
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Verification
 * 
 */
export type Verification = $Result.DefaultSelection<Prisma.$VerificationPayload>
/**
 * Model Organization
 * 
 */
export type Organization = $Result.DefaultSelection<Prisma.$OrganizationPayload>
/**
 * Model Team
 * 
 */
export type Team = $Result.DefaultSelection<Prisma.$TeamPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model OrganizationMembership
 * 
 */
export type OrganizationMembership = $Result.DefaultSelection<Prisma.$OrganizationMembershipPayload>
/**
 * Model TeamMembership
 * 
 */
export type TeamMembership = $Result.DefaultSelection<Prisma.$TeamMembershipPayload>
/**
 * Model Portfolio
 * 
 */
export type Portfolio = $Result.DefaultSelection<Prisma.$PortfolioPayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model Sprint
 * 
 */
export type Sprint = $Result.DefaultSelection<Prisma.$SprintPayload>
/**
 * Model Milestone
 * 
 */
export type Milestone = $Result.DefaultSelection<Prisma.$MilestonePayload>
/**
 * Model Retrospective
 * 
 */
export type Retrospective = $Result.DefaultSelection<Prisma.$RetrospectivePayload>
/**
 * Model WorkItem
 * 
 */
export type WorkItem = $Result.DefaultSelection<Prisma.$WorkItemPayload>
/**
 * Model WorkItemDetail
 * 
 */
export type WorkItemDetail = $Result.DefaultSelection<Prisma.$WorkItemDetailPayload>
/**
 * Model WorkItemState
 * 
 */
export type WorkItemState = $Result.DefaultSelection<Prisma.$WorkItemStatePayload>
/**
 * Model Board
 * 
 */
export type Board = $Result.DefaultSelection<Prisma.$BoardPayload>
/**
 * Model BoardLane
 * 
 */
export type BoardLane = $Result.DefaultSelection<Prisma.$BoardLanePayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>
/**
 * Model TagOnWorkItem
 * 
 */
export type TagOnWorkItem = $Result.DefaultSelection<Prisma.$TagOnWorkItemPayload>
/**
 * Model Component
 * 
 */
export type Component = $Result.DefaultSelection<Prisma.$ComponentPayload>
/**
 * Model ComponentOnWorkItem
 * 
 */
export type ComponentOnWorkItem = $Result.DefaultSelection<Prisma.$ComponentOnWorkItemPayload>
/**
 * Model Dependency
 * 
 */
export type Dependency = $Result.DefaultSelection<Prisma.$DependencyPayload>
/**
 * Model TimeLog
 * 
 */
export type TimeLog = $Result.DefaultSelection<Prisma.$TimeLogPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model Attachment
 * 
 */
export type Attachment = $Result.DefaultSelection<Prisma.$AttachmentPayload>
/**
 * Model WorkItemEmbedding
 * 
 */
export type WorkItemEmbedding = $Result.DefaultSelection<Prisma.$WorkItemEmbeddingPayload>
/**
 * Model WorkItemSnapshot
 * 
 */
export type WorkItemSnapshot = $Result.DefaultSelection<Prisma.$WorkItemSnapshotPayload>
/**
 * Model UserSkillProfile
 * 
 */
export type UserSkillProfile = $Result.DefaultSelection<Prisma.$UserSkillProfilePayload>
/**
 * Model WorkflowRule
 * 
 */
export type WorkflowRule = $Result.DefaultSelection<Prisma.$WorkflowRulePayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model ActivityLog
 * 
 */
export type ActivityLog = $Result.DefaultSelection<Prisma.$ActivityLogPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const WorkItemType: {
  EPIC: 'EPIC',
  FEATURE: 'FEATURE',
  STORY: 'STORY',
  BUG: 'BUG',
  TASK: 'TASK',
  SUB_TASK: 'SUB_TASK'
};

export type WorkItemType = (typeof WorkItemType)[keyof typeof WorkItemType]


export const Priority: {
  CRITICAL: 'CRITICAL',
  HIGH: 'HIGH',
  MEDIUM: 'MEDIUM',
  LOW: 'LOW'
};

export type Priority = (typeof Priority)[keyof typeof Priority]


export const WorkItemStateCategory: {
  TODO: 'TODO',
  IN_PROGRESS: 'IN_PROGRESS',
  DONE: 'DONE',
  ARCHIVED: 'ARCHIVED'
};

export type WorkItemStateCategory = (typeof WorkItemStateCategory)[keyof typeof WorkItemStateCategory]

}

export type WorkItemType = $Enums.WorkItemType

export const WorkItemType: typeof $Enums.WorkItemType

export type Priority = $Enums.Priority

export const Priority: typeof $Enums.Priority

export type WorkItemStateCategory = $Enums.WorkItemStateCategory

export const WorkItemStateCategory: typeof $Enums.WorkItemStateCategory

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verification`: Exposes CRUD operations for the **Verification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Verifications
    * const verifications = await prisma.verification.findMany()
    * ```
    */
  get verification(): Prisma.VerificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.organization`: Exposes CRUD operations for the **Organization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organizations
    * const organizations = await prisma.organization.findMany()
    * ```
    */
  get organization(): Prisma.OrganizationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.team`: Exposes CRUD operations for the **Team** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teams
    * const teams = await prisma.team.findMany()
    * ```
    */
  get team(): Prisma.TeamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.organizationMembership`: Exposes CRUD operations for the **OrganizationMembership** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrganizationMemberships
    * const organizationMemberships = await prisma.organizationMembership.findMany()
    * ```
    */
  get organizationMembership(): Prisma.OrganizationMembershipDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teamMembership`: Exposes CRUD operations for the **TeamMembership** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeamMemberships
    * const teamMemberships = await prisma.teamMembership.findMany()
    * ```
    */
  get teamMembership(): Prisma.TeamMembershipDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.portfolio`: Exposes CRUD operations for the **Portfolio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Portfolios
    * const portfolios = await prisma.portfolio.findMany()
    * ```
    */
  get portfolio(): Prisma.PortfolioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sprint`: Exposes CRUD operations for the **Sprint** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sprints
    * const sprints = await prisma.sprint.findMany()
    * ```
    */
  get sprint(): Prisma.SprintDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.milestone`: Exposes CRUD operations for the **Milestone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Milestones
    * const milestones = await prisma.milestone.findMany()
    * ```
    */
  get milestone(): Prisma.MilestoneDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.retrospective`: Exposes CRUD operations for the **Retrospective** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Retrospectives
    * const retrospectives = await prisma.retrospective.findMany()
    * ```
    */
  get retrospective(): Prisma.RetrospectiveDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workItem`: Exposes CRUD operations for the **WorkItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkItems
    * const workItems = await prisma.workItem.findMany()
    * ```
    */
  get workItem(): Prisma.WorkItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workItemDetail`: Exposes CRUD operations for the **WorkItemDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkItemDetails
    * const workItemDetails = await prisma.workItemDetail.findMany()
    * ```
    */
  get workItemDetail(): Prisma.WorkItemDetailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workItemState`: Exposes CRUD operations for the **WorkItemState** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkItemStates
    * const workItemStates = await prisma.workItemState.findMany()
    * ```
    */
  get workItemState(): Prisma.WorkItemStateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.board`: Exposes CRUD operations for the **Board** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Boards
    * const boards = await prisma.board.findMany()
    * ```
    */
  get board(): Prisma.BoardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.boardLane`: Exposes CRUD operations for the **BoardLane** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BoardLanes
    * const boardLanes = await prisma.boardLane.findMany()
    * ```
    */
  get boardLane(): Prisma.BoardLaneDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tagOnWorkItem`: Exposes CRUD operations for the **TagOnWorkItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TagOnWorkItems
    * const tagOnWorkItems = await prisma.tagOnWorkItem.findMany()
    * ```
    */
  get tagOnWorkItem(): Prisma.TagOnWorkItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.component`: Exposes CRUD operations for the **Component** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Components
    * const components = await prisma.component.findMany()
    * ```
    */
  get component(): Prisma.ComponentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.componentOnWorkItem`: Exposes CRUD operations for the **ComponentOnWorkItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ComponentOnWorkItems
    * const componentOnWorkItems = await prisma.componentOnWorkItem.findMany()
    * ```
    */
  get componentOnWorkItem(): Prisma.ComponentOnWorkItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dependency`: Exposes CRUD operations for the **Dependency** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Dependencies
    * const dependencies = await prisma.dependency.findMany()
    * ```
    */
  get dependency(): Prisma.DependencyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.timeLog`: Exposes CRUD operations for the **TimeLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TimeLogs
    * const timeLogs = await prisma.timeLog.findMany()
    * ```
    */
  get timeLog(): Prisma.TimeLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attachment`: Exposes CRUD operations for the **Attachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attachments
    * const attachments = await prisma.attachment.findMany()
    * ```
    */
  get attachment(): Prisma.AttachmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workItemEmbedding`: Exposes CRUD operations for the **WorkItemEmbedding** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkItemEmbeddings
    * const workItemEmbeddings = await prisma.workItemEmbedding.findMany()
    * ```
    */
  get workItemEmbedding(): Prisma.WorkItemEmbeddingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workItemSnapshot`: Exposes CRUD operations for the **WorkItemSnapshot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkItemSnapshots
    * const workItemSnapshots = await prisma.workItemSnapshot.findMany()
    * ```
    */
  get workItemSnapshot(): Prisma.WorkItemSnapshotDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSkillProfile`: Exposes CRUD operations for the **UserSkillProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSkillProfiles
    * const userSkillProfiles = await prisma.userSkillProfile.findMany()
    * ```
    */
  get userSkillProfile(): Prisma.UserSkillProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workflowRule`: Exposes CRUD operations for the **WorkflowRule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkflowRules
    * const workflowRules = await prisma.workflowRule.findMany()
    * ```
    */
  get workflowRule(): Prisma.WorkflowRuleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activityLog`: Exposes CRUD operations for the **ActivityLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActivityLogs
    * const activityLogs = await prisma.activityLog.findMany()
    * ```
    */
  get activityLog(): Prisma.ActivityLogDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.0
   * Query Engine version: 2ba551f319ab1df4bc874a89965d8b3641056773
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Session: 'Session',
    Account: 'Account',
    Verification: 'Verification',
    Organization: 'Organization',
    Team: 'Team',
    Role: 'Role',
    OrganizationMembership: 'OrganizationMembership',
    TeamMembership: 'TeamMembership',
    Portfolio: 'Portfolio',
    Project: 'Project',
    Sprint: 'Sprint',
    Milestone: 'Milestone',
    Retrospective: 'Retrospective',
    WorkItem: 'WorkItem',
    WorkItemDetail: 'WorkItemDetail',
    WorkItemState: 'WorkItemState',
    Board: 'Board',
    BoardLane: 'BoardLane',
    Tag: 'Tag',
    TagOnWorkItem: 'TagOnWorkItem',
    Component: 'Component',
    ComponentOnWorkItem: 'ComponentOnWorkItem',
    Dependency: 'Dependency',
    TimeLog: 'TimeLog',
    Comment: 'Comment',
    Attachment: 'Attachment',
    WorkItemEmbedding: 'WorkItemEmbedding',
    WorkItemSnapshot: 'WorkItemSnapshot',
    UserSkillProfile: 'UserSkillProfile',
    WorkflowRule: 'WorkflowRule',
    Notification: 'Notification',
    ActivityLog: 'ActivityLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "session" | "account" | "verification" | "organization" | "team" | "role" | "organizationMembership" | "teamMembership" | "portfolio" | "project" | "sprint" | "milestone" | "retrospective" | "workItem" | "workItemDetail" | "workItemState" | "board" | "boardLane" | "tag" | "tagOnWorkItem" | "component" | "componentOnWorkItem" | "dependency" | "timeLog" | "comment" | "attachment" | "workItemEmbedding" | "workItemSnapshot" | "userSkillProfile" | "workflowRule" | "notification" | "activityLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Verification: {
        payload: Prisma.$VerificationPayload<ExtArgs>
        fields: Prisma.VerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findFirst: {
            args: Prisma.VerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findMany: {
            args: Prisma.VerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          create: {
            args: Prisma.VerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          createMany: {
            args: Prisma.VerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          delete: {
            args: Prisma.VerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          update: {
            args: Prisma.VerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          deleteMany: {
            args: Prisma.VerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          upsert: {
            args: Prisma.VerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          aggregate: {
            args: Prisma.VerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerification>
          }
          groupBy: {
            args: Prisma.VerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationCountAggregateOutputType> | number
          }
        }
      }
      Organization: {
        payload: Prisma.$OrganizationPayload<ExtArgs>
        fields: Prisma.OrganizationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findFirst: {
            args: Prisma.OrganizationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findMany: {
            args: Prisma.OrganizationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          create: {
            args: Prisma.OrganizationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          createMany: {
            args: Prisma.OrganizationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrganizationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          delete: {
            args: Prisma.OrganizationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          update: {
            args: Prisma.OrganizationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrganizationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          upsert: {
            args: Prisma.OrganizationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          aggregate: {
            args: Prisma.OrganizationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganization>
          }
          groupBy: {
            args: Prisma.OrganizationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationCountAggregateOutputType> | number
          }
        }
      }
      Team: {
        payload: Prisma.$TeamPayload<ExtArgs>
        fields: Prisma.TeamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findFirst: {
            args: Prisma.TeamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findMany: {
            args: Prisma.TeamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          create: {
            args: Prisma.TeamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          createMany: {
            args: Prisma.TeamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          delete: {
            args: Prisma.TeamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          update: {
            args: Prisma.TeamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          deleteMany: {
            args: Prisma.TeamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeamUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          upsert: {
            args: Prisma.TeamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          aggregate: {
            args: Prisma.TeamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeam>
          }
          groupBy: {
            args: Prisma.TeamGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamCountArgs<ExtArgs>
            result: $Utils.Optional<TeamCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      OrganizationMembership: {
        payload: Prisma.$OrganizationMembershipPayload<ExtArgs>
        fields: Prisma.OrganizationMembershipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationMembershipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMembershipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationMembershipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMembershipPayload>
          }
          findFirst: {
            args: Prisma.OrganizationMembershipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMembershipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationMembershipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMembershipPayload>
          }
          findMany: {
            args: Prisma.OrganizationMembershipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMembershipPayload>[]
          }
          create: {
            args: Prisma.OrganizationMembershipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMembershipPayload>
          }
          createMany: {
            args: Prisma.OrganizationMembershipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrganizationMembershipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMembershipPayload>[]
          }
          delete: {
            args: Prisma.OrganizationMembershipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMembershipPayload>
          }
          update: {
            args: Prisma.OrganizationMembershipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMembershipPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationMembershipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationMembershipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrganizationMembershipUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMembershipPayload>[]
          }
          upsert: {
            args: Prisma.OrganizationMembershipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMembershipPayload>
          }
          aggregate: {
            args: Prisma.OrganizationMembershipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganizationMembership>
          }
          groupBy: {
            args: Prisma.OrganizationMembershipGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationMembershipGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationMembershipCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationMembershipCountAggregateOutputType> | number
          }
        }
      }
      TeamMembership: {
        payload: Prisma.$TeamMembershipPayload<ExtArgs>
        fields: Prisma.TeamMembershipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamMembershipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMembershipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamMembershipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMembershipPayload>
          }
          findFirst: {
            args: Prisma.TeamMembershipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMembershipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamMembershipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMembershipPayload>
          }
          findMany: {
            args: Prisma.TeamMembershipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMembershipPayload>[]
          }
          create: {
            args: Prisma.TeamMembershipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMembershipPayload>
          }
          createMany: {
            args: Prisma.TeamMembershipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamMembershipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMembershipPayload>[]
          }
          delete: {
            args: Prisma.TeamMembershipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMembershipPayload>
          }
          update: {
            args: Prisma.TeamMembershipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMembershipPayload>
          }
          deleteMany: {
            args: Prisma.TeamMembershipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamMembershipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeamMembershipUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMembershipPayload>[]
          }
          upsert: {
            args: Prisma.TeamMembershipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMembershipPayload>
          }
          aggregate: {
            args: Prisma.TeamMembershipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeamMembership>
          }
          groupBy: {
            args: Prisma.TeamMembershipGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamMembershipGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamMembershipCountArgs<ExtArgs>
            result: $Utils.Optional<TeamMembershipCountAggregateOutputType> | number
          }
        }
      }
      Portfolio: {
        payload: Prisma.$PortfolioPayload<ExtArgs>
        fields: Prisma.PortfolioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PortfolioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PortfolioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload>
          }
          findFirst: {
            args: Prisma.PortfolioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PortfolioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload>
          }
          findMany: {
            args: Prisma.PortfolioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload>[]
          }
          create: {
            args: Prisma.PortfolioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload>
          }
          createMany: {
            args: Prisma.PortfolioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PortfolioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload>[]
          }
          delete: {
            args: Prisma.PortfolioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload>
          }
          update: {
            args: Prisma.PortfolioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload>
          }
          deleteMany: {
            args: Prisma.PortfolioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PortfolioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PortfolioUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload>[]
          }
          upsert: {
            args: Prisma.PortfolioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioPayload>
          }
          aggregate: {
            args: Prisma.PortfolioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePortfolio>
          }
          groupBy: {
            args: Prisma.PortfolioGroupByArgs<ExtArgs>
            result: $Utils.Optional<PortfolioGroupByOutputType>[]
          }
          count: {
            args: Prisma.PortfolioCountArgs<ExtArgs>
            result: $Utils.Optional<PortfolioCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      Sprint: {
        payload: Prisma.$SprintPayload<ExtArgs>
        fields: Prisma.SprintFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SprintFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SprintPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SprintFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SprintPayload>
          }
          findFirst: {
            args: Prisma.SprintFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SprintPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SprintFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SprintPayload>
          }
          findMany: {
            args: Prisma.SprintFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SprintPayload>[]
          }
          create: {
            args: Prisma.SprintCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SprintPayload>
          }
          createMany: {
            args: Prisma.SprintCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SprintCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SprintPayload>[]
          }
          delete: {
            args: Prisma.SprintDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SprintPayload>
          }
          update: {
            args: Prisma.SprintUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SprintPayload>
          }
          deleteMany: {
            args: Prisma.SprintDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SprintUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SprintUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SprintPayload>[]
          }
          upsert: {
            args: Prisma.SprintUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SprintPayload>
          }
          aggregate: {
            args: Prisma.SprintAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSprint>
          }
          groupBy: {
            args: Prisma.SprintGroupByArgs<ExtArgs>
            result: $Utils.Optional<SprintGroupByOutputType>[]
          }
          count: {
            args: Prisma.SprintCountArgs<ExtArgs>
            result: $Utils.Optional<SprintCountAggregateOutputType> | number
          }
        }
      }
      Milestone: {
        payload: Prisma.$MilestonePayload<ExtArgs>
        fields: Prisma.MilestoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MilestoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MilestoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          findFirst: {
            args: Prisma.MilestoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MilestoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          findMany: {
            args: Prisma.MilestoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>[]
          }
          create: {
            args: Prisma.MilestoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          createMany: {
            args: Prisma.MilestoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MilestoneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>[]
          }
          delete: {
            args: Prisma.MilestoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          update: {
            args: Prisma.MilestoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          deleteMany: {
            args: Prisma.MilestoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MilestoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MilestoneUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>[]
          }
          upsert: {
            args: Prisma.MilestoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          aggregate: {
            args: Prisma.MilestoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMilestone>
          }
          groupBy: {
            args: Prisma.MilestoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<MilestoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.MilestoneCountArgs<ExtArgs>
            result: $Utils.Optional<MilestoneCountAggregateOutputType> | number
          }
        }
      }
      Retrospective: {
        payload: Prisma.$RetrospectivePayload<ExtArgs>
        fields: Prisma.RetrospectiveFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RetrospectiveFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetrospectivePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RetrospectiveFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetrospectivePayload>
          }
          findFirst: {
            args: Prisma.RetrospectiveFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetrospectivePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RetrospectiveFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetrospectivePayload>
          }
          findMany: {
            args: Prisma.RetrospectiveFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetrospectivePayload>[]
          }
          create: {
            args: Prisma.RetrospectiveCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetrospectivePayload>
          }
          createMany: {
            args: Prisma.RetrospectiveCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RetrospectiveCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetrospectivePayload>[]
          }
          delete: {
            args: Prisma.RetrospectiveDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetrospectivePayload>
          }
          update: {
            args: Prisma.RetrospectiveUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetrospectivePayload>
          }
          deleteMany: {
            args: Prisma.RetrospectiveDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RetrospectiveUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RetrospectiveUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetrospectivePayload>[]
          }
          upsert: {
            args: Prisma.RetrospectiveUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RetrospectivePayload>
          }
          aggregate: {
            args: Prisma.RetrospectiveAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRetrospective>
          }
          groupBy: {
            args: Prisma.RetrospectiveGroupByArgs<ExtArgs>
            result: $Utils.Optional<RetrospectiveGroupByOutputType>[]
          }
          count: {
            args: Prisma.RetrospectiveCountArgs<ExtArgs>
            result: $Utils.Optional<RetrospectiveCountAggregateOutputType> | number
          }
        }
      }
      WorkItem: {
        payload: Prisma.$WorkItemPayload<ExtArgs>
        fields: Prisma.WorkItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkItemPayload>
          }
          findFirst: {
            args: Prisma.WorkItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkItemPayload>
          }
          findMany: {
            args: Prisma.WorkItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkItemPayload>[]
          }
          create: {
            args: Prisma.WorkItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkItemPayload>
          }
          createMany: {
            args: Prisma.WorkItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkItemPayload>[]
          }
          delete: {
            args: Prisma.WorkItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkItemPayload>
          }
          update: {
            args: Prisma.WorkItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkItemPayload>
          }
          deleteMany: {
            args: Prisma.WorkItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkItemPayload>[]
          }
          upsert: {
            args: Prisma.WorkItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkItemPayload>
          }
          aggregate: {
            args: Prisma.WorkItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkItem>
          }
          groupBy: {
            args: Prisma.WorkItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkItemCountArgs<ExtArgs>
            result: $Utils.Optional<WorkItemCountAggregateOutputType> | number
          }
        }
      }
      WorkItemDetail: {
        payload: Prisma.$WorkItemDetailPayload<ExtArgs>
        fields: Prisma.WorkItemDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkItemDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkItemDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkItemDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkItemDetailPayload>
          }
          findFirst: {
            args: Prisma.WorkItemDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkItemDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkItemDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkItemDetailPayload>
          }
          findMany: {
            args: Prisma.WorkItemDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkItemDetailPayload>[]
          }
          create: {
            args: Prisma.WorkItemDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkItemDetailPayload>
          }
          createMany: {
            args: Prisma.WorkItemDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkItemDetailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkItemDetailPayload>[]
          }
          delete: {
            args: Prisma.WorkItemDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkItemDetailPayload>
          }
          update: {
            args: Prisma.WorkItemDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkItemDetailPayload>
          }
          deleteMany: {
            args: Prisma.WorkItemDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkItemDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkItemDetailUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkItemDetailPayload>[]
          }
          upsert: {
            args: Prisma.WorkItemDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkItemDetailPayload>
          }
          aggregate: {
            args: Prisma.WorkItemDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkItemDetail>
          }
          groupBy: {
            args: Prisma.WorkItemDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkItemDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkItemDetailCountArgs<ExtArgs>
            result: $Utils.Optional<WorkItemDetailCountAggregateOutputType> | number
          }
        }
      }
      WorkItemState: {
        payload: Prisma.$WorkItemStatePayload<ExtArgs>
        fields: Prisma.WorkItemStateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkItemStateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkItemStatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkItemStateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkItemStatePayload>
          }
          findFirst: {
            args: Prisma.WorkItemStateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkItemStatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkItemStateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkItemStatePayload>
          }
          findMany: {
            args: Prisma.WorkItemStateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkItemStatePayload>[]
          }
          create: {
            args: Prisma.WorkItemStateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkItemStatePayload>
          }
          createMany: {
            args: Prisma.WorkItemStateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkItemStateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkItemStatePayload>[]
          }
          delete: {
            args: Prisma.WorkItemStateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkItemStatePayload>
          }
          update: {
            args: Prisma.WorkItemStateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkItemStatePayload>
          }
          deleteMany: {
            args: Prisma.WorkItemStateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkItemStateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkItemStateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkItemStatePayload>[]
          }
          upsert: {
            args: Prisma.WorkItemStateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkItemStatePayload>
          }
          aggregate: {
            args: Prisma.WorkItemStateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkItemState>
          }
          groupBy: {
            args: Prisma.WorkItemStateGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkItemStateGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkItemStateCountArgs<ExtArgs>
            result: $Utils.Optional<WorkItemStateCountAggregateOutputType> | number
          }
        }
      }
      Board: {
        payload: Prisma.$BoardPayload<ExtArgs>
        fields: Prisma.BoardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BoardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BoardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>
          }
          findFirst: {
            args: Prisma.BoardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BoardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>
          }
          findMany: {
            args: Prisma.BoardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>[]
          }
          create: {
            args: Prisma.BoardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>
          }
          createMany: {
            args: Prisma.BoardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BoardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>[]
          }
          delete: {
            args: Prisma.BoardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>
          }
          update: {
            args: Prisma.BoardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>
          }
          deleteMany: {
            args: Prisma.BoardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BoardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BoardUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>[]
          }
          upsert: {
            args: Prisma.BoardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>
          }
          aggregate: {
            args: Prisma.BoardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBoard>
          }
          groupBy: {
            args: Prisma.BoardGroupByArgs<ExtArgs>
            result: $Utils.Optional<BoardGroupByOutputType>[]
          }
          count: {
            args: Prisma.BoardCountArgs<ExtArgs>
            result: $Utils.Optional<BoardCountAggregateOutputType> | number
          }
        }
      }
      BoardLane: {
        payload: Prisma.$BoardLanePayload<ExtArgs>
        fields: Prisma.BoardLaneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BoardLaneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardLanePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BoardLaneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardLanePayload>
          }
          findFirst: {
            args: Prisma.BoardLaneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardLanePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BoardLaneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardLanePayload>
          }
          findMany: {
            args: Prisma.BoardLaneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardLanePayload>[]
          }
          create: {
            args: Prisma.BoardLaneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardLanePayload>
          }
          createMany: {
            args: Prisma.BoardLaneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BoardLaneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardLanePayload>[]
          }
          delete: {
            args: Prisma.BoardLaneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardLanePayload>
          }
          update: {
            args: Prisma.BoardLaneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardLanePayload>
          }
          deleteMany: {
            args: Prisma.BoardLaneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BoardLaneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BoardLaneUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardLanePayload>[]
          }
          upsert: {
            args: Prisma.BoardLaneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardLanePayload>
          }
          aggregate: {
            args: Prisma.BoardLaneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBoardLane>
          }
          groupBy: {
            args: Prisma.BoardLaneGroupByArgs<ExtArgs>
            result: $Utils.Optional<BoardLaneGroupByOutputType>[]
          }
          count: {
            args: Prisma.BoardLaneCountArgs<ExtArgs>
            result: $Utils.Optional<BoardLaneCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      TagOnWorkItem: {
        payload: Prisma.$TagOnWorkItemPayload<ExtArgs>
        fields: Prisma.TagOnWorkItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagOnWorkItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagOnWorkItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagOnWorkItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagOnWorkItemPayload>
          }
          findFirst: {
            args: Prisma.TagOnWorkItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagOnWorkItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagOnWorkItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagOnWorkItemPayload>
          }
          findMany: {
            args: Prisma.TagOnWorkItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagOnWorkItemPayload>[]
          }
          create: {
            args: Prisma.TagOnWorkItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagOnWorkItemPayload>
          }
          createMany: {
            args: Prisma.TagOnWorkItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagOnWorkItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagOnWorkItemPayload>[]
          }
          delete: {
            args: Prisma.TagOnWorkItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagOnWorkItemPayload>
          }
          update: {
            args: Prisma.TagOnWorkItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagOnWorkItemPayload>
          }
          deleteMany: {
            args: Prisma.TagOnWorkItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagOnWorkItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TagOnWorkItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagOnWorkItemPayload>[]
          }
          upsert: {
            args: Prisma.TagOnWorkItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagOnWorkItemPayload>
          }
          aggregate: {
            args: Prisma.TagOnWorkItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTagOnWorkItem>
          }
          groupBy: {
            args: Prisma.TagOnWorkItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagOnWorkItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagOnWorkItemCountArgs<ExtArgs>
            result: $Utils.Optional<TagOnWorkItemCountAggregateOutputType> | number
          }
        }
      }
      Component: {
        payload: Prisma.$ComponentPayload<ExtArgs>
        fields: Prisma.ComponentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComponentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComponentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload>
          }
          findFirst: {
            args: Prisma.ComponentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComponentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload>
          }
          findMany: {
            args: Prisma.ComponentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload>[]
          }
          create: {
            args: Prisma.ComponentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload>
          }
          createMany: {
            args: Prisma.ComponentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ComponentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload>[]
          }
          delete: {
            args: Prisma.ComponentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload>
          }
          update: {
            args: Prisma.ComponentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload>
          }
          deleteMany: {
            args: Prisma.ComponentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComponentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ComponentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload>[]
          }
          upsert: {
            args: Prisma.ComponentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload>
          }
          aggregate: {
            args: Prisma.ComponentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComponent>
          }
          groupBy: {
            args: Prisma.ComponentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComponentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComponentCountArgs<ExtArgs>
            result: $Utils.Optional<ComponentCountAggregateOutputType> | number
          }
        }
      }
      ComponentOnWorkItem: {
        payload: Prisma.$ComponentOnWorkItemPayload<ExtArgs>
        fields: Prisma.ComponentOnWorkItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComponentOnWorkItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentOnWorkItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComponentOnWorkItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentOnWorkItemPayload>
          }
          findFirst: {
            args: Prisma.ComponentOnWorkItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentOnWorkItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComponentOnWorkItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentOnWorkItemPayload>
          }
          findMany: {
            args: Prisma.ComponentOnWorkItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentOnWorkItemPayload>[]
          }
          create: {
            args: Prisma.ComponentOnWorkItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentOnWorkItemPayload>
          }
          createMany: {
            args: Prisma.ComponentOnWorkItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ComponentOnWorkItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentOnWorkItemPayload>[]
          }
          delete: {
            args: Prisma.ComponentOnWorkItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentOnWorkItemPayload>
          }
          update: {
            args: Prisma.ComponentOnWorkItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentOnWorkItemPayload>
          }
          deleteMany: {
            args: Prisma.ComponentOnWorkItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComponentOnWorkItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ComponentOnWorkItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentOnWorkItemPayload>[]
          }
          upsert: {
            args: Prisma.ComponentOnWorkItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentOnWorkItemPayload>
          }
          aggregate: {
            args: Prisma.ComponentOnWorkItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComponentOnWorkItem>
          }
          groupBy: {
            args: Prisma.ComponentOnWorkItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComponentOnWorkItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComponentOnWorkItemCountArgs<ExtArgs>
            result: $Utils.Optional<ComponentOnWorkItemCountAggregateOutputType> | number
          }
        }
      }
      Dependency: {
        payload: Prisma.$DependencyPayload<ExtArgs>
        fields: Prisma.DependencyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DependencyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DependencyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DependencyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DependencyPayload>
          }
          findFirst: {
            args: Prisma.DependencyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DependencyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DependencyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DependencyPayload>
          }
          findMany: {
            args: Prisma.DependencyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DependencyPayload>[]
          }
          create: {
            args: Prisma.DependencyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DependencyPayload>
          }
          createMany: {
            args: Prisma.DependencyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DependencyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DependencyPayload>[]
          }
          delete: {
            args: Prisma.DependencyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DependencyPayload>
          }
          update: {
            args: Prisma.DependencyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DependencyPayload>
          }
          deleteMany: {
            args: Prisma.DependencyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DependencyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DependencyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DependencyPayload>[]
          }
          upsert: {
            args: Prisma.DependencyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DependencyPayload>
          }
          aggregate: {
            args: Prisma.DependencyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDependency>
          }
          groupBy: {
            args: Prisma.DependencyGroupByArgs<ExtArgs>
            result: $Utils.Optional<DependencyGroupByOutputType>[]
          }
          count: {
            args: Prisma.DependencyCountArgs<ExtArgs>
            result: $Utils.Optional<DependencyCountAggregateOutputType> | number
          }
        }
      }
      TimeLog: {
        payload: Prisma.$TimeLogPayload<ExtArgs>
        fields: Prisma.TimeLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TimeLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TimeLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeLogPayload>
          }
          findFirst: {
            args: Prisma.TimeLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TimeLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeLogPayload>
          }
          findMany: {
            args: Prisma.TimeLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeLogPayload>[]
          }
          create: {
            args: Prisma.TimeLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeLogPayload>
          }
          createMany: {
            args: Prisma.TimeLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TimeLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeLogPayload>[]
          }
          delete: {
            args: Prisma.TimeLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeLogPayload>
          }
          update: {
            args: Prisma.TimeLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeLogPayload>
          }
          deleteMany: {
            args: Prisma.TimeLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TimeLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TimeLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeLogPayload>[]
          }
          upsert: {
            args: Prisma.TimeLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeLogPayload>
          }
          aggregate: {
            args: Prisma.TimeLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTimeLog>
          }
          groupBy: {
            args: Prisma.TimeLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<TimeLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.TimeLogCountArgs<ExtArgs>
            result: $Utils.Optional<TimeLogCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      Attachment: {
        payload: Prisma.$AttachmentPayload<ExtArgs>
        fields: Prisma.AttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          findFirst: {
            args: Prisma.AttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          findMany: {
            args: Prisma.AttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>[]
          }
          create: {
            args: Prisma.AttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          createMany: {
            args: Prisma.AttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>[]
          }
          delete: {
            args: Prisma.AttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          update: {
            args: Prisma.AttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          deleteMany: {
            args: Prisma.AttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttachmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>[]
          }
          upsert: {
            args: Prisma.AttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          aggregate: {
            args: Prisma.AttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttachment>
          }
          groupBy: {
            args: Prisma.AttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<AttachmentCountAggregateOutputType> | number
          }
        }
      }
      WorkItemEmbedding: {
        payload: Prisma.$WorkItemEmbeddingPayload<ExtArgs>
        fields: Prisma.WorkItemEmbeddingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkItemEmbeddingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkItemEmbeddingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkItemEmbeddingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkItemEmbeddingPayload>
          }
          findFirst: {
            args: Prisma.WorkItemEmbeddingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkItemEmbeddingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkItemEmbeddingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkItemEmbeddingPayload>
          }
          findMany: {
            args: Prisma.WorkItemEmbeddingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkItemEmbeddingPayload>[]
          }
          delete: {
            args: Prisma.WorkItemEmbeddingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkItemEmbeddingPayload>
          }
          update: {
            args: Prisma.WorkItemEmbeddingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkItemEmbeddingPayload>
          }
          deleteMany: {
            args: Prisma.WorkItemEmbeddingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkItemEmbeddingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkItemEmbeddingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkItemEmbeddingPayload>[]
          }
          aggregate: {
            args: Prisma.WorkItemEmbeddingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkItemEmbedding>
          }
          groupBy: {
            args: Prisma.WorkItemEmbeddingGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkItemEmbeddingGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkItemEmbeddingCountArgs<ExtArgs>
            result: $Utils.Optional<WorkItemEmbeddingCountAggregateOutputType> | number
          }
        }
      }
      WorkItemSnapshot: {
        payload: Prisma.$WorkItemSnapshotPayload<ExtArgs>
        fields: Prisma.WorkItemSnapshotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkItemSnapshotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkItemSnapshotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkItemSnapshotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkItemSnapshotPayload>
          }
          findFirst: {
            args: Prisma.WorkItemSnapshotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkItemSnapshotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkItemSnapshotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkItemSnapshotPayload>
          }
          findMany: {
            args: Prisma.WorkItemSnapshotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkItemSnapshotPayload>[]
          }
          create: {
            args: Prisma.WorkItemSnapshotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkItemSnapshotPayload>
          }
          createMany: {
            args: Prisma.WorkItemSnapshotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkItemSnapshotCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkItemSnapshotPayload>[]
          }
          delete: {
            args: Prisma.WorkItemSnapshotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkItemSnapshotPayload>
          }
          update: {
            args: Prisma.WorkItemSnapshotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkItemSnapshotPayload>
          }
          deleteMany: {
            args: Prisma.WorkItemSnapshotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkItemSnapshotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkItemSnapshotUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkItemSnapshotPayload>[]
          }
          upsert: {
            args: Prisma.WorkItemSnapshotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkItemSnapshotPayload>
          }
          aggregate: {
            args: Prisma.WorkItemSnapshotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkItemSnapshot>
          }
          groupBy: {
            args: Prisma.WorkItemSnapshotGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkItemSnapshotGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkItemSnapshotCountArgs<ExtArgs>
            result: $Utils.Optional<WorkItemSnapshotCountAggregateOutputType> | number
          }
        }
      }
      UserSkillProfile: {
        payload: Prisma.$UserSkillProfilePayload<ExtArgs>
        fields: Prisma.UserSkillProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSkillProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSkillProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillProfilePayload>
          }
          findFirst: {
            args: Prisma.UserSkillProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSkillProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillProfilePayload>
          }
          findMany: {
            args: Prisma.UserSkillProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillProfilePayload>[]
          }
          create: {
            args: Prisma.UserSkillProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillProfilePayload>
          }
          createMany: {
            args: Prisma.UserSkillProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSkillProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillProfilePayload>[]
          }
          delete: {
            args: Prisma.UserSkillProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillProfilePayload>
          }
          update: {
            args: Prisma.UserSkillProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillProfilePayload>
          }
          deleteMany: {
            args: Prisma.UserSkillProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSkillProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserSkillProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillProfilePayload>[]
          }
          upsert: {
            args: Prisma.UserSkillProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSkillProfilePayload>
          }
          aggregate: {
            args: Prisma.UserSkillProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSkillProfile>
          }
          groupBy: {
            args: Prisma.UserSkillProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSkillProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSkillProfileCountArgs<ExtArgs>
            result: $Utils.Optional<UserSkillProfileCountAggregateOutputType> | number
          }
        }
      }
      WorkflowRule: {
        payload: Prisma.$WorkflowRulePayload<ExtArgs>
        fields: Prisma.WorkflowRuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkflowRuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowRulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkflowRuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowRulePayload>
          }
          findFirst: {
            args: Prisma.WorkflowRuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowRulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkflowRuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowRulePayload>
          }
          findMany: {
            args: Prisma.WorkflowRuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowRulePayload>[]
          }
          create: {
            args: Prisma.WorkflowRuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowRulePayload>
          }
          createMany: {
            args: Prisma.WorkflowRuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkflowRuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowRulePayload>[]
          }
          delete: {
            args: Prisma.WorkflowRuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowRulePayload>
          }
          update: {
            args: Prisma.WorkflowRuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowRulePayload>
          }
          deleteMany: {
            args: Prisma.WorkflowRuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkflowRuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkflowRuleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowRulePayload>[]
          }
          upsert: {
            args: Prisma.WorkflowRuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowRulePayload>
          }
          aggregate: {
            args: Prisma.WorkflowRuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkflowRule>
          }
          groupBy: {
            args: Prisma.WorkflowRuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkflowRuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkflowRuleCountArgs<ExtArgs>
            result: $Utils.Optional<WorkflowRuleCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      ActivityLog: {
        payload: Prisma.$ActivityLogPayload<ExtArgs>
        fields: Prisma.ActivityLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findFirst: {
            args: Prisma.ActivityLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findMany: {
            args: Prisma.ActivityLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          create: {
            args: Prisma.ActivityLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          createMany: {
            args: Prisma.ActivityLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          delete: {
            args: Prisma.ActivityLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          update: {
            args: Prisma.ActivityLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          deleteMany: {
            args: Prisma.ActivityLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActivityLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          upsert: {
            args: Prisma.ActivityLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          aggregate: {
            args: Prisma.ActivityLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivityLog>
          }
          groupBy: {
            args: Prisma.ActivityLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityLogCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    session?: SessionOmit
    account?: AccountOmit
    verification?: VerificationOmit
    organization?: OrganizationOmit
    team?: TeamOmit
    role?: RoleOmit
    organizationMembership?: OrganizationMembershipOmit
    teamMembership?: TeamMembershipOmit
    portfolio?: PortfolioOmit
    project?: ProjectOmit
    sprint?: SprintOmit
    milestone?: MilestoneOmit
    retrospective?: RetrospectiveOmit
    workItem?: WorkItemOmit
    workItemDetail?: WorkItemDetailOmit
    workItemState?: WorkItemStateOmit
    board?: BoardOmit
    boardLane?: BoardLaneOmit
    tag?: TagOmit
    tagOnWorkItem?: TagOnWorkItemOmit
    component?: ComponentOmit
    componentOnWorkItem?: ComponentOnWorkItemOmit
    dependency?: DependencyOmit
    timeLog?: TimeLogOmit
    comment?: CommentOmit
    attachment?: AttachmentOmit
    workItemEmbedding?: WorkItemEmbeddingOmit
    workItemSnapshot?: WorkItemSnapshotOmit
    userSkillProfile?: UserSkillProfileOmit
    workflowRule?: WorkflowRuleOmit
    notification?: NotificationOmit
    activityLog?: ActivityLogOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    sessions: number
    accounts: number
    organizationMemberships: number
    teamMemberships: number
    ownedProjects: number
    assignedWorkItems: number
    createdWorkItems: number
    comments: number
    timeLogs: number
    notifications: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    organizationMemberships?: boolean | UserCountOutputTypeCountOrganizationMembershipsArgs
    teamMemberships?: boolean | UserCountOutputTypeCountTeamMembershipsArgs
    ownedProjects?: boolean | UserCountOutputTypeCountOwnedProjectsArgs
    assignedWorkItems?: boolean | UserCountOutputTypeCountAssignedWorkItemsArgs
    createdWorkItems?: boolean | UserCountOutputTypeCountCreatedWorkItemsArgs
    comments?: boolean | UserCountOutputTypeCountCommentsArgs
    timeLogs?: boolean | UserCountOutputTypeCountTimeLogsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrganizationMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationMembershipWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTeamMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMembershipWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedWorkItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkItemWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedWorkItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkItemWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTimeLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type OrganizationCountOutputType
   */

  export type OrganizationCountOutputType = {
    users: number
    portfolios: number
    teams: number
    projects: number
  }

  export type OrganizationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | OrganizationCountOutputTypeCountUsersArgs
    portfolios?: boolean | OrganizationCountOutputTypeCountPortfoliosArgs
    teams?: boolean | OrganizationCountOutputTypeCountTeamsArgs
    projects?: boolean | OrganizationCountOutputTypeCountProjectsArgs
  }

  // Custom InputTypes
  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationCountOutputType
     */
    select?: OrganizationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationMembershipWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountPortfoliosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PortfolioWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountTeamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }


  /**
   * Count Type TeamCountOutputType
   */

  export type TeamCountOutputType = {
    members: number
    projects: number
    skillProfiles: number
  }

  export type TeamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | TeamCountOutputTypeCountMembersArgs
    projects?: boolean | TeamCountOutputTypeCountProjectsArgs
    skillProfiles?: boolean | TeamCountOutputTypeCountSkillProfilesArgs
  }

  // Custom InputTypes
  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamCountOutputType
     */
    select?: TeamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMembershipWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountSkillProfilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSkillProfileWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    teamMemberships: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teamMemberships?: boolean | RoleCountOutputTypeCountTeamMembershipsArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountTeamMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMembershipWhereInput
  }


  /**
   * Count Type PortfolioCountOutputType
   */

  export type PortfolioCountOutputType = {
    projects: number
  }

  export type PortfolioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | PortfolioCountOutputTypeCountProjectsArgs
  }

  // Custom InputTypes
  /**
   * PortfolioCountOutputType without action
   */
  export type PortfolioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioCountOutputType
     */
    select?: PortfolioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PortfolioCountOutputType without action
   */
  export type PortfolioCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    workItems: number
    sprints: number
    milestones: number
    boards: number
    workflowRules: number
    workItemStates: number
    components: number
    teams: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workItems?: boolean | ProjectCountOutputTypeCountWorkItemsArgs
    sprints?: boolean | ProjectCountOutputTypeCountSprintsArgs
    milestones?: boolean | ProjectCountOutputTypeCountMilestonesArgs
    boards?: boolean | ProjectCountOutputTypeCountBoardsArgs
    workflowRules?: boolean | ProjectCountOutputTypeCountWorkflowRulesArgs
    workItemStates?: boolean | ProjectCountOutputTypeCountWorkItemStatesArgs
    components?: boolean | ProjectCountOutputTypeCountComponentsArgs
    teams?: boolean | ProjectCountOutputTypeCountTeamsArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountWorkItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkItemWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountSprintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SprintWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountMilestonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MilestoneWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountBoardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BoardWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountWorkflowRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowRuleWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountWorkItemStatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkItemStateWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountComponentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComponentWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountTeamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
  }


  /**
   * Count Type SprintCountOutputType
   */

  export type SprintCountOutputType = {
    workItems: number
    snapshots: number
    timeLogs: number
    boards: number
  }

  export type SprintCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workItems?: boolean | SprintCountOutputTypeCountWorkItemsArgs
    snapshots?: boolean | SprintCountOutputTypeCountSnapshotsArgs
    timeLogs?: boolean | SprintCountOutputTypeCountTimeLogsArgs
    boards?: boolean | SprintCountOutputTypeCountBoardsArgs
  }

  // Custom InputTypes
  /**
   * SprintCountOutputType without action
   */
  export type SprintCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SprintCountOutputType
     */
    select?: SprintCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SprintCountOutputType without action
   */
  export type SprintCountOutputTypeCountWorkItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkItemWhereInput
  }

  /**
   * SprintCountOutputType without action
   */
  export type SprintCountOutputTypeCountSnapshotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkItemSnapshotWhereInput
  }

  /**
   * SprintCountOutputType without action
   */
  export type SprintCountOutputTypeCountTimeLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeLogWhereInput
  }

  /**
   * SprintCountOutputType without action
   */
  export type SprintCountOutputTypeCountBoardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BoardWhereInput
  }


  /**
   * Count Type WorkItemCountOutputType
   */

  export type WorkItemCountOutputType = {
    children: number
    stories: number
    dependenciesAsSource: number
    dependenciesAsTarget: number
    comments: number
    attachments: number
    timeLogs: number
    snapshots: number
    tags: number
    components: number
  }

  export type WorkItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | WorkItemCountOutputTypeCountChildrenArgs
    stories?: boolean | WorkItemCountOutputTypeCountStoriesArgs
    dependenciesAsSource?: boolean | WorkItemCountOutputTypeCountDependenciesAsSourceArgs
    dependenciesAsTarget?: boolean | WorkItemCountOutputTypeCountDependenciesAsTargetArgs
    comments?: boolean | WorkItemCountOutputTypeCountCommentsArgs
    attachments?: boolean | WorkItemCountOutputTypeCountAttachmentsArgs
    timeLogs?: boolean | WorkItemCountOutputTypeCountTimeLogsArgs
    snapshots?: boolean | WorkItemCountOutputTypeCountSnapshotsArgs
    tags?: boolean | WorkItemCountOutputTypeCountTagsArgs
    components?: boolean | WorkItemCountOutputTypeCountComponentsArgs
  }

  // Custom InputTypes
  /**
   * WorkItemCountOutputType without action
   */
  export type WorkItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItemCountOutputType
     */
    select?: WorkItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkItemCountOutputType without action
   */
  export type WorkItemCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkItemWhereInput
  }

  /**
   * WorkItemCountOutputType without action
   */
  export type WorkItemCountOutputTypeCountStoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkItemWhereInput
  }

  /**
   * WorkItemCountOutputType without action
   */
  export type WorkItemCountOutputTypeCountDependenciesAsSourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DependencyWhereInput
  }

  /**
   * WorkItemCountOutputType without action
   */
  export type WorkItemCountOutputTypeCountDependenciesAsTargetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DependencyWhereInput
  }

  /**
   * WorkItemCountOutputType without action
   */
  export type WorkItemCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * WorkItemCountOutputType without action
   */
  export type WorkItemCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttachmentWhereInput
  }

  /**
   * WorkItemCountOutputType without action
   */
  export type WorkItemCountOutputTypeCountTimeLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeLogWhereInput
  }

  /**
   * WorkItemCountOutputType without action
   */
  export type WorkItemCountOutputTypeCountSnapshotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkItemSnapshotWhereInput
  }

  /**
   * WorkItemCountOutputType without action
   */
  export type WorkItemCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagOnWorkItemWhereInput
  }

  /**
   * WorkItemCountOutputType without action
   */
  export type WorkItemCountOutputTypeCountComponentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComponentOnWorkItemWhereInput
  }


  /**
   * Count Type WorkItemStateCountOutputType
   */

  export type WorkItemStateCountOutputType = {
    workItems: number
  }

  export type WorkItemStateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workItems?: boolean | WorkItemStateCountOutputTypeCountWorkItemsArgs
  }

  // Custom InputTypes
  /**
   * WorkItemStateCountOutputType without action
   */
  export type WorkItemStateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItemStateCountOutputType
     */
    select?: WorkItemStateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkItemStateCountOutputType without action
   */
  export type WorkItemStateCountOutputTypeCountWorkItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkItemWhereInput
  }


  /**
   * Count Type BoardCountOutputType
   */

  export type BoardCountOutputType = {
    lanes: number
  }

  export type BoardCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lanes?: boolean | BoardCountOutputTypeCountLanesArgs
  }

  // Custom InputTypes
  /**
   * BoardCountOutputType without action
   */
  export type BoardCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardCountOutputType
     */
    select?: BoardCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BoardCountOutputType without action
   */
  export type BoardCountOutputTypeCountLanesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BoardLaneWhereInput
  }


  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    workItems: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workItems?: boolean | TagCountOutputTypeCountWorkItemsArgs
  }

  // Custom InputTypes
  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountWorkItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagOnWorkItemWhereInput
  }


  /**
   * Count Type ComponentCountOutputType
   */

  export type ComponentCountOutputType = {
    workItems: number
  }

  export type ComponentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workItems?: boolean | ComponentCountOutputTypeCountWorkItemsArgs
  }

  // Custom InputTypes
  /**
   * ComponentCountOutputType without action
   */
  export type ComponentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentCountOutputType
     */
    select?: ComponentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ComponentCountOutputType without action
   */
  export type ComponentCountOutputTypeCountWorkItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComponentOnWorkItemWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    availabilityHours: number | null
  }

  export type UserSumAggregateOutputType = {
    availabilityHours: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    image: string | null
    passwordHash: string | null
    firstName: string | null
    lastName: string | null
    avatarUrl: string | null
    timezone: string | null
    availabilityHours: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    image: string | null
    passwordHash: string | null
    firstName: string | null
    lastName: string | null
    avatarUrl: string | null
    timezone: string | null
    availabilityHours: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    image: number
    passwordHash: number
    firstName: number
    lastName: number
    avatarUrl: number
    timezone: number
    availabilityHours: number
    isActive: number
    preferences: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    availabilityHours?: true
  }

  export type UserSumAggregateInputType = {
    availabilityHours?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    avatarUrl?: true
    timezone?: true
    availabilityHours?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    avatarUrl?: true
    timezone?: true
    availabilityHours?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    avatarUrl?: true
    timezone?: true
    availabilityHours?: true
    isActive?: true
    preferences?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string | null
    email: string
    emailVerified: boolean
    image: string | null
    passwordHash: string | null
    firstName: string
    lastName: string
    avatarUrl: string | null
    timezone: string
    availabilityHours: number
    isActive: boolean
    preferences: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    avatarUrl?: boolean
    timezone?: boolean
    availabilityHours?: boolean
    isActive?: boolean
    preferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    organizationMemberships?: boolean | User$organizationMembershipsArgs<ExtArgs>
    teamMemberships?: boolean | User$teamMembershipsArgs<ExtArgs>
    ownedProjects?: boolean | User$ownedProjectsArgs<ExtArgs>
    assignedWorkItems?: boolean | User$assignedWorkItemsArgs<ExtArgs>
    createdWorkItems?: boolean | User$createdWorkItemsArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    timeLogs?: boolean | User$timeLogsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    skillProfile?: boolean | User$skillProfileArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    avatarUrl?: boolean
    timezone?: boolean
    availabilityHours?: boolean
    isActive?: boolean
    preferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    avatarUrl?: boolean
    timezone?: boolean
    availabilityHours?: boolean
    isActive?: boolean
    preferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    avatarUrl?: boolean
    timezone?: boolean
    availabilityHours?: boolean
    isActive?: boolean
    preferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "emailVerified" | "image" | "passwordHash" | "firstName" | "lastName" | "avatarUrl" | "timezone" | "availabilityHours" | "isActive" | "preferences" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    organizationMemberships?: boolean | User$organizationMembershipsArgs<ExtArgs>
    teamMemberships?: boolean | User$teamMembershipsArgs<ExtArgs>
    ownedProjects?: boolean | User$ownedProjectsArgs<ExtArgs>
    assignedWorkItems?: boolean | User$assignedWorkItemsArgs<ExtArgs>
    createdWorkItems?: boolean | User$createdWorkItemsArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    timeLogs?: boolean | User$timeLogsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    skillProfile?: boolean | User$skillProfileArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      organizationMemberships: Prisma.$OrganizationMembershipPayload<ExtArgs>[]
      teamMemberships: Prisma.$TeamMembershipPayload<ExtArgs>[]
      ownedProjects: Prisma.$ProjectPayload<ExtArgs>[]
      assignedWorkItems: Prisma.$WorkItemPayload<ExtArgs>[]
      createdWorkItems: Prisma.$WorkItemPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      timeLogs: Prisma.$TimeLogPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      skillProfile: Prisma.$UserSkillProfilePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      email: string
      emailVerified: boolean
      image: string | null
      passwordHash: string | null
      firstName: string
      lastName: string
      avatarUrl: string | null
      timezone: string
      availabilityHours: number
      isActive: boolean
      preferences: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    organizationMemberships<T extends User$organizationMembershipsArgs<ExtArgs> = {}>(args?: Subset<T, User$organizationMembershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teamMemberships<T extends User$teamMembershipsArgs<ExtArgs> = {}>(args?: Subset<T, User$teamMembershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ownedProjects<T extends User$ownedProjectsArgs<ExtArgs> = {}>(args?: Subset<T, User$ownedProjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignedWorkItems<T extends User$assignedWorkItemsArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedWorkItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdWorkItems<T extends User$createdWorkItemsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdWorkItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends User$commentsArgs<ExtArgs> = {}>(args?: Subset<T, User$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    timeLogs<T extends User$timeLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$timeLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    skillProfile<T extends User$skillProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$skillProfileArgs<ExtArgs>>): Prisma__UserSkillProfileClient<$Result.GetResult<Prisma.$UserSkillProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly image: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly avatarUrl: FieldRef<"User", 'String'>
    readonly timezone: FieldRef<"User", 'String'>
    readonly availabilityHours: FieldRef<"User", 'Int'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly preferences: FieldRef<"User", 'Json'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.organizationMemberships
   */
  export type User$organizationMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMembership
     */
    select?: OrganizationMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMembership
     */
    omit?: OrganizationMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMembershipInclude<ExtArgs> | null
    where?: OrganizationMembershipWhereInput
    orderBy?: OrganizationMembershipOrderByWithRelationInput | OrganizationMembershipOrderByWithRelationInput[]
    cursor?: OrganizationMembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrganizationMembershipScalarFieldEnum | OrganizationMembershipScalarFieldEnum[]
  }

  /**
   * User.teamMemberships
   */
  export type User$teamMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMembership
     */
    select?: TeamMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMembership
     */
    omit?: TeamMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMembershipInclude<ExtArgs> | null
    where?: TeamMembershipWhereInput
    orderBy?: TeamMembershipOrderByWithRelationInput | TeamMembershipOrderByWithRelationInput[]
    cursor?: TeamMembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamMembershipScalarFieldEnum | TeamMembershipScalarFieldEnum[]
  }

  /**
   * User.ownedProjects
   */
  export type User$ownedProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * User.assignedWorkItems
   */
  export type User$assignedWorkItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItem
     */
    select?: WorkItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItem
     */
    omit?: WorkItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemInclude<ExtArgs> | null
    where?: WorkItemWhereInput
    orderBy?: WorkItemOrderByWithRelationInput | WorkItemOrderByWithRelationInput[]
    cursor?: WorkItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkItemScalarFieldEnum | WorkItemScalarFieldEnum[]
  }

  /**
   * User.createdWorkItems
   */
  export type User$createdWorkItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItem
     */
    select?: WorkItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItem
     */
    omit?: WorkItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemInclude<ExtArgs> | null
    where?: WorkItemWhereInput
    orderBy?: WorkItemOrderByWithRelationInput | WorkItemOrderByWithRelationInput[]
    cursor?: WorkItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkItemScalarFieldEnum | WorkItemScalarFieldEnum[]
  }

  /**
   * User.comments
   */
  export type User$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * User.timeLogs
   */
  export type User$timeLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeLog
     */
    select?: TimeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeLog
     */
    omit?: TimeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeLogInclude<ExtArgs> | null
    where?: TimeLogWhereInput
    orderBy?: TimeLogOrderByWithRelationInput | TimeLogOrderByWithRelationInput[]
    cursor?: TimeLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimeLogScalarFieldEnum | TimeLogScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.skillProfile
   */
  export type User$skillProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkillProfile
     */
    select?: UserSkillProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkillProfile
     */
    omit?: UserSkillProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillProfileInclude<ExtArgs> | null
    where?: UserSkillProfileWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    expiresAt: Date | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    userId: string | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    expiresAt: Date | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    userId: string | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    expiresAt: number
    token: number
    createdAt: number
    updatedAt: number
    ipAddress: number
    userAgent: number
    userId: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    expiresAt: Date
    token: string
    createdAt: Date
    updatedAt: Date
    ipAddress: string | null
    userAgent: string | null
    userId: string
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "expiresAt" | "token" | "createdAt" | "updatedAt" | "ipAddress" | "userAgent" | "userId", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      expiresAt: Date
      token: string
      createdAt: Date
      updatedAt: Date
      ipAddress: string | null
      userAgent: string | null
      userId: string
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly token: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    providerId: string | null
    userId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    providerId: string | null
    userId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    accountId: number
    providerId: number
    userId: number
    accessToken: number
    refreshToken: number
    idToken: number
    accessTokenExpiresAt: number
    refreshTokenExpiresAt: number
    scope: number
    password: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    accountId: string
    providerId: string
    userId: string
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accountId" | "providerId" | "userId" | "accessToken" | "refreshToken" | "idToken" | "accessTokenExpiresAt" | "refreshTokenExpiresAt" | "scope" | "password" | "createdAt" | "updatedAt", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      providerId: string
      userId: string
      accessToken: string | null
      refreshToken: string | null
      idToken: string | null
      accessTokenExpiresAt: Date | null
      refreshTokenExpiresAt: Date | null
      scope: string | null
      password: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly accountId: FieldRef<"Account", 'String'>
    readonly providerId: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly accessToken: FieldRef<"Account", 'String'>
    readonly refreshToken: FieldRef<"Account", 'String'>
    readonly idToken: FieldRef<"Account", 'String'>
    readonly accessTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly refreshTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly password: FieldRef<"Account", 'String'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Verification
   */

  export type AggregateVerification = {
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  export type VerificationMinAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationMaxAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationCountAggregateOutputType = {
    id: number
    identifier: number
    value: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VerificationMinAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationMaxAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationCountAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verification to aggregate.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Verifications
    **/
    _count?: true | VerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationMaxAggregateInputType
  }

  export type GetVerificationAggregateType<T extends VerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerification[P]>
      : GetScalarType<T[P], AggregateVerification[P]>
  }




  export type VerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationWhereInput
    orderBy?: VerificationOrderByWithAggregationInput | VerificationOrderByWithAggregationInput[]
    by: VerificationScalarFieldEnum[] | VerificationScalarFieldEnum
    having?: VerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationCountAggregateInputType | true
    _min?: VerificationMinAggregateInputType
    _max?: VerificationMaxAggregateInputType
  }

  export type VerificationGroupByOutputType = {
    id: string
    identifier: string
    value: string
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  type GetVerificationGroupByPayload<T extends VerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationGroupByOutputType[P]>
        }
      >
    >


  export type VerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectScalar = {
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VerificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "identifier" | "value" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["verification"]>

  export type $VerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Verification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      identifier: string
      value: string
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["verification"]>
    composites: {}
  }

  type VerificationGetPayload<S extends boolean | null | undefined | VerificationDefaultArgs> = $Result.GetResult<Prisma.$VerificationPayload, S>

  type VerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationCountAggregateInputType | true
    }

  export interface VerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Verification'], meta: { name: 'Verification' } }
    /**
     * Find zero or one Verification that matches the filter.
     * @param {VerificationFindUniqueArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationFindUniqueArgs>(args: SelectSubset<T, VerificationFindUniqueArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Verification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationFindUniqueOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationFindFirstArgs>(args?: SelectSubset<T, VerificationFindFirstArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Verifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Verifications
     * const verifications = await prisma.verification.findMany()
     * 
     * // Get first 10 Verifications
     * const verifications = await prisma.verification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationWithIdOnly = await prisma.verification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationFindManyArgs>(args?: SelectSubset<T, VerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Verification.
     * @param {VerificationCreateArgs} args - Arguments to create a Verification.
     * @example
     * // Create one Verification
     * const Verification = await prisma.verification.create({
     *   data: {
     *     // ... data to create a Verification
     *   }
     * })
     * 
     */
    create<T extends VerificationCreateArgs>(args: SelectSubset<T, VerificationCreateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Verifications.
     * @param {VerificationCreateManyArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationCreateManyArgs>(args?: SelectSubset<T, VerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Verifications and returns the data saved in the database.
     * @param {VerificationCreateManyAndReturnArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Verification.
     * @param {VerificationDeleteArgs} args - Arguments to delete one Verification.
     * @example
     * // Delete one Verification
     * const Verification = await prisma.verification.delete({
     *   where: {
     *     // ... filter to delete one Verification
     *   }
     * })
     * 
     */
    delete<T extends VerificationDeleteArgs>(args: SelectSubset<T, VerificationDeleteArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Verification.
     * @param {VerificationUpdateArgs} args - Arguments to update one Verification.
     * @example
     * // Update one Verification
     * const verification = await prisma.verification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationUpdateArgs>(args: SelectSubset<T, VerificationUpdateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Verifications.
     * @param {VerificationDeleteManyArgs} args - Arguments to filter Verifications to delete.
     * @example
     * // Delete a few Verifications
     * const { count } = await prisma.verification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationDeleteManyArgs>(args?: SelectSubset<T, VerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationUpdateManyArgs>(args: SelectSubset<T, VerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications and returns the data updated in the database.
     * @param {VerificationUpdateManyAndReturnArgs} args - Arguments to update many Verifications.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Verification.
     * @param {VerificationUpsertArgs} args - Arguments to update or create a Verification.
     * @example
     * // Update or create a Verification
     * const verification = await prisma.verification.upsert({
     *   create: {
     *     // ... data to create a Verification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Verification we want to update
     *   }
     * })
     */
    upsert<T extends VerificationUpsertArgs>(args: SelectSubset<T, VerificationUpsertArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCountArgs} args - Arguments to filter Verifications to count.
     * @example
     * // Count the number of Verifications
     * const count = await prisma.verification.count({
     *   where: {
     *     // ... the filter for the Verifications we want to count
     *   }
     * })
    **/
    count<T extends VerificationCountArgs>(
      args?: Subset<T, VerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationAggregateArgs>(args: Subset<T, VerificationAggregateArgs>): Prisma.PrismaPromise<GetVerificationAggregateType<T>>

    /**
     * Group by Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationGroupByArgs['orderBy'] }
        : { orderBy?: VerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Verification model
   */
  readonly fields: VerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Verification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Verification model
   */
  interface VerificationFieldRefs {
    readonly id: FieldRef<"Verification", 'String'>
    readonly identifier: FieldRef<"Verification", 'String'>
    readonly value: FieldRef<"Verification", 'String'>
    readonly expiresAt: FieldRef<"Verification", 'DateTime'>
    readonly createdAt: FieldRef<"Verification", 'DateTime'>
    readonly updatedAt: FieldRef<"Verification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Verification findUnique
   */
  export type VerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findUniqueOrThrow
   */
  export type VerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findFirst
   */
  export type VerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findFirstOrThrow
   */
  export type VerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findMany
   */
  export type VerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verifications to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification create
   */
  export type VerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to create a Verification.
     */
    data: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
  }

  /**
   * Verification createMany
   */
  export type VerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification createManyAndReturn
   */
  export type VerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification update
   */
  export type VerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to update a Verification.
     */
    data: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
    /**
     * Choose, which Verification to update.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification updateMany
   */
  export type VerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification updateManyAndReturn
   */
  export type VerificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification upsert
   */
  export type VerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The filter to search for the Verification to update in case it exists.
     */
    where: VerificationWhereUniqueInput
    /**
     * In case the Verification found by the `where` argument doesn't exist, create a new Verification with this data.
     */
    create: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
    /**
     * In case the Verification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
  }

  /**
   * Verification delete
   */
  export type VerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter which Verification to delete.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification deleteMany
   */
  export type VerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verifications to delete
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to delete.
     */
    limit?: number
  }

  /**
   * Verification without action
   */
  export type VerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
  }


  /**
   * Model Organization
   */

  export type AggregateOrganization = {
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  export type OrganizationMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    planTier: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    planTier: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    planTier: number
    settings: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrganizationMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    planTier?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    planTier?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    planTier?: true
    settings?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrganizationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organization to aggregate.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Organizations
    **/
    _count?: true | OrganizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationMaxAggregateInputType
  }

  export type GetOrganizationAggregateType<T extends OrganizationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganization[P]>
      : GetScalarType<T[P], AggregateOrganization[P]>
  }




  export type OrganizationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationWhereInput
    orderBy?: OrganizationOrderByWithAggregationInput | OrganizationOrderByWithAggregationInput[]
    by: OrganizationScalarFieldEnum[] | OrganizationScalarFieldEnum
    having?: OrganizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationCountAggregateInputType | true
    _min?: OrganizationMinAggregateInputType
    _max?: OrganizationMaxAggregateInputType
  }

  export type OrganizationGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    planTier: string
    settings: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  type GetOrganizationGroupByPayload<T extends OrganizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    planTier?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Organization$usersArgs<ExtArgs>
    portfolios?: boolean | Organization$portfoliosArgs<ExtArgs>
    teams?: boolean | Organization$teamsArgs<ExtArgs>
    projects?: boolean | Organization$projectsArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    planTier?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    planTier?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    planTier?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrganizationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "description" | "planTier" | "settings" | "createdAt" | "updatedAt", ExtArgs["result"]["organization"]>
  export type OrganizationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Organization$usersArgs<ExtArgs>
    portfolios?: boolean | Organization$portfoliosArgs<ExtArgs>
    teams?: boolean | Organization$teamsArgs<ExtArgs>
    projects?: boolean | Organization$projectsArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrganizationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type OrganizationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OrganizationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Organization"
    objects: {
      users: Prisma.$OrganizationMembershipPayload<ExtArgs>[]
      portfolios: Prisma.$PortfolioPayload<ExtArgs>[]
      teams: Prisma.$TeamPayload<ExtArgs>[]
      projects: Prisma.$ProjectPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      planTier: string
      settings: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["organization"]>
    composites: {}
  }

  type OrganizationGetPayload<S extends boolean | null | undefined | OrganizationDefaultArgs> = $Result.GetResult<Prisma.$OrganizationPayload, S>

  type OrganizationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrganizationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrganizationCountAggregateInputType | true
    }

  export interface OrganizationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Organization'], meta: { name: 'Organization' } }
    /**
     * Find zero or one Organization that matches the filter.
     * @param {OrganizationFindUniqueArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationFindUniqueArgs>(args: SelectSubset<T, OrganizationFindUniqueArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Organization that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrganizationFindUniqueOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationFindFirstArgs>(args?: SelectSubset<T, OrganizationFindFirstArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations
     * const organizations = await prisma.organization.findMany()
     * 
     * // Get first 10 Organizations
     * const organizations = await prisma.organization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationWithIdOnly = await prisma.organization.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganizationFindManyArgs>(args?: SelectSubset<T, OrganizationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Organization.
     * @param {OrganizationCreateArgs} args - Arguments to create a Organization.
     * @example
     * // Create one Organization
     * const Organization = await prisma.organization.create({
     *   data: {
     *     // ... data to create a Organization
     *   }
     * })
     * 
     */
    create<T extends OrganizationCreateArgs>(args: SelectSubset<T, OrganizationCreateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Organizations.
     * @param {OrganizationCreateManyArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizationCreateManyArgs>(args?: SelectSubset<T, OrganizationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Organizations and returns the data saved in the database.
     * @param {OrganizationCreateManyAndReturnArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrganizationCreateManyAndReturnArgs>(args?: SelectSubset<T, OrganizationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Organization.
     * @param {OrganizationDeleteArgs} args - Arguments to delete one Organization.
     * @example
     * // Delete one Organization
     * const Organization = await prisma.organization.delete({
     *   where: {
     *     // ... filter to delete one Organization
     *   }
     * })
     * 
     */
    delete<T extends OrganizationDeleteArgs>(args: SelectSubset<T, OrganizationDeleteArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Organization.
     * @param {OrganizationUpdateArgs} args - Arguments to update one Organization.
     * @example
     * // Update one Organization
     * const organization = await prisma.organization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizationUpdateArgs>(args: SelectSubset<T, OrganizationUpdateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Organizations.
     * @param {OrganizationDeleteManyArgs} args - Arguments to filter Organizations to delete.
     * @example
     * // Delete a few Organizations
     * const { count } = await prisma.organization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizationDeleteManyArgs>(args?: SelectSubset<T, OrganizationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizationUpdateManyArgs>(args: SelectSubset<T, OrganizationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations and returns the data updated in the database.
     * @param {OrganizationUpdateManyAndReturnArgs} args - Arguments to update many Organizations.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrganizationUpdateManyAndReturnArgs>(args: SelectSubset<T, OrganizationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Organization.
     * @param {OrganizationUpsertArgs} args - Arguments to update or create a Organization.
     * @example
     * // Update or create a Organization
     * const organization = await prisma.organization.upsert({
     *   create: {
     *     // ... data to create a Organization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organization we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationUpsertArgs>(args: SelectSubset<T, OrganizationUpsertArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationCountArgs} args - Arguments to filter Organizations to count.
     * @example
     * // Count the number of Organizations
     * const count = await prisma.organization.count({
     *   where: {
     *     // ... the filter for the Organizations we want to count
     *   }
     * })
    **/
    count<T extends OrganizationCountArgs>(
      args?: Subset<T, OrganizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationAggregateArgs>(args: Subset<T, OrganizationAggregateArgs>): Prisma.PrismaPromise<GetOrganizationAggregateType<T>>

    /**
     * Group by Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Organization model
   */
  readonly fields: OrganizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Organization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Organization$usersArgs<ExtArgs> = {}>(args?: Subset<T, Organization$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    portfolios<T extends Organization$portfoliosArgs<ExtArgs> = {}>(args?: Subset<T, Organization$portfoliosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teams<T extends Organization$teamsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$teamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projects<T extends Organization$projectsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Organization model
   */
  interface OrganizationFieldRefs {
    readonly id: FieldRef<"Organization", 'String'>
    readonly name: FieldRef<"Organization", 'String'>
    readonly slug: FieldRef<"Organization", 'String'>
    readonly description: FieldRef<"Organization", 'String'>
    readonly planTier: FieldRef<"Organization", 'String'>
    readonly settings: FieldRef<"Organization", 'Json'>
    readonly createdAt: FieldRef<"Organization", 'DateTime'>
    readonly updatedAt: FieldRef<"Organization", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Organization findUnique
   */
  export type OrganizationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findUniqueOrThrow
   */
  export type OrganizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findFirst
   */
  export type OrganizationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findFirstOrThrow
   */
  export type OrganizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findMany
   */
  export type OrganizationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organizations to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization create
   */
  export type OrganizationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to create a Organization.
     */
    data: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
  }

  /**
   * Organization createMany
   */
  export type OrganizationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization createManyAndReturn
   */
  export type OrganizationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization update
   */
  export type OrganizationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to update a Organization.
     */
    data: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
    /**
     * Choose, which Organization to update.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization updateMany
   */
  export type OrganizationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to update.
     */
    limit?: number
  }

  /**
   * Organization updateManyAndReturn
   */
  export type OrganizationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to update.
     */
    limit?: number
  }

  /**
   * Organization upsert
   */
  export type OrganizationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The filter to search for the Organization to update in case it exists.
     */
    where: OrganizationWhereUniqueInput
    /**
     * In case the Organization found by the `where` argument doesn't exist, create a new Organization with this data.
     */
    create: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
    /**
     * In case the Organization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
  }

  /**
   * Organization delete
   */
  export type OrganizationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter which Organization to delete.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization deleteMany
   */
  export type OrganizationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organizations to delete
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to delete.
     */
    limit?: number
  }

  /**
   * Organization.users
   */
  export type Organization$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMembership
     */
    select?: OrganizationMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMembership
     */
    omit?: OrganizationMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMembershipInclude<ExtArgs> | null
    where?: OrganizationMembershipWhereInput
    orderBy?: OrganizationMembershipOrderByWithRelationInput | OrganizationMembershipOrderByWithRelationInput[]
    cursor?: OrganizationMembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrganizationMembershipScalarFieldEnum | OrganizationMembershipScalarFieldEnum[]
  }

  /**
   * Organization.portfolios
   */
  export type Organization$portfoliosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    where?: PortfolioWhereInput
    orderBy?: PortfolioOrderByWithRelationInput | PortfolioOrderByWithRelationInput[]
    cursor?: PortfolioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PortfolioScalarFieldEnum | PortfolioScalarFieldEnum[]
  }

  /**
   * Organization.teams
   */
  export type Organization$teamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    cursor?: TeamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Organization.projects
   */
  export type Organization$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Organization without action
   */
  export type OrganizationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
  }


  /**
   * Model Team
   */

  export type AggregateTeam = {
    _count: TeamCountAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  export type TeamMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    organizationId: string | null
  }

  export type TeamMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    organizationId: string | null
  }

  export type TeamCountAggregateOutputType = {
    id: number
    name: number
    description: number
    velocityHistory: number
    settings: number
    createdAt: number
    updatedAt: number
    organizationId: number
    _all: number
  }


  export type TeamMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    organizationId?: true
  }

  export type TeamMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    organizationId?: true
  }

  export type TeamCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    velocityHistory?: true
    settings?: true
    createdAt?: true
    updatedAt?: true
    organizationId?: true
    _all?: true
  }

  export type TeamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Team to aggregate.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teams
    **/
    _count?: true | TeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMaxAggregateInputType
  }

  export type GetTeamAggregateType<T extends TeamAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam[P]>
      : GetScalarType<T[P], AggregateTeam[P]>
  }




  export type TeamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithAggregationInput | TeamOrderByWithAggregationInput[]
    by: TeamScalarFieldEnum[] | TeamScalarFieldEnum
    having?: TeamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamCountAggregateInputType | true
    _min?: TeamMinAggregateInputType
    _max?: TeamMaxAggregateInputType
  }

  export type TeamGroupByOutputType = {
    id: string
    name: string
    description: string | null
    velocityHistory: JsonValue
    settings: JsonValue
    createdAt: Date
    updatedAt: Date
    organizationId: string
    _count: TeamCountAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  type GetTeamGroupByPayload<T extends TeamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamGroupByOutputType[P]>
            : GetScalarType<T[P], TeamGroupByOutputType[P]>
        }
      >
    >


  export type TeamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    velocityHistory?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organizationId?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    members?: boolean | Team$membersArgs<ExtArgs>
    projects?: boolean | Team$projectsArgs<ExtArgs>
    skillProfiles?: boolean | Team$skillProfilesArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    velocityHistory?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organizationId?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    velocityHistory?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organizationId?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    velocityHistory?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organizationId?: boolean
  }

  export type TeamOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "velocityHistory" | "settings" | "createdAt" | "updatedAt" | "organizationId", ExtArgs["result"]["team"]>
  export type TeamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    members?: boolean | Team$membersArgs<ExtArgs>
    projects?: boolean | Team$projectsArgs<ExtArgs>
    skillProfiles?: boolean | Team$skillProfilesArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TeamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type TeamIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $TeamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Team"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      members: Prisma.$TeamMembershipPayload<ExtArgs>[]
      projects: Prisma.$ProjectPayload<ExtArgs>[]
      skillProfiles: Prisma.$UserSkillProfilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      velocityHistory: Prisma.JsonValue
      settings: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
      organizationId: string
    }, ExtArgs["result"]["team"]>
    composites: {}
  }

  type TeamGetPayload<S extends boolean | null | undefined | TeamDefaultArgs> = $Result.GetResult<Prisma.$TeamPayload, S>

  type TeamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamCountAggregateInputType | true
    }

  export interface TeamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Team'], meta: { name: 'Team' } }
    /**
     * Find zero or one Team that matches the filter.
     * @param {TeamFindUniqueArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamFindUniqueArgs>(args: SelectSubset<T, TeamFindUniqueArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Team that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamFindUniqueOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamFindFirstArgs>(args?: SelectSubset<T, TeamFindFirstArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teams
     * const teams = await prisma.team.findMany()
     * 
     * // Get first 10 Teams
     * const teams = await prisma.team.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamWithIdOnly = await prisma.team.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamFindManyArgs>(args?: SelectSubset<T, TeamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Team.
     * @param {TeamCreateArgs} args - Arguments to create a Team.
     * @example
     * // Create one Team
     * const Team = await prisma.team.create({
     *   data: {
     *     // ... data to create a Team
     *   }
     * })
     * 
     */
    create<T extends TeamCreateArgs>(args: SelectSubset<T, TeamCreateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Teams.
     * @param {TeamCreateManyArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamCreateManyArgs>(args?: SelectSubset<T, TeamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teams and returns the data saved in the database.
     * @param {TeamCreateManyAndReturnArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teams and only return the `id`
     * const teamWithIdOnly = await prisma.team.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Team.
     * @param {TeamDeleteArgs} args - Arguments to delete one Team.
     * @example
     * // Delete one Team
     * const Team = await prisma.team.delete({
     *   where: {
     *     // ... filter to delete one Team
     *   }
     * })
     * 
     */
    delete<T extends TeamDeleteArgs>(args: SelectSubset<T, TeamDeleteArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Team.
     * @param {TeamUpdateArgs} args - Arguments to update one Team.
     * @example
     * // Update one Team
     * const team = await prisma.team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamUpdateArgs>(args: SelectSubset<T, TeamUpdateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Teams.
     * @param {TeamDeleteManyArgs} args - Arguments to filter Teams to delete.
     * @example
     * // Delete a few Teams
     * const { count } = await prisma.team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamDeleteManyArgs>(args?: SelectSubset<T, TeamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamUpdateManyArgs>(args: SelectSubset<T, TeamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams and returns the data updated in the database.
     * @param {TeamUpdateManyAndReturnArgs} args - Arguments to update many Teams.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Teams and only return the `id`
     * const teamWithIdOnly = await prisma.team.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeamUpdateManyAndReturnArgs>(args: SelectSubset<T, TeamUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Team.
     * @param {TeamUpsertArgs} args - Arguments to update or create a Team.
     * @example
     * // Update or create a Team
     * const team = await prisma.team.upsert({
     *   create: {
     *     // ... data to create a Team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team we want to update
     *   }
     * })
     */
    upsert<T extends TeamUpsertArgs>(args: SelectSubset<T, TeamUpsertArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamCountArgs} args - Arguments to filter Teams to count.
     * @example
     * // Count the number of Teams
     * const count = await prisma.team.count({
     *   where: {
     *     // ... the filter for the Teams we want to count
     *   }
     * })
    **/
    count<T extends TeamCountArgs>(
      args?: Subset<T, TeamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamAggregateArgs>(args: Subset<T, TeamAggregateArgs>): Prisma.PrismaPromise<GetTeamAggregateType<T>>

    /**
     * Group by Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamGroupByArgs['orderBy'] }
        : { orderBy?: TeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Team model
   */
  readonly fields: TeamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    members<T extends Team$membersArgs<ExtArgs> = {}>(args?: Subset<T, Team$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projects<T extends Team$projectsArgs<ExtArgs> = {}>(args?: Subset<T, Team$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    skillProfiles<T extends Team$skillProfilesArgs<ExtArgs> = {}>(args?: Subset<T, Team$skillProfilesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSkillProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Team model
   */
  interface TeamFieldRefs {
    readonly id: FieldRef<"Team", 'String'>
    readonly name: FieldRef<"Team", 'String'>
    readonly description: FieldRef<"Team", 'String'>
    readonly velocityHistory: FieldRef<"Team", 'Json'>
    readonly settings: FieldRef<"Team", 'Json'>
    readonly createdAt: FieldRef<"Team", 'DateTime'>
    readonly updatedAt: FieldRef<"Team", 'DateTime'>
    readonly organizationId: FieldRef<"Team", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Team findUnique
   */
  export type TeamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findUniqueOrThrow
   */
  export type TeamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findFirst
   */
  export type TeamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findFirstOrThrow
   */
  export type TeamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findMany
   */
  export type TeamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Teams to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team create
   */
  export type TeamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to create a Team.
     */
    data: XOR<TeamCreateInput, TeamUncheckedCreateInput>
  }

  /**
   * Team createMany
   */
  export type TeamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Team createManyAndReturn
   */
  export type TeamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Team update
   */
  export type TeamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to update a Team.
     */
    data: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
    /**
     * Choose, which Team to update.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team updateMany
   */
  export type TeamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to update.
     */
    limit?: number
  }

  /**
   * Team updateManyAndReturn
   */
  export type TeamUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Team upsert
   */
  export type TeamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The filter to search for the Team to update in case it exists.
     */
    where: TeamWhereUniqueInput
    /**
     * In case the Team found by the `where` argument doesn't exist, create a new Team with this data.
     */
    create: XOR<TeamCreateInput, TeamUncheckedCreateInput>
    /**
     * In case the Team was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
  }

  /**
   * Team delete
   */
  export type TeamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter which Team to delete.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team deleteMany
   */
  export type TeamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teams to delete
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to delete.
     */
    limit?: number
  }

  /**
   * Team.members
   */
  export type Team$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMembership
     */
    select?: TeamMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMembership
     */
    omit?: TeamMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMembershipInclude<ExtArgs> | null
    where?: TeamMembershipWhereInput
    orderBy?: TeamMembershipOrderByWithRelationInput | TeamMembershipOrderByWithRelationInput[]
    cursor?: TeamMembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamMembershipScalarFieldEnum | TeamMembershipScalarFieldEnum[]
  }

  /**
   * Team.projects
   */
  export type Team$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Team.skillProfiles
   */
  export type Team$skillProfilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkillProfile
     */
    select?: UserSkillProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkillProfile
     */
    omit?: UserSkillProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillProfileInclude<ExtArgs> | null
    where?: UserSkillProfileWhereInput
    orderBy?: UserSkillProfileOrderByWithRelationInput | UserSkillProfileOrderByWithRelationInput[]
    cursor?: UserSkillProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSkillProfileScalarFieldEnum | UserSkillProfileScalarFieldEnum[]
  }

  /**
   * Team without action
   */
  export type TeamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    description: number
    permissions: number
    createdAt: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    permissions?: true
    createdAt?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: string
    name: string
    description: string | null
    permissions: JsonValue
    createdAt: Date
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    permissions?: boolean
    createdAt?: boolean
    teamMemberships?: boolean | Role$teamMembershipsArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    permissions?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    permissions?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    permissions?: boolean
    createdAt?: boolean
  }

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "permissions" | "createdAt", ExtArgs["result"]["role"]>
  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teamMemberships?: boolean | Role$teamMembershipsArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      teamMemberships: Prisma.$TeamMembershipPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      permissions: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {RoleUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoleUpdateManyAndReturnArgs>(args: SelectSubset<T, RoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    teamMemberships<T extends Role$teamMembershipsArgs<ExtArgs> = {}>(args?: Subset<T, Role$teamMembershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'String'>
    readonly name: FieldRef<"Role", 'String'>
    readonly description: FieldRef<"Role", 'String'>
    readonly permissions: FieldRef<"Role", 'Json'>
    readonly createdAt: FieldRef<"Role", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role updateManyAndReturn
   */
  export type RoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Role.teamMemberships
   */
  export type Role$teamMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMembership
     */
    select?: TeamMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMembership
     */
    omit?: TeamMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMembershipInclude<ExtArgs> | null
    where?: TeamMembershipWhereInput
    orderBy?: TeamMembershipOrderByWithRelationInput | TeamMembershipOrderByWithRelationInput[]
    cursor?: TeamMembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamMembershipScalarFieldEnum | TeamMembershipScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model OrganizationMembership
   */

  export type AggregateOrganizationMembership = {
    _count: OrganizationMembershipCountAggregateOutputType | null
    _min: OrganizationMembershipMinAggregateOutputType | null
    _max: OrganizationMembershipMaxAggregateOutputType | null
  }

  export type OrganizationMembershipMinAggregateOutputType = {
    id: string | null
    userId: string | null
    organizationId: string | null
    role: string | null
    joinedAt: Date | null
  }

  export type OrganizationMembershipMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    organizationId: string | null
    role: string | null
    joinedAt: Date | null
  }

  export type OrganizationMembershipCountAggregateOutputType = {
    id: number
    userId: number
    organizationId: number
    role: number
    joinedAt: number
    _all: number
  }


  export type OrganizationMembershipMinAggregateInputType = {
    id?: true
    userId?: true
    organizationId?: true
    role?: true
    joinedAt?: true
  }

  export type OrganizationMembershipMaxAggregateInputType = {
    id?: true
    userId?: true
    organizationId?: true
    role?: true
    joinedAt?: true
  }

  export type OrganizationMembershipCountAggregateInputType = {
    id?: true
    userId?: true
    organizationId?: true
    role?: true
    joinedAt?: true
    _all?: true
  }

  export type OrganizationMembershipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrganizationMembership to aggregate.
     */
    where?: OrganizationMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationMemberships to fetch.
     */
    orderBy?: OrganizationMembershipOrderByWithRelationInput | OrganizationMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrganizationMemberships
    **/
    _count?: true | OrganizationMembershipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationMembershipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationMembershipMaxAggregateInputType
  }

  export type GetOrganizationMembershipAggregateType<T extends OrganizationMembershipAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganizationMembership]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganizationMembership[P]>
      : GetScalarType<T[P], AggregateOrganizationMembership[P]>
  }




  export type OrganizationMembershipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationMembershipWhereInput
    orderBy?: OrganizationMembershipOrderByWithAggregationInput | OrganizationMembershipOrderByWithAggregationInput[]
    by: OrganizationMembershipScalarFieldEnum[] | OrganizationMembershipScalarFieldEnum
    having?: OrganizationMembershipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationMembershipCountAggregateInputType | true
    _min?: OrganizationMembershipMinAggregateInputType
    _max?: OrganizationMembershipMaxAggregateInputType
  }

  export type OrganizationMembershipGroupByOutputType = {
    id: string
    userId: string
    organizationId: string
    role: string
    joinedAt: Date
    _count: OrganizationMembershipCountAggregateOutputType | null
    _min: OrganizationMembershipMinAggregateOutputType | null
    _max: OrganizationMembershipMaxAggregateOutputType | null
  }

  type GetOrganizationMembershipGroupByPayload<T extends OrganizationMembershipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationMembershipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationMembershipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationMembershipGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationMembershipGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationMembershipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    organizationId?: boolean
    role?: boolean
    joinedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organizationMembership"]>

  export type OrganizationMembershipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    organizationId?: boolean
    role?: boolean
    joinedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organizationMembership"]>

  export type OrganizationMembershipSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    organizationId?: boolean
    role?: boolean
    joinedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organizationMembership"]>

  export type OrganizationMembershipSelectScalar = {
    id?: boolean
    userId?: boolean
    organizationId?: boolean
    role?: boolean
    joinedAt?: boolean
  }

  export type OrganizationMembershipOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "organizationId" | "role" | "joinedAt", ExtArgs["result"]["organizationMembership"]>
  export type OrganizationMembershipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type OrganizationMembershipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type OrganizationMembershipIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $OrganizationMembershipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrganizationMembership"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      organization: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      organizationId: string
      role: string
      joinedAt: Date
    }, ExtArgs["result"]["organizationMembership"]>
    composites: {}
  }

  type OrganizationMembershipGetPayload<S extends boolean | null | undefined | OrganizationMembershipDefaultArgs> = $Result.GetResult<Prisma.$OrganizationMembershipPayload, S>

  type OrganizationMembershipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrganizationMembershipFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrganizationMembershipCountAggregateInputType | true
    }

  export interface OrganizationMembershipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrganizationMembership'], meta: { name: 'OrganizationMembership' } }
    /**
     * Find zero or one OrganizationMembership that matches the filter.
     * @param {OrganizationMembershipFindUniqueArgs} args - Arguments to find a OrganizationMembership
     * @example
     * // Get one OrganizationMembership
     * const organizationMembership = await prisma.organizationMembership.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationMembershipFindUniqueArgs>(args: SelectSubset<T, OrganizationMembershipFindUniqueArgs<ExtArgs>>): Prisma__OrganizationMembershipClient<$Result.GetResult<Prisma.$OrganizationMembershipPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrganizationMembership that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrganizationMembershipFindUniqueOrThrowArgs} args - Arguments to find a OrganizationMembership
     * @example
     * // Get one OrganizationMembership
     * const organizationMembership = await prisma.organizationMembership.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationMembershipFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizationMembershipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizationMembershipClient<$Result.GetResult<Prisma.$OrganizationMembershipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrganizationMembership that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMembershipFindFirstArgs} args - Arguments to find a OrganizationMembership
     * @example
     * // Get one OrganizationMembership
     * const organizationMembership = await prisma.organizationMembership.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationMembershipFindFirstArgs>(args?: SelectSubset<T, OrganizationMembershipFindFirstArgs<ExtArgs>>): Prisma__OrganizationMembershipClient<$Result.GetResult<Prisma.$OrganizationMembershipPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrganizationMembership that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMembershipFindFirstOrThrowArgs} args - Arguments to find a OrganizationMembership
     * @example
     * // Get one OrganizationMembership
     * const organizationMembership = await prisma.organizationMembership.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationMembershipFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizationMembershipFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizationMembershipClient<$Result.GetResult<Prisma.$OrganizationMembershipPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrganizationMemberships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMembershipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrganizationMemberships
     * const organizationMemberships = await prisma.organizationMembership.findMany()
     * 
     * // Get first 10 OrganizationMemberships
     * const organizationMemberships = await prisma.organizationMembership.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationMembershipWithIdOnly = await prisma.organizationMembership.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganizationMembershipFindManyArgs>(args?: SelectSubset<T, OrganizationMembershipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrganizationMembership.
     * @param {OrganizationMembershipCreateArgs} args - Arguments to create a OrganizationMembership.
     * @example
     * // Create one OrganizationMembership
     * const OrganizationMembership = await prisma.organizationMembership.create({
     *   data: {
     *     // ... data to create a OrganizationMembership
     *   }
     * })
     * 
     */
    create<T extends OrganizationMembershipCreateArgs>(args: SelectSubset<T, OrganizationMembershipCreateArgs<ExtArgs>>): Prisma__OrganizationMembershipClient<$Result.GetResult<Prisma.$OrganizationMembershipPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrganizationMemberships.
     * @param {OrganizationMembershipCreateManyArgs} args - Arguments to create many OrganizationMemberships.
     * @example
     * // Create many OrganizationMemberships
     * const organizationMembership = await prisma.organizationMembership.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizationMembershipCreateManyArgs>(args?: SelectSubset<T, OrganizationMembershipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrganizationMemberships and returns the data saved in the database.
     * @param {OrganizationMembershipCreateManyAndReturnArgs} args - Arguments to create many OrganizationMemberships.
     * @example
     * // Create many OrganizationMemberships
     * const organizationMembership = await prisma.organizationMembership.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrganizationMemberships and only return the `id`
     * const organizationMembershipWithIdOnly = await prisma.organizationMembership.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrganizationMembershipCreateManyAndReturnArgs>(args?: SelectSubset<T, OrganizationMembershipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationMembershipPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrganizationMembership.
     * @param {OrganizationMembershipDeleteArgs} args - Arguments to delete one OrganizationMembership.
     * @example
     * // Delete one OrganizationMembership
     * const OrganizationMembership = await prisma.organizationMembership.delete({
     *   where: {
     *     // ... filter to delete one OrganizationMembership
     *   }
     * })
     * 
     */
    delete<T extends OrganizationMembershipDeleteArgs>(args: SelectSubset<T, OrganizationMembershipDeleteArgs<ExtArgs>>): Prisma__OrganizationMembershipClient<$Result.GetResult<Prisma.$OrganizationMembershipPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrganizationMembership.
     * @param {OrganizationMembershipUpdateArgs} args - Arguments to update one OrganizationMembership.
     * @example
     * // Update one OrganizationMembership
     * const organizationMembership = await prisma.organizationMembership.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizationMembershipUpdateArgs>(args: SelectSubset<T, OrganizationMembershipUpdateArgs<ExtArgs>>): Prisma__OrganizationMembershipClient<$Result.GetResult<Prisma.$OrganizationMembershipPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrganizationMemberships.
     * @param {OrganizationMembershipDeleteManyArgs} args - Arguments to filter OrganizationMemberships to delete.
     * @example
     * // Delete a few OrganizationMemberships
     * const { count } = await prisma.organizationMembership.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizationMembershipDeleteManyArgs>(args?: SelectSubset<T, OrganizationMembershipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrganizationMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMembershipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrganizationMemberships
     * const organizationMembership = await prisma.organizationMembership.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizationMembershipUpdateManyArgs>(args: SelectSubset<T, OrganizationMembershipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrganizationMemberships and returns the data updated in the database.
     * @param {OrganizationMembershipUpdateManyAndReturnArgs} args - Arguments to update many OrganizationMemberships.
     * @example
     * // Update many OrganizationMemberships
     * const organizationMembership = await prisma.organizationMembership.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrganizationMemberships and only return the `id`
     * const organizationMembershipWithIdOnly = await prisma.organizationMembership.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrganizationMembershipUpdateManyAndReturnArgs>(args: SelectSubset<T, OrganizationMembershipUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationMembershipPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrganizationMembership.
     * @param {OrganizationMembershipUpsertArgs} args - Arguments to update or create a OrganizationMembership.
     * @example
     * // Update or create a OrganizationMembership
     * const organizationMembership = await prisma.organizationMembership.upsert({
     *   create: {
     *     // ... data to create a OrganizationMembership
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrganizationMembership we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationMembershipUpsertArgs>(args: SelectSubset<T, OrganizationMembershipUpsertArgs<ExtArgs>>): Prisma__OrganizationMembershipClient<$Result.GetResult<Prisma.$OrganizationMembershipPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrganizationMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMembershipCountArgs} args - Arguments to filter OrganizationMemberships to count.
     * @example
     * // Count the number of OrganizationMemberships
     * const count = await prisma.organizationMembership.count({
     *   where: {
     *     // ... the filter for the OrganizationMemberships we want to count
     *   }
     * })
    **/
    count<T extends OrganizationMembershipCountArgs>(
      args?: Subset<T, OrganizationMembershipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationMembershipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrganizationMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMembershipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationMembershipAggregateArgs>(args: Subset<T, OrganizationMembershipAggregateArgs>): Prisma.PrismaPromise<GetOrganizationMembershipAggregateType<T>>

    /**
     * Group by OrganizationMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMembershipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationMembershipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationMembershipGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationMembershipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationMembershipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationMembershipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrganizationMembership model
   */
  readonly fields: OrganizationMembershipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrganizationMembership.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationMembershipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrganizationMembership model
   */
  interface OrganizationMembershipFieldRefs {
    readonly id: FieldRef<"OrganizationMembership", 'String'>
    readonly userId: FieldRef<"OrganizationMembership", 'String'>
    readonly organizationId: FieldRef<"OrganizationMembership", 'String'>
    readonly role: FieldRef<"OrganizationMembership", 'String'>
    readonly joinedAt: FieldRef<"OrganizationMembership", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrganizationMembership findUnique
   */
  export type OrganizationMembershipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMembership
     */
    select?: OrganizationMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMembership
     */
    omit?: OrganizationMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMembershipInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationMembership to fetch.
     */
    where: OrganizationMembershipWhereUniqueInput
  }

  /**
   * OrganizationMembership findUniqueOrThrow
   */
  export type OrganizationMembershipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMembership
     */
    select?: OrganizationMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMembership
     */
    omit?: OrganizationMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMembershipInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationMembership to fetch.
     */
    where: OrganizationMembershipWhereUniqueInput
  }

  /**
   * OrganizationMembership findFirst
   */
  export type OrganizationMembershipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMembership
     */
    select?: OrganizationMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMembership
     */
    omit?: OrganizationMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMembershipInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationMembership to fetch.
     */
    where?: OrganizationMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationMemberships to fetch.
     */
    orderBy?: OrganizationMembershipOrderByWithRelationInput | OrganizationMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganizationMemberships.
     */
    cursor?: OrganizationMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganizationMemberships.
     */
    distinct?: OrganizationMembershipScalarFieldEnum | OrganizationMembershipScalarFieldEnum[]
  }

  /**
   * OrganizationMembership findFirstOrThrow
   */
  export type OrganizationMembershipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMembership
     */
    select?: OrganizationMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMembership
     */
    omit?: OrganizationMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMembershipInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationMembership to fetch.
     */
    where?: OrganizationMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationMemberships to fetch.
     */
    orderBy?: OrganizationMembershipOrderByWithRelationInput | OrganizationMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganizationMemberships.
     */
    cursor?: OrganizationMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganizationMemberships.
     */
    distinct?: OrganizationMembershipScalarFieldEnum | OrganizationMembershipScalarFieldEnum[]
  }

  /**
   * OrganizationMembership findMany
   */
  export type OrganizationMembershipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMembership
     */
    select?: OrganizationMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMembership
     */
    omit?: OrganizationMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMembershipInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationMemberships to fetch.
     */
    where?: OrganizationMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationMemberships to fetch.
     */
    orderBy?: OrganizationMembershipOrderByWithRelationInput | OrganizationMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrganizationMemberships.
     */
    cursor?: OrganizationMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationMemberships.
     */
    skip?: number
    distinct?: OrganizationMembershipScalarFieldEnum | OrganizationMembershipScalarFieldEnum[]
  }

  /**
   * OrganizationMembership create
   */
  export type OrganizationMembershipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMembership
     */
    select?: OrganizationMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMembership
     */
    omit?: OrganizationMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMembershipInclude<ExtArgs> | null
    /**
     * The data needed to create a OrganizationMembership.
     */
    data: XOR<OrganizationMembershipCreateInput, OrganizationMembershipUncheckedCreateInput>
  }

  /**
   * OrganizationMembership createMany
   */
  export type OrganizationMembershipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrganizationMemberships.
     */
    data: OrganizationMembershipCreateManyInput | OrganizationMembershipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrganizationMembership createManyAndReturn
   */
  export type OrganizationMembershipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMembership
     */
    select?: OrganizationMembershipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMembership
     */
    omit?: OrganizationMembershipOmit<ExtArgs> | null
    /**
     * The data used to create many OrganizationMemberships.
     */
    data: OrganizationMembershipCreateManyInput | OrganizationMembershipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMembershipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrganizationMembership update
   */
  export type OrganizationMembershipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMembership
     */
    select?: OrganizationMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMembership
     */
    omit?: OrganizationMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMembershipInclude<ExtArgs> | null
    /**
     * The data needed to update a OrganizationMembership.
     */
    data: XOR<OrganizationMembershipUpdateInput, OrganizationMembershipUncheckedUpdateInput>
    /**
     * Choose, which OrganizationMembership to update.
     */
    where: OrganizationMembershipWhereUniqueInput
  }

  /**
   * OrganizationMembership updateMany
   */
  export type OrganizationMembershipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrganizationMemberships.
     */
    data: XOR<OrganizationMembershipUpdateManyMutationInput, OrganizationMembershipUncheckedUpdateManyInput>
    /**
     * Filter which OrganizationMemberships to update
     */
    where?: OrganizationMembershipWhereInput
    /**
     * Limit how many OrganizationMemberships to update.
     */
    limit?: number
  }

  /**
   * OrganizationMembership updateManyAndReturn
   */
  export type OrganizationMembershipUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMembership
     */
    select?: OrganizationMembershipSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMembership
     */
    omit?: OrganizationMembershipOmit<ExtArgs> | null
    /**
     * The data used to update OrganizationMemberships.
     */
    data: XOR<OrganizationMembershipUpdateManyMutationInput, OrganizationMembershipUncheckedUpdateManyInput>
    /**
     * Filter which OrganizationMemberships to update
     */
    where?: OrganizationMembershipWhereInput
    /**
     * Limit how many OrganizationMemberships to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMembershipIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrganizationMembership upsert
   */
  export type OrganizationMembershipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMembership
     */
    select?: OrganizationMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMembership
     */
    omit?: OrganizationMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMembershipInclude<ExtArgs> | null
    /**
     * The filter to search for the OrganizationMembership to update in case it exists.
     */
    where: OrganizationMembershipWhereUniqueInput
    /**
     * In case the OrganizationMembership found by the `where` argument doesn't exist, create a new OrganizationMembership with this data.
     */
    create: XOR<OrganizationMembershipCreateInput, OrganizationMembershipUncheckedCreateInput>
    /**
     * In case the OrganizationMembership was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationMembershipUpdateInput, OrganizationMembershipUncheckedUpdateInput>
  }

  /**
   * OrganizationMembership delete
   */
  export type OrganizationMembershipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMembership
     */
    select?: OrganizationMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMembership
     */
    omit?: OrganizationMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMembershipInclude<ExtArgs> | null
    /**
     * Filter which OrganizationMembership to delete.
     */
    where: OrganizationMembershipWhereUniqueInput
  }

  /**
   * OrganizationMembership deleteMany
   */
  export type OrganizationMembershipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrganizationMemberships to delete
     */
    where?: OrganizationMembershipWhereInput
    /**
     * Limit how many OrganizationMemberships to delete.
     */
    limit?: number
  }

  /**
   * OrganizationMembership without action
   */
  export type OrganizationMembershipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMembership
     */
    select?: OrganizationMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMembership
     */
    omit?: OrganizationMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMembershipInclude<ExtArgs> | null
  }


  /**
   * Model TeamMembership
   */

  export type AggregateTeamMembership = {
    _count: TeamMembershipCountAggregateOutputType | null
    _min: TeamMembershipMinAggregateOutputType | null
    _max: TeamMembershipMaxAggregateOutputType | null
  }

  export type TeamMembershipMinAggregateOutputType = {
    id: string | null
    userId: string | null
    teamId: string | null
    roleId: string | null
    joinedAt: Date | null
    leftAt: Date | null
  }

  export type TeamMembershipMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    teamId: string | null
    roleId: string | null
    joinedAt: Date | null
    leftAt: Date | null
  }

  export type TeamMembershipCountAggregateOutputType = {
    id: number
    userId: number
    teamId: number
    roleId: number
    joinedAt: number
    leftAt: number
    _all: number
  }


  export type TeamMembershipMinAggregateInputType = {
    id?: true
    userId?: true
    teamId?: true
    roleId?: true
    joinedAt?: true
    leftAt?: true
  }

  export type TeamMembershipMaxAggregateInputType = {
    id?: true
    userId?: true
    teamId?: true
    roleId?: true
    joinedAt?: true
    leftAt?: true
  }

  export type TeamMembershipCountAggregateInputType = {
    id?: true
    userId?: true
    teamId?: true
    roleId?: true
    joinedAt?: true
    leftAt?: true
    _all?: true
  }

  export type TeamMembershipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamMembership to aggregate.
     */
    where?: TeamMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMemberships to fetch.
     */
    orderBy?: TeamMembershipOrderByWithRelationInput | TeamMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeamMemberships
    **/
    _count?: true | TeamMembershipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMembershipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMembershipMaxAggregateInputType
  }

  export type GetTeamMembershipAggregateType<T extends TeamMembershipAggregateArgs> = {
        [P in keyof T & keyof AggregateTeamMembership]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamMembership[P]>
      : GetScalarType<T[P], AggregateTeamMembership[P]>
  }




  export type TeamMembershipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMembershipWhereInput
    orderBy?: TeamMembershipOrderByWithAggregationInput | TeamMembershipOrderByWithAggregationInput[]
    by: TeamMembershipScalarFieldEnum[] | TeamMembershipScalarFieldEnum
    having?: TeamMembershipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamMembershipCountAggregateInputType | true
    _min?: TeamMembershipMinAggregateInputType
    _max?: TeamMembershipMaxAggregateInputType
  }

  export type TeamMembershipGroupByOutputType = {
    id: string
    userId: string
    teamId: string
    roleId: string | null
    joinedAt: Date
    leftAt: Date | null
    _count: TeamMembershipCountAggregateOutputType | null
    _min: TeamMembershipMinAggregateOutputType | null
    _max: TeamMembershipMaxAggregateOutputType | null
  }

  type GetTeamMembershipGroupByPayload<T extends TeamMembershipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamMembershipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamMembershipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamMembershipGroupByOutputType[P]>
            : GetScalarType<T[P], TeamMembershipGroupByOutputType[P]>
        }
      >
    >


  export type TeamMembershipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    teamId?: boolean
    roleId?: boolean
    joinedAt?: boolean
    leftAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    role?: boolean | TeamMembership$roleArgs<ExtArgs>
  }, ExtArgs["result"]["teamMembership"]>

  export type TeamMembershipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    teamId?: boolean
    roleId?: boolean
    joinedAt?: boolean
    leftAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    role?: boolean | TeamMembership$roleArgs<ExtArgs>
  }, ExtArgs["result"]["teamMembership"]>

  export type TeamMembershipSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    teamId?: boolean
    roleId?: boolean
    joinedAt?: boolean
    leftAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    role?: boolean | TeamMembership$roleArgs<ExtArgs>
  }, ExtArgs["result"]["teamMembership"]>

  export type TeamMembershipSelectScalar = {
    id?: boolean
    userId?: boolean
    teamId?: boolean
    roleId?: boolean
    joinedAt?: boolean
    leftAt?: boolean
  }

  export type TeamMembershipOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "teamId" | "roleId" | "joinedAt" | "leftAt", ExtArgs["result"]["teamMembership"]>
  export type TeamMembershipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    role?: boolean | TeamMembership$roleArgs<ExtArgs>
  }
  export type TeamMembershipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    role?: boolean | TeamMembership$roleArgs<ExtArgs>
  }
  export type TeamMembershipIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    role?: boolean | TeamMembership$roleArgs<ExtArgs>
  }

  export type $TeamMembershipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeamMembership"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      team: Prisma.$TeamPayload<ExtArgs>
      role: Prisma.$RolePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      teamId: string
      roleId: string | null
      joinedAt: Date
      leftAt: Date | null
    }, ExtArgs["result"]["teamMembership"]>
    composites: {}
  }

  type TeamMembershipGetPayload<S extends boolean | null | undefined | TeamMembershipDefaultArgs> = $Result.GetResult<Prisma.$TeamMembershipPayload, S>

  type TeamMembershipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamMembershipFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamMembershipCountAggregateInputType | true
    }

  export interface TeamMembershipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeamMembership'], meta: { name: 'TeamMembership' } }
    /**
     * Find zero or one TeamMembership that matches the filter.
     * @param {TeamMembershipFindUniqueArgs} args - Arguments to find a TeamMembership
     * @example
     * // Get one TeamMembership
     * const teamMembership = await prisma.teamMembership.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamMembershipFindUniqueArgs>(args: SelectSubset<T, TeamMembershipFindUniqueArgs<ExtArgs>>): Prisma__TeamMembershipClient<$Result.GetResult<Prisma.$TeamMembershipPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TeamMembership that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamMembershipFindUniqueOrThrowArgs} args - Arguments to find a TeamMembership
     * @example
     * // Get one TeamMembership
     * const teamMembership = await prisma.teamMembership.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamMembershipFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamMembershipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamMembershipClient<$Result.GetResult<Prisma.$TeamMembershipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamMembership that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMembershipFindFirstArgs} args - Arguments to find a TeamMembership
     * @example
     * // Get one TeamMembership
     * const teamMembership = await prisma.teamMembership.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamMembershipFindFirstArgs>(args?: SelectSubset<T, TeamMembershipFindFirstArgs<ExtArgs>>): Prisma__TeamMembershipClient<$Result.GetResult<Prisma.$TeamMembershipPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamMembership that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMembershipFindFirstOrThrowArgs} args - Arguments to find a TeamMembership
     * @example
     * // Get one TeamMembership
     * const teamMembership = await prisma.teamMembership.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamMembershipFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamMembershipFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamMembershipClient<$Result.GetResult<Prisma.$TeamMembershipPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TeamMemberships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMembershipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamMemberships
     * const teamMemberships = await prisma.teamMembership.findMany()
     * 
     * // Get first 10 TeamMemberships
     * const teamMemberships = await prisma.teamMembership.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamMembershipWithIdOnly = await prisma.teamMembership.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamMembershipFindManyArgs>(args?: SelectSubset<T, TeamMembershipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TeamMembership.
     * @param {TeamMembershipCreateArgs} args - Arguments to create a TeamMembership.
     * @example
     * // Create one TeamMembership
     * const TeamMembership = await prisma.teamMembership.create({
     *   data: {
     *     // ... data to create a TeamMembership
     *   }
     * })
     * 
     */
    create<T extends TeamMembershipCreateArgs>(args: SelectSubset<T, TeamMembershipCreateArgs<ExtArgs>>): Prisma__TeamMembershipClient<$Result.GetResult<Prisma.$TeamMembershipPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TeamMemberships.
     * @param {TeamMembershipCreateManyArgs} args - Arguments to create many TeamMemberships.
     * @example
     * // Create many TeamMemberships
     * const teamMembership = await prisma.teamMembership.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamMembershipCreateManyArgs>(args?: SelectSubset<T, TeamMembershipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TeamMemberships and returns the data saved in the database.
     * @param {TeamMembershipCreateManyAndReturnArgs} args - Arguments to create many TeamMemberships.
     * @example
     * // Create many TeamMemberships
     * const teamMembership = await prisma.teamMembership.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TeamMemberships and only return the `id`
     * const teamMembershipWithIdOnly = await prisma.teamMembership.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamMembershipCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamMembershipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMembershipPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TeamMembership.
     * @param {TeamMembershipDeleteArgs} args - Arguments to delete one TeamMembership.
     * @example
     * // Delete one TeamMembership
     * const TeamMembership = await prisma.teamMembership.delete({
     *   where: {
     *     // ... filter to delete one TeamMembership
     *   }
     * })
     * 
     */
    delete<T extends TeamMembershipDeleteArgs>(args: SelectSubset<T, TeamMembershipDeleteArgs<ExtArgs>>): Prisma__TeamMembershipClient<$Result.GetResult<Prisma.$TeamMembershipPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TeamMembership.
     * @param {TeamMembershipUpdateArgs} args - Arguments to update one TeamMembership.
     * @example
     * // Update one TeamMembership
     * const teamMembership = await prisma.teamMembership.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamMembershipUpdateArgs>(args: SelectSubset<T, TeamMembershipUpdateArgs<ExtArgs>>): Prisma__TeamMembershipClient<$Result.GetResult<Prisma.$TeamMembershipPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TeamMemberships.
     * @param {TeamMembershipDeleteManyArgs} args - Arguments to filter TeamMemberships to delete.
     * @example
     * // Delete a few TeamMemberships
     * const { count } = await prisma.teamMembership.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamMembershipDeleteManyArgs>(args?: SelectSubset<T, TeamMembershipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMembershipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamMemberships
     * const teamMembership = await prisma.teamMembership.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamMembershipUpdateManyArgs>(args: SelectSubset<T, TeamMembershipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamMemberships and returns the data updated in the database.
     * @param {TeamMembershipUpdateManyAndReturnArgs} args - Arguments to update many TeamMemberships.
     * @example
     * // Update many TeamMemberships
     * const teamMembership = await prisma.teamMembership.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TeamMemberships and only return the `id`
     * const teamMembershipWithIdOnly = await prisma.teamMembership.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeamMembershipUpdateManyAndReturnArgs>(args: SelectSubset<T, TeamMembershipUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMembershipPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TeamMembership.
     * @param {TeamMembershipUpsertArgs} args - Arguments to update or create a TeamMembership.
     * @example
     * // Update or create a TeamMembership
     * const teamMembership = await prisma.teamMembership.upsert({
     *   create: {
     *     // ... data to create a TeamMembership
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamMembership we want to update
     *   }
     * })
     */
    upsert<T extends TeamMembershipUpsertArgs>(args: SelectSubset<T, TeamMembershipUpsertArgs<ExtArgs>>): Prisma__TeamMembershipClient<$Result.GetResult<Prisma.$TeamMembershipPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TeamMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMembershipCountArgs} args - Arguments to filter TeamMemberships to count.
     * @example
     * // Count the number of TeamMemberships
     * const count = await prisma.teamMembership.count({
     *   where: {
     *     // ... the filter for the TeamMemberships we want to count
     *   }
     * })
    **/
    count<T extends TeamMembershipCountArgs>(
      args?: Subset<T, TeamMembershipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamMembershipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeamMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMembershipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamMembershipAggregateArgs>(args: Subset<T, TeamMembershipAggregateArgs>): Prisma.PrismaPromise<GetTeamMembershipAggregateType<T>>

    /**
     * Group by TeamMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMembershipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamMembershipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamMembershipGroupByArgs['orderBy'] }
        : { orderBy?: TeamMembershipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamMembershipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamMembershipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeamMembership model
   */
  readonly fields: TeamMembershipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamMembership.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamMembershipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    role<T extends TeamMembership$roleArgs<ExtArgs> = {}>(args?: Subset<T, TeamMembership$roleArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeamMembership model
   */
  interface TeamMembershipFieldRefs {
    readonly id: FieldRef<"TeamMembership", 'String'>
    readonly userId: FieldRef<"TeamMembership", 'String'>
    readonly teamId: FieldRef<"TeamMembership", 'String'>
    readonly roleId: FieldRef<"TeamMembership", 'String'>
    readonly joinedAt: FieldRef<"TeamMembership", 'DateTime'>
    readonly leftAt: FieldRef<"TeamMembership", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TeamMembership findUnique
   */
  export type TeamMembershipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMembership
     */
    select?: TeamMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMembership
     */
    omit?: TeamMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMembershipInclude<ExtArgs> | null
    /**
     * Filter, which TeamMembership to fetch.
     */
    where: TeamMembershipWhereUniqueInput
  }

  /**
   * TeamMembership findUniqueOrThrow
   */
  export type TeamMembershipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMembership
     */
    select?: TeamMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMembership
     */
    omit?: TeamMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMembershipInclude<ExtArgs> | null
    /**
     * Filter, which TeamMembership to fetch.
     */
    where: TeamMembershipWhereUniqueInput
  }

  /**
   * TeamMembership findFirst
   */
  export type TeamMembershipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMembership
     */
    select?: TeamMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMembership
     */
    omit?: TeamMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMembershipInclude<ExtArgs> | null
    /**
     * Filter, which TeamMembership to fetch.
     */
    where?: TeamMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMemberships to fetch.
     */
    orderBy?: TeamMembershipOrderByWithRelationInput | TeamMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamMemberships.
     */
    cursor?: TeamMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamMemberships.
     */
    distinct?: TeamMembershipScalarFieldEnum | TeamMembershipScalarFieldEnum[]
  }

  /**
   * TeamMembership findFirstOrThrow
   */
  export type TeamMembershipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMembership
     */
    select?: TeamMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMembership
     */
    omit?: TeamMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMembershipInclude<ExtArgs> | null
    /**
     * Filter, which TeamMembership to fetch.
     */
    where?: TeamMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMemberships to fetch.
     */
    orderBy?: TeamMembershipOrderByWithRelationInput | TeamMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamMemberships.
     */
    cursor?: TeamMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamMemberships.
     */
    distinct?: TeamMembershipScalarFieldEnum | TeamMembershipScalarFieldEnum[]
  }

  /**
   * TeamMembership findMany
   */
  export type TeamMembershipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMembership
     */
    select?: TeamMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMembership
     */
    omit?: TeamMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMembershipInclude<ExtArgs> | null
    /**
     * Filter, which TeamMemberships to fetch.
     */
    where?: TeamMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMemberships to fetch.
     */
    orderBy?: TeamMembershipOrderByWithRelationInput | TeamMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeamMemberships.
     */
    cursor?: TeamMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMemberships.
     */
    skip?: number
    distinct?: TeamMembershipScalarFieldEnum | TeamMembershipScalarFieldEnum[]
  }

  /**
   * TeamMembership create
   */
  export type TeamMembershipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMembership
     */
    select?: TeamMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMembership
     */
    omit?: TeamMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMembershipInclude<ExtArgs> | null
    /**
     * The data needed to create a TeamMembership.
     */
    data: XOR<TeamMembershipCreateInput, TeamMembershipUncheckedCreateInput>
  }

  /**
   * TeamMembership createMany
   */
  export type TeamMembershipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeamMemberships.
     */
    data: TeamMembershipCreateManyInput | TeamMembershipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TeamMembership createManyAndReturn
   */
  export type TeamMembershipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMembership
     */
    select?: TeamMembershipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMembership
     */
    omit?: TeamMembershipOmit<ExtArgs> | null
    /**
     * The data used to create many TeamMemberships.
     */
    data: TeamMembershipCreateManyInput | TeamMembershipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMembershipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeamMembership update
   */
  export type TeamMembershipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMembership
     */
    select?: TeamMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMembership
     */
    omit?: TeamMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMembershipInclude<ExtArgs> | null
    /**
     * The data needed to update a TeamMembership.
     */
    data: XOR<TeamMembershipUpdateInput, TeamMembershipUncheckedUpdateInput>
    /**
     * Choose, which TeamMembership to update.
     */
    where: TeamMembershipWhereUniqueInput
  }

  /**
   * TeamMembership updateMany
   */
  export type TeamMembershipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeamMemberships.
     */
    data: XOR<TeamMembershipUpdateManyMutationInput, TeamMembershipUncheckedUpdateManyInput>
    /**
     * Filter which TeamMemberships to update
     */
    where?: TeamMembershipWhereInput
    /**
     * Limit how many TeamMemberships to update.
     */
    limit?: number
  }

  /**
   * TeamMembership updateManyAndReturn
   */
  export type TeamMembershipUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMembership
     */
    select?: TeamMembershipSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMembership
     */
    omit?: TeamMembershipOmit<ExtArgs> | null
    /**
     * The data used to update TeamMemberships.
     */
    data: XOR<TeamMembershipUpdateManyMutationInput, TeamMembershipUncheckedUpdateManyInput>
    /**
     * Filter which TeamMemberships to update
     */
    where?: TeamMembershipWhereInput
    /**
     * Limit how many TeamMemberships to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMembershipIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeamMembership upsert
   */
  export type TeamMembershipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMembership
     */
    select?: TeamMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMembership
     */
    omit?: TeamMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMembershipInclude<ExtArgs> | null
    /**
     * The filter to search for the TeamMembership to update in case it exists.
     */
    where: TeamMembershipWhereUniqueInput
    /**
     * In case the TeamMembership found by the `where` argument doesn't exist, create a new TeamMembership with this data.
     */
    create: XOR<TeamMembershipCreateInput, TeamMembershipUncheckedCreateInput>
    /**
     * In case the TeamMembership was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamMembershipUpdateInput, TeamMembershipUncheckedUpdateInput>
  }

  /**
   * TeamMembership delete
   */
  export type TeamMembershipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMembership
     */
    select?: TeamMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMembership
     */
    omit?: TeamMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMembershipInclude<ExtArgs> | null
    /**
     * Filter which TeamMembership to delete.
     */
    where: TeamMembershipWhereUniqueInput
  }

  /**
   * TeamMembership deleteMany
   */
  export type TeamMembershipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamMemberships to delete
     */
    where?: TeamMembershipWhereInput
    /**
     * Limit how many TeamMemberships to delete.
     */
    limit?: number
  }

  /**
   * TeamMembership.role
   */
  export type TeamMembership$roleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    where?: RoleWhereInput
  }

  /**
   * TeamMembership without action
   */
  export type TeamMembershipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMembership
     */
    select?: TeamMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMembership
     */
    omit?: TeamMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMembershipInclude<ExtArgs> | null
  }


  /**
   * Model Portfolio
   */

  export type AggregatePortfolio = {
    _count: PortfolioCountAggregateOutputType | null
    _min: PortfolioMinAggregateOutputType | null
    _max: PortfolioMaxAggregateOutputType | null
  }

  export type PortfolioMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    strategicGoal: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    organizationId: string | null
  }

  export type PortfolioMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    strategicGoal: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    organizationId: string | null
  }

  export type PortfolioCountAggregateOutputType = {
    id: number
    name: number
    description: number
    strategicGoal: number
    startDate: number
    endDate: number
    createdAt: number
    updatedAt: number
    organizationId: number
    _all: number
  }


  export type PortfolioMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    strategicGoal?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    organizationId?: true
  }

  export type PortfolioMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    strategicGoal?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    organizationId?: true
  }

  export type PortfolioCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    strategicGoal?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    organizationId?: true
    _all?: true
  }

  export type PortfolioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Portfolio to aggregate.
     */
    where?: PortfolioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Portfolios to fetch.
     */
    orderBy?: PortfolioOrderByWithRelationInput | PortfolioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PortfolioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Portfolios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Portfolios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Portfolios
    **/
    _count?: true | PortfolioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PortfolioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PortfolioMaxAggregateInputType
  }

  export type GetPortfolioAggregateType<T extends PortfolioAggregateArgs> = {
        [P in keyof T & keyof AggregatePortfolio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePortfolio[P]>
      : GetScalarType<T[P], AggregatePortfolio[P]>
  }




  export type PortfolioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PortfolioWhereInput
    orderBy?: PortfolioOrderByWithAggregationInput | PortfolioOrderByWithAggregationInput[]
    by: PortfolioScalarFieldEnum[] | PortfolioScalarFieldEnum
    having?: PortfolioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PortfolioCountAggregateInputType | true
    _min?: PortfolioMinAggregateInputType
    _max?: PortfolioMaxAggregateInputType
  }

  export type PortfolioGroupByOutputType = {
    id: string
    name: string
    description: string | null
    strategicGoal: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date
    updatedAt: Date
    organizationId: string
    _count: PortfolioCountAggregateOutputType | null
    _min: PortfolioMinAggregateOutputType | null
    _max: PortfolioMaxAggregateOutputType | null
  }

  type GetPortfolioGroupByPayload<T extends PortfolioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PortfolioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PortfolioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PortfolioGroupByOutputType[P]>
            : GetScalarType<T[P], PortfolioGroupByOutputType[P]>
        }
      >
    >


  export type PortfolioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    strategicGoal?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organizationId?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    projects?: boolean | Portfolio$projectsArgs<ExtArgs>
    _count?: boolean | PortfolioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["portfolio"]>

  export type PortfolioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    strategicGoal?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organizationId?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["portfolio"]>

  export type PortfolioSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    strategicGoal?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organizationId?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["portfolio"]>

  export type PortfolioSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    strategicGoal?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organizationId?: boolean
  }

  export type PortfolioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "strategicGoal" | "startDate" | "endDate" | "createdAt" | "updatedAt" | "organizationId", ExtArgs["result"]["portfolio"]>
  export type PortfolioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    projects?: boolean | Portfolio$projectsArgs<ExtArgs>
    _count?: boolean | PortfolioCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PortfolioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type PortfolioIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $PortfolioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Portfolio"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      projects: Prisma.$ProjectPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      strategicGoal: string | null
      startDate: Date | null
      endDate: Date | null
      createdAt: Date
      updatedAt: Date
      organizationId: string
    }, ExtArgs["result"]["portfolio"]>
    composites: {}
  }

  type PortfolioGetPayload<S extends boolean | null | undefined | PortfolioDefaultArgs> = $Result.GetResult<Prisma.$PortfolioPayload, S>

  type PortfolioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PortfolioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PortfolioCountAggregateInputType | true
    }

  export interface PortfolioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Portfolio'], meta: { name: 'Portfolio' } }
    /**
     * Find zero or one Portfolio that matches the filter.
     * @param {PortfolioFindUniqueArgs} args - Arguments to find a Portfolio
     * @example
     * // Get one Portfolio
     * const portfolio = await prisma.portfolio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PortfolioFindUniqueArgs>(args: SelectSubset<T, PortfolioFindUniqueArgs<ExtArgs>>): Prisma__PortfolioClient<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Portfolio that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PortfolioFindUniqueOrThrowArgs} args - Arguments to find a Portfolio
     * @example
     * // Get one Portfolio
     * const portfolio = await prisma.portfolio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PortfolioFindUniqueOrThrowArgs>(args: SelectSubset<T, PortfolioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PortfolioClient<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Portfolio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioFindFirstArgs} args - Arguments to find a Portfolio
     * @example
     * // Get one Portfolio
     * const portfolio = await prisma.portfolio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PortfolioFindFirstArgs>(args?: SelectSubset<T, PortfolioFindFirstArgs<ExtArgs>>): Prisma__PortfolioClient<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Portfolio that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioFindFirstOrThrowArgs} args - Arguments to find a Portfolio
     * @example
     * // Get one Portfolio
     * const portfolio = await prisma.portfolio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PortfolioFindFirstOrThrowArgs>(args?: SelectSubset<T, PortfolioFindFirstOrThrowArgs<ExtArgs>>): Prisma__PortfolioClient<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Portfolios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Portfolios
     * const portfolios = await prisma.portfolio.findMany()
     * 
     * // Get first 10 Portfolios
     * const portfolios = await prisma.portfolio.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const portfolioWithIdOnly = await prisma.portfolio.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PortfolioFindManyArgs>(args?: SelectSubset<T, PortfolioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Portfolio.
     * @param {PortfolioCreateArgs} args - Arguments to create a Portfolio.
     * @example
     * // Create one Portfolio
     * const Portfolio = await prisma.portfolio.create({
     *   data: {
     *     // ... data to create a Portfolio
     *   }
     * })
     * 
     */
    create<T extends PortfolioCreateArgs>(args: SelectSubset<T, PortfolioCreateArgs<ExtArgs>>): Prisma__PortfolioClient<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Portfolios.
     * @param {PortfolioCreateManyArgs} args - Arguments to create many Portfolios.
     * @example
     * // Create many Portfolios
     * const portfolio = await prisma.portfolio.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PortfolioCreateManyArgs>(args?: SelectSubset<T, PortfolioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Portfolios and returns the data saved in the database.
     * @param {PortfolioCreateManyAndReturnArgs} args - Arguments to create many Portfolios.
     * @example
     * // Create many Portfolios
     * const portfolio = await prisma.portfolio.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Portfolios and only return the `id`
     * const portfolioWithIdOnly = await prisma.portfolio.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PortfolioCreateManyAndReturnArgs>(args?: SelectSubset<T, PortfolioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Portfolio.
     * @param {PortfolioDeleteArgs} args - Arguments to delete one Portfolio.
     * @example
     * // Delete one Portfolio
     * const Portfolio = await prisma.portfolio.delete({
     *   where: {
     *     // ... filter to delete one Portfolio
     *   }
     * })
     * 
     */
    delete<T extends PortfolioDeleteArgs>(args: SelectSubset<T, PortfolioDeleteArgs<ExtArgs>>): Prisma__PortfolioClient<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Portfolio.
     * @param {PortfolioUpdateArgs} args - Arguments to update one Portfolio.
     * @example
     * // Update one Portfolio
     * const portfolio = await prisma.portfolio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PortfolioUpdateArgs>(args: SelectSubset<T, PortfolioUpdateArgs<ExtArgs>>): Prisma__PortfolioClient<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Portfolios.
     * @param {PortfolioDeleteManyArgs} args - Arguments to filter Portfolios to delete.
     * @example
     * // Delete a few Portfolios
     * const { count } = await prisma.portfolio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PortfolioDeleteManyArgs>(args?: SelectSubset<T, PortfolioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Portfolios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Portfolios
     * const portfolio = await prisma.portfolio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PortfolioUpdateManyArgs>(args: SelectSubset<T, PortfolioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Portfolios and returns the data updated in the database.
     * @param {PortfolioUpdateManyAndReturnArgs} args - Arguments to update many Portfolios.
     * @example
     * // Update many Portfolios
     * const portfolio = await prisma.portfolio.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Portfolios and only return the `id`
     * const portfolioWithIdOnly = await prisma.portfolio.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PortfolioUpdateManyAndReturnArgs>(args: SelectSubset<T, PortfolioUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Portfolio.
     * @param {PortfolioUpsertArgs} args - Arguments to update or create a Portfolio.
     * @example
     * // Update or create a Portfolio
     * const portfolio = await prisma.portfolio.upsert({
     *   create: {
     *     // ... data to create a Portfolio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Portfolio we want to update
     *   }
     * })
     */
    upsert<T extends PortfolioUpsertArgs>(args: SelectSubset<T, PortfolioUpsertArgs<ExtArgs>>): Prisma__PortfolioClient<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Portfolios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioCountArgs} args - Arguments to filter Portfolios to count.
     * @example
     * // Count the number of Portfolios
     * const count = await prisma.portfolio.count({
     *   where: {
     *     // ... the filter for the Portfolios we want to count
     *   }
     * })
    **/
    count<T extends PortfolioCountArgs>(
      args?: Subset<T, PortfolioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PortfolioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Portfolio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PortfolioAggregateArgs>(args: Subset<T, PortfolioAggregateArgs>): Prisma.PrismaPromise<GetPortfolioAggregateType<T>>

    /**
     * Group by Portfolio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PortfolioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PortfolioGroupByArgs['orderBy'] }
        : { orderBy?: PortfolioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PortfolioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPortfolioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Portfolio model
   */
  readonly fields: PortfolioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Portfolio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PortfolioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    projects<T extends Portfolio$projectsArgs<ExtArgs> = {}>(args?: Subset<T, Portfolio$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Portfolio model
   */
  interface PortfolioFieldRefs {
    readonly id: FieldRef<"Portfolio", 'String'>
    readonly name: FieldRef<"Portfolio", 'String'>
    readonly description: FieldRef<"Portfolio", 'String'>
    readonly strategicGoal: FieldRef<"Portfolio", 'String'>
    readonly startDate: FieldRef<"Portfolio", 'DateTime'>
    readonly endDate: FieldRef<"Portfolio", 'DateTime'>
    readonly createdAt: FieldRef<"Portfolio", 'DateTime'>
    readonly updatedAt: FieldRef<"Portfolio", 'DateTime'>
    readonly organizationId: FieldRef<"Portfolio", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Portfolio findUnique
   */
  export type PortfolioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    /**
     * Filter, which Portfolio to fetch.
     */
    where: PortfolioWhereUniqueInput
  }

  /**
   * Portfolio findUniqueOrThrow
   */
  export type PortfolioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    /**
     * Filter, which Portfolio to fetch.
     */
    where: PortfolioWhereUniqueInput
  }

  /**
   * Portfolio findFirst
   */
  export type PortfolioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    /**
     * Filter, which Portfolio to fetch.
     */
    where?: PortfolioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Portfolios to fetch.
     */
    orderBy?: PortfolioOrderByWithRelationInput | PortfolioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Portfolios.
     */
    cursor?: PortfolioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Portfolios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Portfolios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Portfolios.
     */
    distinct?: PortfolioScalarFieldEnum | PortfolioScalarFieldEnum[]
  }

  /**
   * Portfolio findFirstOrThrow
   */
  export type PortfolioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    /**
     * Filter, which Portfolio to fetch.
     */
    where?: PortfolioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Portfolios to fetch.
     */
    orderBy?: PortfolioOrderByWithRelationInput | PortfolioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Portfolios.
     */
    cursor?: PortfolioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Portfolios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Portfolios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Portfolios.
     */
    distinct?: PortfolioScalarFieldEnum | PortfolioScalarFieldEnum[]
  }

  /**
   * Portfolio findMany
   */
  export type PortfolioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    /**
     * Filter, which Portfolios to fetch.
     */
    where?: PortfolioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Portfolios to fetch.
     */
    orderBy?: PortfolioOrderByWithRelationInput | PortfolioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Portfolios.
     */
    cursor?: PortfolioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Portfolios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Portfolios.
     */
    skip?: number
    distinct?: PortfolioScalarFieldEnum | PortfolioScalarFieldEnum[]
  }

  /**
   * Portfolio create
   */
  export type PortfolioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    /**
     * The data needed to create a Portfolio.
     */
    data: XOR<PortfolioCreateInput, PortfolioUncheckedCreateInput>
  }

  /**
   * Portfolio createMany
   */
  export type PortfolioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Portfolios.
     */
    data: PortfolioCreateManyInput | PortfolioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Portfolio createManyAndReturn
   */
  export type PortfolioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * The data used to create many Portfolios.
     */
    data: PortfolioCreateManyInput | PortfolioCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Portfolio update
   */
  export type PortfolioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    /**
     * The data needed to update a Portfolio.
     */
    data: XOR<PortfolioUpdateInput, PortfolioUncheckedUpdateInput>
    /**
     * Choose, which Portfolio to update.
     */
    where: PortfolioWhereUniqueInput
  }

  /**
   * Portfolio updateMany
   */
  export type PortfolioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Portfolios.
     */
    data: XOR<PortfolioUpdateManyMutationInput, PortfolioUncheckedUpdateManyInput>
    /**
     * Filter which Portfolios to update
     */
    where?: PortfolioWhereInput
    /**
     * Limit how many Portfolios to update.
     */
    limit?: number
  }

  /**
   * Portfolio updateManyAndReturn
   */
  export type PortfolioUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * The data used to update Portfolios.
     */
    data: XOR<PortfolioUpdateManyMutationInput, PortfolioUncheckedUpdateManyInput>
    /**
     * Filter which Portfolios to update
     */
    where?: PortfolioWhereInput
    /**
     * Limit how many Portfolios to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Portfolio upsert
   */
  export type PortfolioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    /**
     * The filter to search for the Portfolio to update in case it exists.
     */
    where: PortfolioWhereUniqueInput
    /**
     * In case the Portfolio found by the `where` argument doesn't exist, create a new Portfolio with this data.
     */
    create: XOR<PortfolioCreateInput, PortfolioUncheckedCreateInput>
    /**
     * In case the Portfolio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PortfolioUpdateInput, PortfolioUncheckedUpdateInput>
  }

  /**
   * Portfolio delete
   */
  export type PortfolioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    /**
     * Filter which Portfolio to delete.
     */
    where: PortfolioWhereUniqueInput
  }

  /**
   * Portfolio deleteMany
   */
  export type PortfolioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Portfolios to delete
     */
    where?: PortfolioWhereInput
    /**
     * Limit how many Portfolios to delete.
     */
    limit?: number
  }

  /**
   * Portfolio.projects
   */
  export type Portfolio$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Portfolio without action
   */
  export type PortfolioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectAvgAggregateOutputType = {
    riskScore: number | null
  }

  export type ProjectSumAggregateOutputType = {
    riskScore: number | null
  }

  export type ProjectMinAggregateOutputType = {
    id: string | null
    key: string | null
    name: string | null
    description: string | null
    projectType: string | null
    riskScore: number | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    portfolioId: string | null
    organizationId: string | null
    leadUserId: string | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: string | null
    key: string | null
    name: string | null
    description: string | null
    projectType: string | null
    riskScore: number | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    portfolioId: string | null
    organizationId: string | null
    leadUserId: string | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    key: number
    name: number
    description: number
    projectType: number
    riskScore: number
    startDate: number
    endDate: number
    settings: number
    createdAt: number
    updatedAt: number
    portfolioId: number
    organizationId: number
    leadUserId: number
    _all: number
  }


  export type ProjectAvgAggregateInputType = {
    riskScore?: true
  }

  export type ProjectSumAggregateInputType = {
    riskScore?: true
  }

  export type ProjectMinAggregateInputType = {
    id?: true
    key?: true
    name?: true
    description?: true
    projectType?: true
    riskScore?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    portfolioId?: true
    organizationId?: true
    leadUserId?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    key?: true
    name?: true
    description?: true
    projectType?: true
    riskScore?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    portfolioId?: true
    organizationId?: true
    leadUserId?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    key?: true
    name?: true
    description?: true
    projectType?: true
    riskScore?: true
    startDate?: true
    endDate?: true
    settings?: true
    createdAt?: true
    updatedAt?: true
    portfolioId?: true
    organizationId?: true
    leadUserId?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _avg?: ProjectAvgAggregateInputType
    _sum?: ProjectSumAggregateInputType
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: string
    key: string
    name: string
    description: string | null
    projectType: string
    riskScore: number
    startDate: Date | null
    endDate: Date | null
    settings: JsonValue
    createdAt: Date
    updatedAt: Date
    portfolioId: string | null
    organizationId: string
    leadUserId: string | null
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    name?: boolean
    description?: boolean
    projectType?: boolean
    riskScore?: boolean
    startDate?: boolean
    endDate?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    portfolioId?: boolean
    organizationId?: boolean
    leadUserId?: boolean
    portfolio?: boolean | Project$portfolioArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    leadUser?: boolean | Project$leadUserArgs<ExtArgs>
    workItems?: boolean | Project$workItemsArgs<ExtArgs>
    sprints?: boolean | Project$sprintsArgs<ExtArgs>
    milestones?: boolean | Project$milestonesArgs<ExtArgs>
    boards?: boolean | Project$boardsArgs<ExtArgs>
    workflowRules?: boolean | Project$workflowRulesArgs<ExtArgs>
    workItemStates?: boolean | Project$workItemStatesArgs<ExtArgs>
    components?: boolean | Project$componentsArgs<ExtArgs>
    teams?: boolean | Project$teamsArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    name?: boolean
    description?: boolean
    projectType?: boolean
    riskScore?: boolean
    startDate?: boolean
    endDate?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    portfolioId?: boolean
    organizationId?: boolean
    leadUserId?: boolean
    portfolio?: boolean | Project$portfolioArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    leadUser?: boolean | Project$leadUserArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    name?: boolean
    description?: boolean
    projectType?: boolean
    riskScore?: boolean
    startDate?: boolean
    endDate?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    portfolioId?: boolean
    organizationId?: boolean
    leadUserId?: boolean
    portfolio?: boolean | Project$portfolioArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    leadUser?: boolean | Project$leadUserArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    id?: boolean
    key?: boolean
    name?: boolean
    description?: boolean
    projectType?: boolean
    riskScore?: boolean
    startDate?: boolean
    endDate?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    portfolioId?: boolean
    organizationId?: boolean
    leadUserId?: boolean
  }

  export type ProjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "name" | "description" | "projectType" | "riskScore" | "startDate" | "endDate" | "settings" | "createdAt" | "updatedAt" | "portfolioId" | "organizationId" | "leadUserId", ExtArgs["result"]["project"]>
  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    portfolio?: boolean | Project$portfolioArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    leadUser?: boolean | Project$leadUserArgs<ExtArgs>
    workItems?: boolean | Project$workItemsArgs<ExtArgs>
    sprints?: boolean | Project$sprintsArgs<ExtArgs>
    milestones?: boolean | Project$milestonesArgs<ExtArgs>
    boards?: boolean | Project$boardsArgs<ExtArgs>
    workflowRules?: boolean | Project$workflowRulesArgs<ExtArgs>
    workItemStates?: boolean | Project$workItemStatesArgs<ExtArgs>
    components?: boolean | Project$componentsArgs<ExtArgs>
    teams?: boolean | Project$teamsArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    portfolio?: boolean | Project$portfolioArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    leadUser?: boolean | Project$leadUserArgs<ExtArgs>
  }
  export type ProjectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    portfolio?: boolean | Project$portfolioArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    leadUser?: boolean | Project$leadUserArgs<ExtArgs>
  }

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      portfolio: Prisma.$PortfolioPayload<ExtArgs> | null
      organization: Prisma.$OrganizationPayload<ExtArgs>
      leadUser: Prisma.$UserPayload<ExtArgs> | null
      workItems: Prisma.$WorkItemPayload<ExtArgs>[]
      sprints: Prisma.$SprintPayload<ExtArgs>[]
      milestones: Prisma.$MilestonePayload<ExtArgs>[]
      boards: Prisma.$BoardPayload<ExtArgs>[]
      workflowRules: Prisma.$WorkflowRulePayload<ExtArgs>[]
      workItemStates: Prisma.$WorkItemStatePayload<ExtArgs>[]
      components: Prisma.$ComponentPayload<ExtArgs>[]
      teams: Prisma.$TeamPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      name: string
      description: string | null
      projectType: string
      riskScore: number
      startDate: Date | null
      endDate: Date | null
      settings: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
      portfolioId: string | null
      organizationId: string
      leadUserId: string | null
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects and returns the data updated in the database.
     * @param {ProjectUpdateManyAndReturnArgs} args - Arguments to update many Projects.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    portfolio<T extends Project$portfolioArgs<ExtArgs> = {}>(args?: Subset<T, Project$portfolioArgs<ExtArgs>>): Prisma__PortfolioClient<$Result.GetResult<Prisma.$PortfolioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    leadUser<T extends Project$leadUserArgs<ExtArgs> = {}>(args?: Subset<T, Project$leadUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    workItems<T extends Project$workItemsArgs<ExtArgs> = {}>(args?: Subset<T, Project$workItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sprints<T extends Project$sprintsArgs<ExtArgs> = {}>(args?: Subset<T, Project$sprintsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    milestones<T extends Project$milestonesArgs<ExtArgs> = {}>(args?: Subset<T, Project$milestonesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    boards<T extends Project$boardsArgs<ExtArgs> = {}>(args?: Subset<T, Project$boardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workflowRules<T extends Project$workflowRulesArgs<ExtArgs> = {}>(args?: Subset<T, Project$workflowRulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workItemStates<T extends Project$workItemStatesArgs<ExtArgs> = {}>(args?: Subset<T, Project$workItemStatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkItemStatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    components<T extends Project$componentsArgs<ExtArgs> = {}>(args?: Subset<T, Project$componentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teams<T extends Project$teamsArgs<ExtArgs> = {}>(args?: Subset<T, Project$teamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'String'>
    readonly key: FieldRef<"Project", 'String'>
    readonly name: FieldRef<"Project", 'String'>
    readonly description: FieldRef<"Project", 'String'>
    readonly projectType: FieldRef<"Project", 'String'>
    readonly riskScore: FieldRef<"Project", 'Float'>
    readonly startDate: FieldRef<"Project", 'DateTime'>
    readonly endDate: FieldRef<"Project", 'DateTime'>
    readonly settings: FieldRef<"Project", 'Json'>
    readonly createdAt: FieldRef<"Project", 'DateTime'>
    readonly updatedAt: FieldRef<"Project", 'DateTime'>
    readonly portfolioId: FieldRef<"Project", 'String'>
    readonly organizationId: FieldRef<"Project", 'String'>
    readonly leadUserId: FieldRef<"Project", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project createManyAndReturn
   */
  export type ProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
  }

  /**
   * Project updateManyAndReturn
   */
  export type ProjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to delete.
     */
    limit?: number
  }

  /**
   * Project.portfolio
   */
  export type Project$portfolioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portfolio
     */
    select?: PortfolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portfolio
     */
    omit?: PortfolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioInclude<ExtArgs> | null
    where?: PortfolioWhereInput
  }

  /**
   * Project.leadUser
   */
  export type Project$leadUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Project.workItems
   */
  export type Project$workItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItem
     */
    select?: WorkItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItem
     */
    omit?: WorkItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemInclude<ExtArgs> | null
    where?: WorkItemWhereInput
    orderBy?: WorkItemOrderByWithRelationInput | WorkItemOrderByWithRelationInput[]
    cursor?: WorkItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkItemScalarFieldEnum | WorkItemScalarFieldEnum[]
  }

  /**
   * Project.sprints
   */
  export type Project$sprintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    where?: SprintWhereInput
    orderBy?: SprintOrderByWithRelationInput | SprintOrderByWithRelationInput[]
    cursor?: SprintWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SprintScalarFieldEnum | SprintScalarFieldEnum[]
  }

  /**
   * Project.milestones
   */
  export type Project$milestonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    where?: MilestoneWhereInput
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    cursor?: MilestoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MilestoneScalarFieldEnum | MilestoneScalarFieldEnum[]
  }

  /**
   * Project.boards
   */
  export type Project$boardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    where?: BoardWhereInput
    orderBy?: BoardOrderByWithRelationInput | BoardOrderByWithRelationInput[]
    cursor?: BoardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BoardScalarFieldEnum | BoardScalarFieldEnum[]
  }

  /**
   * Project.workflowRules
   */
  export type Project$workflowRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowRule
     */
    select?: WorkflowRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowRule
     */
    omit?: WorkflowRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowRuleInclude<ExtArgs> | null
    where?: WorkflowRuleWhereInput
    orderBy?: WorkflowRuleOrderByWithRelationInput | WorkflowRuleOrderByWithRelationInput[]
    cursor?: WorkflowRuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowRuleScalarFieldEnum | WorkflowRuleScalarFieldEnum[]
  }

  /**
   * Project.workItemStates
   */
  export type Project$workItemStatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItemState
     */
    select?: WorkItemStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItemState
     */
    omit?: WorkItemStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemStateInclude<ExtArgs> | null
    where?: WorkItemStateWhereInput
    orderBy?: WorkItemStateOrderByWithRelationInput | WorkItemStateOrderByWithRelationInput[]
    cursor?: WorkItemStateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkItemStateScalarFieldEnum | WorkItemStateScalarFieldEnum[]
  }

  /**
   * Project.components
   */
  export type Project$componentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Component
     */
    omit?: ComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
    where?: ComponentWhereInput
    orderBy?: ComponentOrderByWithRelationInput | ComponentOrderByWithRelationInput[]
    cursor?: ComponentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComponentScalarFieldEnum | ComponentScalarFieldEnum[]
  }

  /**
   * Project.teams
   */
  export type Project$teamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    cursor?: TeamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model Sprint
   */

  export type AggregateSprint = {
    _count: SprintCountAggregateOutputType | null
    _avg: SprintAvgAggregateOutputType | null
    _sum: SprintSumAggregateOutputType | null
    _min: SprintMinAggregateOutputType | null
    _max: SprintMaxAggregateOutputType | null
  }

  export type SprintAvgAggregateOutputType = {
    committedPoints: number | null
    completedPoints: number | null
    velocity: number | null
  }

  export type SprintSumAggregateOutputType = {
    committedPoints: number | null
    completedPoints: number | null
    velocity: number | null
  }

  export type SprintMinAggregateOutputType = {
    id: string | null
    name: string | null
    goal: string | null
    startDate: Date | null
    endDate: Date | null
    state: string | null
    committedPoints: number | null
    completedPoints: number | null
    velocity: number | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
  }

  export type SprintMaxAggregateOutputType = {
    id: string | null
    name: string | null
    goal: string | null
    startDate: Date | null
    endDate: Date | null
    state: string | null
    committedPoints: number | null
    completedPoints: number | null
    velocity: number | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
  }

  export type SprintCountAggregateOutputType = {
    id: number
    name: number
    goal: number
    startDate: number
    endDate: number
    state: number
    committedPoints: number
    completedPoints: number
    velocity: number
    createdAt: number
    updatedAt: number
    projectId: number
    _all: number
  }


  export type SprintAvgAggregateInputType = {
    committedPoints?: true
    completedPoints?: true
    velocity?: true
  }

  export type SprintSumAggregateInputType = {
    committedPoints?: true
    completedPoints?: true
    velocity?: true
  }

  export type SprintMinAggregateInputType = {
    id?: true
    name?: true
    goal?: true
    startDate?: true
    endDate?: true
    state?: true
    committedPoints?: true
    completedPoints?: true
    velocity?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type SprintMaxAggregateInputType = {
    id?: true
    name?: true
    goal?: true
    startDate?: true
    endDate?: true
    state?: true
    committedPoints?: true
    completedPoints?: true
    velocity?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type SprintCountAggregateInputType = {
    id?: true
    name?: true
    goal?: true
    startDate?: true
    endDate?: true
    state?: true
    committedPoints?: true
    completedPoints?: true
    velocity?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    _all?: true
  }

  export type SprintAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sprint to aggregate.
     */
    where?: SprintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sprints to fetch.
     */
    orderBy?: SprintOrderByWithRelationInput | SprintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SprintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sprints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sprints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sprints
    **/
    _count?: true | SprintCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SprintAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SprintSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SprintMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SprintMaxAggregateInputType
  }

  export type GetSprintAggregateType<T extends SprintAggregateArgs> = {
        [P in keyof T & keyof AggregateSprint]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSprint[P]>
      : GetScalarType<T[P], AggregateSprint[P]>
  }




  export type SprintGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SprintWhereInput
    orderBy?: SprintOrderByWithAggregationInput | SprintOrderByWithAggregationInput[]
    by: SprintScalarFieldEnum[] | SprintScalarFieldEnum
    having?: SprintScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SprintCountAggregateInputType | true
    _avg?: SprintAvgAggregateInputType
    _sum?: SprintSumAggregateInputType
    _min?: SprintMinAggregateInputType
    _max?: SprintMaxAggregateInputType
  }

  export type SprintGroupByOutputType = {
    id: string
    name: string
    goal: string | null
    startDate: Date
    endDate: Date
    state: string
    committedPoints: number
    completedPoints: number
    velocity: number | null
    createdAt: Date
    updatedAt: Date
    projectId: string
    _count: SprintCountAggregateOutputType | null
    _avg: SprintAvgAggregateOutputType | null
    _sum: SprintSumAggregateOutputType | null
    _min: SprintMinAggregateOutputType | null
    _max: SprintMaxAggregateOutputType | null
  }

  type GetSprintGroupByPayload<T extends SprintGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SprintGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SprintGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SprintGroupByOutputType[P]>
            : GetScalarType<T[P], SprintGroupByOutputType[P]>
        }
      >
    >


  export type SprintSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    goal?: boolean
    startDate?: boolean
    endDate?: boolean
    state?: boolean
    committedPoints?: boolean
    completedPoints?: boolean
    velocity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    workItems?: boolean | Sprint$workItemsArgs<ExtArgs>
    snapshots?: boolean | Sprint$snapshotsArgs<ExtArgs>
    retrospective?: boolean | Sprint$retrospectiveArgs<ExtArgs>
    timeLogs?: boolean | Sprint$timeLogsArgs<ExtArgs>
    boards?: boolean | Sprint$boardsArgs<ExtArgs>
    _count?: boolean | SprintCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sprint"]>

  export type SprintSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    goal?: boolean
    startDate?: boolean
    endDate?: boolean
    state?: boolean
    committedPoints?: boolean
    completedPoints?: boolean
    velocity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sprint"]>

  export type SprintSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    goal?: boolean
    startDate?: boolean
    endDate?: boolean
    state?: boolean
    committedPoints?: boolean
    completedPoints?: boolean
    velocity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sprint"]>

  export type SprintSelectScalar = {
    id?: boolean
    name?: boolean
    goal?: boolean
    startDate?: boolean
    endDate?: boolean
    state?: boolean
    committedPoints?: boolean
    completedPoints?: boolean
    velocity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
  }

  export type SprintOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "goal" | "startDate" | "endDate" | "state" | "committedPoints" | "completedPoints" | "velocity" | "createdAt" | "updatedAt" | "projectId", ExtArgs["result"]["sprint"]>
  export type SprintInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    workItems?: boolean | Sprint$workItemsArgs<ExtArgs>
    snapshots?: boolean | Sprint$snapshotsArgs<ExtArgs>
    retrospective?: boolean | Sprint$retrospectiveArgs<ExtArgs>
    timeLogs?: boolean | Sprint$timeLogsArgs<ExtArgs>
    boards?: boolean | Sprint$boardsArgs<ExtArgs>
    _count?: boolean | SprintCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SprintIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type SprintIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $SprintPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sprint"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      workItems: Prisma.$WorkItemPayload<ExtArgs>[]
      snapshots: Prisma.$WorkItemSnapshotPayload<ExtArgs>[]
      retrospective: Prisma.$RetrospectivePayload<ExtArgs> | null
      timeLogs: Prisma.$TimeLogPayload<ExtArgs>[]
      boards: Prisma.$BoardPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      goal: string | null
      startDate: Date
      endDate: Date
      state: string
      committedPoints: number
      completedPoints: number
      velocity: number | null
      createdAt: Date
      updatedAt: Date
      projectId: string
    }, ExtArgs["result"]["sprint"]>
    composites: {}
  }

  type SprintGetPayload<S extends boolean | null | undefined | SprintDefaultArgs> = $Result.GetResult<Prisma.$SprintPayload, S>

  type SprintCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SprintFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SprintCountAggregateInputType | true
    }

  export interface SprintDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sprint'], meta: { name: 'Sprint' } }
    /**
     * Find zero or one Sprint that matches the filter.
     * @param {SprintFindUniqueArgs} args - Arguments to find a Sprint
     * @example
     * // Get one Sprint
     * const sprint = await prisma.sprint.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SprintFindUniqueArgs>(args: SelectSubset<T, SprintFindUniqueArgs<ExtArgs>>): Prisma__SprintClient<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sprint that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SprintFindUniqueOrThrowArgs} args - Arguments to find a Sprint
     * @example
     * // Get one Sprint
     * const sprint = await prisma.sprint.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SprintFindUniqueOrThrowArgs>(args: SelectSubset<T, SprintFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SprintClient<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sprint that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SprintFindFirstArgs} args - Arguments to find a Sprint
     * @example
     * // Get one Sprint
     * const sprint = await prisma.sprint.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SprintFindFirstArgs>(args?: SelectSubset<T, SprintFindFirstArgs<ExtArgs>>): Prisma__SprintClient<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sprint that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SprintFindFirstOrThrowArgs} args - Arguments to find a Sprint
     * @example
     * // Get one Sprint
     * const sprint = await prisma.sprint.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SprintFindFirstOrThrowArgs>(args?: SelectSubset<T, SprintFindFirstOrThrowArgs<ExtArgs>>): Prisma__SprintClient<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sprints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SprintFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sprints
     * const sprints = await prisma.sprint.findMany()
     * 
     * // Get first 10 Sprints
     * const sprints = await prisma.sprint.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sprintWithIdOnly = await prisma.sprint.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SprintFindManyArgs>(args?: SelectSubset<T, SprintFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sprint.
     * @param {SprintCreateArgs} args - Arguments to create a Sprint.
     * @example
     * // Create one Sprint
     * const Sprint = await prisma.sprint.create({
     *   data: {
     *     // ... data to create a Sprint
     *   }
     * })
     * 
     */
    create<T extends SprintCreateArgs>(args: SelectSubset<T, SprintCreateArgs<ExtArgs>>): Prisma__SprintClient<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sprints.
     * @param {SprintCreateManyArgs} args - Arguments to create many Sprints.
     * @example
     * // Create many Sprints
     * const sprint = await prisma.sprint.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SprintCreateManyArgs>(args?: SelectSubset<T, SprintCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sprints and returns the data saved in the database.
     * @param {SprintCreateManyAndReturnArgs} args - Arguments to create many Sprints.
     * @example
     * // Create many Sprints
     * const sprint = await prisma.sprint.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sprints and only return the `id`
     * const sprintWithIdOnly = await prisma.sprint.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SprintCreateManyAndReturnArgs>(args?: SelectSubset<T, SprintCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Sprint.
     * @param {SprintDeleteArgs} args - Arguments to delete one Sprint.
     * @example
     * // Delete one Sprint
     * const Sprint = await prisma.sprint.delete({
     *   where: {
     *     // ... filter to delete one Sprint
     *   }
     * })
     * 
     */
    delete<T extends SprintDeleteArgs>(args: SelectSubset<T, SprintDeleteArgs<ExtArgs>>): Prisma__SprintClient<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sprint.
     * @param {SprintUpdateArgs} args - Arguments to update one Sprint.
     * @example
     * // Update one Sprint
     * const sprint = await prisma.sprint.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SprintUpdateArgs>(args: SelectSubset<T, SprintUpdateArgs<ExtArgs>>): Prisma__SprintClient<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sprints.
     * @param {SprintDeleteManyArgs} args - Arguments to filter Sprints to delete.
     * @example
     * // Delete a few Sprints
     * const { count } = await prisma.sprint.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SprintDeleteManyArgs>(args?: SelectSubset<T, SprintDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sprints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SprintUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sprints
     * const sprint = await prisma.sprint.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SprintUpdateManyArgs>(args: SelectSubset<T, SprintUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sprints and returns the data updated in the database.
     * @param {SprintUpdateManyAndReturnArgs} args - Arguments to update many Sprints.
     * @example
     * // Update many Sprints
     * const sprint = await prisma.sprint.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sprints and only return the `id`
     * const sprintWithIdOnly = await prisma.sprint.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SprintUpdateManyAndReturnArgs>(args: SelectSubset<T, SprintUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Sprint.
     * @param {SprintUpsertArgs} args - Arguments to update or create a Sprint.
     * @example
     * // Update or create a Sprint
     * const sprint = await prisma.sprint.upsert({
     *   create: {
     *     // ... data to create a Sprint
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sprint we want to update
     *   }
     * })
     */
    upsert<T extends SprintUpsertArgs>(args: SelectSubset<T, SprintUpsertArgs<ExtArgs>>): Prisma__SprintClient<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sprints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SprintCountArgs} args - Arguments to filter Sprints to count.
     * @example
     * // Count the number of Sprints
     * const count = await prisma.sprint.count({
     *   where: {
     *     // ... the filter for the Sprints we want to count
     *   }
     * })
    **/
    count<T extends SprintCountArgs>(
      args?: Subset<T, SprintCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SprintCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sprint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SprintAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SprintAggregateArgs>(args: Subset<T, SprintAggregateArgs>): Prisma.PrismaPromise<GetSprintAggregateType<T>>

    /**
     * Group by Sprint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SprintGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SprintGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SprintGroupByArgs['orderBy'] }
        : { orderBy?: SprintGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SprintGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSprintGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sprint model
   */
  readonly fields: SprintFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sprint.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SprintClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    workItems<T extends Sprint$workItemsArgs<ExtArgs> = {}>(args?: Subset<T, Sprint$workItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    snapshots<T extends Sprint$snapshotsArgs<ExtArgs> = {}>(args?: Subset<T, Sprint$snapshotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkItemSnapshotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    retrospective<T extends Sprint$retrospectiveArgs<ExtArgs> = {}>(args?: Subset<T, Sprint$retrospectiveArgs<ExtArgs>>): Prisma__RetrospectiveClient<$Result.GetResult<Prisma.$RetrospectivePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    timeLogs<T extends Sprint$timeLogsArgs<ExtArgs> = {}>(args?: Subset<T, Sprint$timeLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    boards<T extends Sprint$boardsArgs<ExtArgs> = {}>(args?: Subset<T, Sprint$boardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Sprint model
   */
  interface SprintFieldRefs {
    readonly id: FieldRef<"Sprint", 'String'>
    readonly name: FieldRef<"Sprint", 'String'>
    readonly goal: FieldRef<"Sprint", 'String'>
    readonly startDate: FieldRef<"Sprint", 'DateTime'>
    readonly endDate: FieldRef<"Sprint", 'DateTime'>
    readonly state: FieldRef<"Sprint", 'String'>
    readonly committedPoints: FieldRef<"Sprint", 'Float'>
    readonly completedPoints: FieldRef<"Sprint", 'Float'>
    readonly velocity: FieldRef<"Sprint", 'Float'>
    readonly createdAt: FieldRef<"Sprint", 'DateTime'>
    readonly updatedAt: FieldRef<"Sprint", 'DateTime'>
    readonly projectId: FieldRef<"Sprint", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Sprint findUnique
   */
  export type SprintFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    /**
     * Filter, which Sprint to fetch.
     */
    where: SprintWhereUniqueInput
  }

  /**
   * Sprint findUniqueOrThrow
   */
  export type SprintFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    /**
     * Filter, which Sprint to fetch.
     */
    where: SprintWhereUniqueInput
  }

  /**
   * Sprint findFirst
   */
  export type SprintFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    /**
     * Filter, which Sprint to fetch.
     */
    where?: SprintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sprints to fetch.
     */
    orderBy?: SprintOrderByWithRelationInput | SprintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sprints.
     */
    cursor?: SprintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sprints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sprints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sprints.
     */
    distinct?: SprintScalarFieldEnum | SprintScalarFieldEnum[]
  }

  /**
   * Sprint findFirstOrThrow
   */
  export type SprintFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    /**
     * Filter, which Sprint to fetch.
     */
    where?: SprintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sprints to fetch.
     */
    orderBy?: SprintOrderByWithRelationInput | SprintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sprints.
     */
    cursor?: SprintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sprints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sprints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sprints.
     */
    distinct?: SprintScalarFieldEnum | SprintScalarFieldEnum[]
  }

  /**
   * Sprint findMany
   */
  export type SprintFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    /**
     * Filter, which Sprints to fetch.
     */
    where?: SprintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sprints to fetch.
     */
    orderBy?: SprintOrderByWithRelationInput | SprintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sprints.
     */
    cursor?: SprintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sprints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sprints.
     */
    skip?: number
    distinct?: SprintScalarFieldEnum | SprintScalarFieldEnum[]
  }

  /**
   * Sprint create
   */
  export type SprintCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    /**
     * The data needed to create a Sprint.
     */
    data: XOR<SprintCreateInput, SprintUncheckedCreateInput>
  }

  /**
   * Sprint createMany
   */
  export type SprintCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sprints.
     */
    data: SprintCreateManyInput | SprintCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sprint createManyAndReturn
   */
  export type SprintCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * The data used to create many Sprints.
     */
    data: SprintCreateManyInput | SprintCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Sprint update
   */
  export type SprintUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    /**
     * The data needed to update a Sprint.
     */
    data: XOR<SprintUpdateInput, SprintUncheckedUpdateInput>
    /**
     * Choose, which Sprint to update.
     */
    where: SprintWhereUniqueInput
  }

  /**
   * Sprint updateMany
   */
  export type SprintUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sprints.
     */
    data: XOR<SprintUpdateManyMutationInput, SprintUncheckedUpdateManyInput>
    /**
     * Filter which Sprints to update
     */
    where?: SprintWhereInput
    /**
     * Limit how many Sprints to update.
     */
    limit?: number
  }

  /**
   * Sprint updateManyAndReturn
   */
  export type SprintUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * The data used to update Sprints.
     */
    data: XOR<SprintUpdateManyMutationInput, SprintUncheckedUpdateManyInput>
    /**
     * Filter which Sprints to update
     */
    where?: SprintWhereInput
    /**
     * Limit how many Sprints to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Sprint upsert
   */
  export type SprintUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    /**
     * The filter to search for the Sprint to update in case it exists.
     */
    where: SprintWhereUniqueInput
    /**
     * In case the Sprint found by the `where` argument doesn't exist, create a new Sprint with this data.
     */
    create: XOR<SprintCreateInput, SprintUncheckedCreateInput>
    /**
     * In case the Sprint was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SprintUpdateInput, SprintUncheckedUpdateInput>
  }

  /**
   * Sprint delete
   */
  export type SprintDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    /**
     * Filter which Sprint to delete.
     */
    where: SprintWhereUniqueInput
  }

  /**
   * Sprint deleteMany
   */
  export type SprintDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sprints to delete
     */
    where?: SprintWhereInput
    /**
     * Limit how many Sprints to delete.
     */
    limit?: number
  }

  /**
   * Sprint.workItems
   */
  export type Sprint$workItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItem
     */
    select?: WorkItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItem
     */
    omit?: WorkItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemInclude<ExtArgs> | null
    where?: WorkItemWhereInput
    orderBy?: WorkItemOrderByWithRelationInput | WorkItemOrderByWithRelationInput[]
    cursor?: WorkItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkItemScalarFieldEnum | WorkItemScalarFieldEnum[]
  }

  /**
   * Sprint.snapshots
   */
  export type Sprint$snapshotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItemSnapshot
     */
    select?: WorkItemSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItemSnapshot
     */
    omit?: WorkItemSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemSnapshotInclude<ExtArgs> | null
    where?: WorkItemSnapshotWhereInput
    orderBy?: WorkItemSnapshotOrderByWithRelationInput | WorkItemSnapshotOrderByWithRelationInput[]
    cursor?: WorkItemSnapshotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkItemSnapshotScalarFieldEnum | WorkItemSnapshotScalarFieldEnum[]
  }

  /**
   * Sprint.retrospective
   */
  export type Sprint$retrospectiveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Retrospective
     */
    select?: RetrospectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Retrospective
     */
    omit?: RetrospectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetrospectiveInclude<ExtArgs> | null
    where?: RetrospectiveWhereInput
  }

  /**
   * Sprint.timeLogs
   */
  export type Sprint$timeLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeLog
     */
    select?: TimeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeLog
     */
    omit?: TimeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeLogInclude<ExtArgs> | null
    where?: TimeLogWhereInput
    orderBy?: TimeLogOrderByWithRelationInput | TimeLogOrderByWithRelationInput[]
    cursor?: TimeLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimeLogScalarFieldEnum | TimeLogScalarFieldEnum[]
  }

  /**
   * Sprint.boards
   */
  export type Sprint$boardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    where?: BoardWhereInput
    orderBy?: BoardOrderByWithRelationInput | BoardOrderByWithRelationInput[]
    cursor?: BoardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BoardScalarFieldEnum | BoardScalarFieldEnum[]
  }

  /**
   * Sprint without action
   */
  export type SprintDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
  }


  /**
   * Model Milestone
   */

  export type AggregateMilestone = {
    _count: MilestoneCountAggregateOutputType | null
    _min: MilestoneMinAggregateOutputType | null
    _max: MilestoneMaxAggregateOutputType | null
  }

  export type MilestoneMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    dueDate: Date | null
    completed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
  }

  export type MilestoneMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    dueDate: Date | null
    completed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
  }

  export type MilestoneCountAggregateOutputType = {
    id: number
    name: number
    description: number
    dueDate: number
    completed: number
    createdAt: number
    updatedAt: number
    projectId: number
    _all: number
  }


  export type MilestoneMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    dueDate?: true
    completed?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type MilestoneMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    dueDate?: true
    completed?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type MilestoneCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    dueDate?: true
    completed?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    _all?: true
  }

  export type MilestoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Milestone to aggregate.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Milestones
    **/
    _count?: true | MilestoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MilestoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MilestoneMaxAggregateInputType
  }

  export type GetMilestoneAggregateType<T extends MilestoneAggregateArgs> = {
        [P in keyof T & keyof AggregateMilestone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMilestone[P]>
      : GetScalarType<T[P], AggregateMilestone[P]>
  }




  export type MilestoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MilestoneWhereInput
    orderBy?: MilestoneOrderByWithAggregationInput | MilestoneOrderByWithAggregationInput[]
    by: MilestoneScalarFieldEnum[] | MilestoneScalarFieldEnum
    having?: MilestoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MilestoneCountAggregateInputType | true
    _min?: MilestoneMinAggregateInputType
    _max?: MilestoneMaxAggregateInputType
  }

  export type MilestoneGroupByOutputType = {
    id: string
    name: string
    description: string | null
    dueDate: Date
    completed: boolean
    createdAt: Date
    updatedAt: Date
    projectId: string
    _count: MilestoneCountAggregateOutputType | null
    _min: MilestoneMinAggregateOutputType | null
    _max: MilestoneMaxAggregateOutputType | null
  }

  type GetMilestoneGroupByPayload<T extends MilestoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MilestoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MilestoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MilestoneGroupByOutputType[P]>
            : GetScalarType<T[P], MilestoneGroupByOutputType[P]>
        }
      >
    >


  export type MilestoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    dueDate?: boolean
    completed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["milestone"]>

  export type MilestoneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    dueDate?: boolean
    completed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["milestone"]>

  export type MilestoneSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    dueDate?: boolean
    completed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["milestone"]>

  export type MilestoneSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    dueDate?: boolean
    completed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
  }

  export type MilestoneOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "dueDate" | "completed" | "createdAt" | "updatedAt" | "projectId", ExtArgs["result"]["milestone"]>
  export type MilestoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type MilestoneIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type MilestoneIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $MilestonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Milestone"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      dueDate: Date
      completed: boolean
      createdAt: Date
      updatedAt: Date
      projectId: string
    }, ExtArgs["result"]["milestone"]>
    composites: {}
  }

  type MilestoneGetPayload<S extends boolean | null | undefined | MilestoneDefaultArgs> = $Result.GetResult<Prisma.$MilestonePayload, S>

  type MilestoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MilestoneFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MilestoneCountAggregateInputType | true
    }

  export interface MilestoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Milestone'], meta: { name: 'Milestone' } }
    /**
     * Find zero or one Milestone that matches the filter.
     * @param {MilestoneFindUniqueArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MilestoneFindUniqueArgs>(args: SelectSubset<T, MilestoneFindUniqueArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Milestone that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MilestoneFindUniqueOrThrowArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MilestoneFindUniqueOrThrowArgs>(args: SelectSubset<T, MilestoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Milestone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneFindFirstArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MilestoneFindFirstArgs>(args?: SelectSubset<T, MilestoneFindFirstArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Milestone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneFindFirstOrThrowArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MilestoneFindFirstOrThrowArgs>(args?: SelectSubset<T, MilestoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Milestones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Milestones
     * const milestones = await prisma.milestone.findMany()
     * 
     * // Get first 10 Milestones
     * const milestones = await prisma.milestone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const milestoneWithIdOnly = await prisma.milestone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MilestoneFindManyArgs>(args?: SelectSubset<T, MilestoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Milestone.
     * @param {MilestoneCreateArgs} args - Arguments to create a Milestone.
     * @example
     * // Create one Milestone
     * const Milestone = await prisma.milestone.create({
     *   data: {
     *     // ... data to create a Milestone
     *   }
     * })
     * 
     */
    create<T extends MilestoneCreateArgs>(args: SelectSubset<T, MilestoneCreateArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Milestones.
     * @param {MilestoneCreateManyArgs} args - Arguments to create many Milestones.
     * @example
     * // Create many Milestones
     * const milestone = await prisma.milestone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MilestoneCreateManyArgs>(args?: SelectSubset<T, MilestoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Milestones and returns the data saved in the database.
     * @param {MilestoneCreateManyAndReturnArgs} args - Arguments to create many Milestones.
     * @example
     * // Create many Milestones
     * const milestone = await prisma.milestone.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Milestones and only return the `id`
     * const milestoneWithIdOnly = await prisma.milestone.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MilestoneCreateManyAndReturnArgs>(args?: SelectSubset<T, MilestoneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Milestone.
     * @param {MilestoneDeleteArgs} args - Arguments to delete one Milestone.
     * @example
     * // Delete one Milestone
     * const Milestone = await prisma.milestone.delete({
     *   where: {
     *     // ... filter to delete one Milestone
     *   }
     * })
     * 
     */
    delete<T extends MilestoneDeleteArgs>(args: SelectSubset<T, MilestoneDeleteArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Milestone.
     * @param {MilestoneUpdateArgs} args - Arguments to update one Milestone.
     * @example
     * // Update one Milestone
     * const milestone = await prisma.milestone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MilestoneUpdateArgs>(args: SelectSubset<T, MilestoneUpdateArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Milestones.
     * @param {MilestoneDeleteManyArgs} args - Arguments to filter Milestones to delete.
     * @example
     * // Delete a few Milestones
     * const { count } = await prisma.milestone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MilestoneDeleteManyArgs>(args?: SelectSubset<T, MilestoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Milestones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Milestones
     * const milestone = await prisma.milestone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MilestoneUpdateManyArgs>(args: SelectSubset<T, MilestoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Milestones and returns the data updated in the database.
     * @param {MilestoneUpdateManyAndReturnArgs} args - Arguments to update many Milestones.
     * @example
     * // Update many Milestones
     * const milestone = await prisma.milestone.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Milestones and only return the `id`
     * const milestoneWithIdOnly = await prisma.milestone.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MilestoneUpdateManyAndReturnArgs>(args: SelectSubset<T, MilestoneUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Milestone.
     * @param {MilestoneUpsertArgs} args - Arguments to update or create a Milestone.
     * @example
     * // Update or create a Milestone
     * const milestone = await prisma.milestone.upsert({
     *   create: {
     *     // ... data to create a Milestone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Milestone we want to update
     *   }
     * })
     */
    upsert<T extends MilestoneUpsertArgs>(args: SelectSubset<T, MilestoneUpsertArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Milestones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneCountArgs} args - Arguments to filter Milestones to count.
     * @example
     * // Count the number of Milestones
     * const count = await prisma.milestone.count({
     *   where: {
     *     // ... the filter for the Milestones we want to count
     *   }
     * })
    **/
    count<T extends MilestoneCountArgs>(
      args?: Subset<T, MilestoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MilestoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Milestone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MilestoneAggregateArgs>(args: Subset<T, MilestoneAggregateArgs>): Prisma.PrismaPromise<GetMilestoneAggregateType<T>>

    /**
     * Group by Milestone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MilestoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MilestoneGroupByArgs['orderBy'] }
        : { orderBy?: MilestoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MilestoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMilestoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Milestone model
   */
  readonly fields: MilestoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Milestone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MilestoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Milestone model
   */
  interface MilestoneFieldRefs {
    readonly id: FieldRef<"Milestone", 'String'>
    readonly name: FieldRef<"Milestone", 'String'>
    readonly description: FieldRef<"Milestone", 'String'>
    readonly dueDate: FieldRef<"Milestone", 'DateTime'>
    readonly completed: FieldRef<"Milestone", 'Boolean'>
    readonly createdAt: FieldRef<"Milestone", 'DateTime'>
    readonly updatedAt: FieldRef<"Milestone", 'DateTime'>
    readonly projectId: FieldRef<"Milestone", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Milestone findUnique
   */
  export type MilestoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where: MilestoneWhereUniqueInput
  }

  /**
   * Milestone findUniqueOrThrow
   */
  export type MilestoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where: MilestoneWhereUniqueInput
  }

  /**
   * Milestone findFirst
   */
  export type MilestoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Milestones.
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Milestones.
     */
    distinct?: MilestoneScalarFieldEnum | MilestoneScalarFieldEnum[]
  }

  /**
   * Milestone findFirstOrThrow
   */
  export type MilestoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Milestones.
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Milestones.
     */
    distinct?: MilestoneScalarFieldEnum | MilestoneScalarFieldEnum[]
  }

  /**
   * Milestone findMany
   */
  export type MilestoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestones to fetch.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Milestones.
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    distinct?: MilestoneScalarFieldEnum | MilestoneScalarFieldEnum[]
  }

  /**
   * Milestone create
   */
  export type MilestoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * The data needed to create a Milestone.
     */
    data: XOR<MilestoneCreateInput, MilestoneUncheckedCreateInput>
  }

  /**
   * Milestone createMany
   */
  export type MilestoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Milestones.
     */
    data: MilestoneCreateManyInput | MilestoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Milestone createManyAndReturn
   */
  export type MilestoneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * The data used to create many Milestones.
     */
    data: MilestoneCreateManyInput | MilestoneCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Milestone update
   */
  export type MilestoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * The data needed to update a Milestone.
     */
    data: XOR<MilestoneUpdateInput, MilestoneUncheckedUpdateInput>
    /**
     * Choose, which Milestone to update.
     */
    where: MilestoneWhereUniqueInput
  }

  /**
   * Milestone updateMany
   */
  export type MilestoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Milestones.
     */
    data: XOR<MilestoneUpdateManyMutationInput, MilestoneUncheckedUpdateManyInput>
    /**
     * Filter which Milestones to update
     */
    where?: MilestoneWhereInput
    /**
     * Limit how many Milestones to update.
     */
    limit?: number
  }

  /**
   * Milestone updateManyAndReturn
   */
  export type MilestoneUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * The data used to update Milestones.
     */
    data: XOR<MilestoneUpdateManyMutationInput, MilestoneUncheckedUpdateManyInput>
    /**
     * Filter which Milestones to update
     */
    where?: MilestoneWhereInput
    /**
     * Limit how many Milestones to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Milestone upsert
   */
  export type MilestoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * The filter to search for the Milestone to update in case it exists.
     */
    where: MilestoneWhereUniqueInput
    /**
     * In case the Milestone found by the `where` argument doesn't exist, create a new Milestone with this data.
     */
    create: XOR<MilestoneCreateInput, MilestoneUncheckedCreateInput>
    /**
     * In case the Milestone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MilestoneUpdateInput, MilestoneUncheckedUpdateInput>
  }

  /**
   * Milestone delete
   */
  export type MilestoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter which Milestone to delete.
     */
    where: MilestoneWhereUniqueInput
  }

  /**
   * Milestone deleteMany
   */
  export type MilestoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Milestones to delete
     */
    where?: MilestoneWhereInput
    /**
     * Limit how many Milestones to delete.
     */
    limit?: number
  }

  /**
   * Milestone without action
   */
  export type MilestoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
  }


  /**
   * Model Retrospective
   */

  export type AggregateRetrospective = {
    _count: RetrospectiveCountAggregateOutputType | null
    _min: RetrospectiveMinAggregateOutputType | null
    _max: RetrospectiveMaxAggregateOutputType | null
  }

  export type RetrospectiveMinAggregateOutputType = {
    id: string | null
    sentimentSummary: string | null
    createdAt: Date | null
    updatedAt: Date | null
    sprintId: string | null
  }

  export type RetrospectiveMaxAggregateOutputType = {
    id: string | null
    sentimentSummary: string | null
    createdAt: Date | null
    updatedAt: Date | null
    sprintId: string | null
  }

  export type RetrospectiveCountAggregateOutputType = {
    id: number
    content: number
    sentimentSummary: number
    createdAt: number
    updatedAt: number
    sprintId: number
    _all: number
  }


  export type RetrospectiveMinAggregateInputType = {
    id?: true
    sentimentSummary?: true
    createdAt?: true
    updatedAt?: true
    sprintId?: true
  }

  export type RetrospectiveMaxAggregateInputType = {
    id?: true
    sentimentSummary?: true
    createdAt?: true
    updatedAt?: true
    sprintId?: true
  }

  export type RetrospectiveCountAggregateInputType = {
    id?: true
    content?: true
    sentimentSummary?: true
    createdAt?: true
    updatedAt?: true
    sprintId?: true
    _all?: true
  }

  export type RetrospectiveAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Retrospective to aggregate.
     */
    where?: RetrospectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Retrospectives to fetch.
     */
    orderBy?: RetrospectiveOrderByWithRelationInput | RetrospectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RetrospectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Retrospectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Retrospectives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Retrospectives
    **/
    _count?: true | RetrospectiveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RetrospectiveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RetrospectiveMaxAggregateInputType
  }

  export type GetRetrospectiveAggregateType<T extends RetrospectiveAggregateArgs> = {
        [P in keyof T & keyof AggregateRetrospective]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRetrospective[P]>
      : GetScalarType<T[P], AggregateRetrospective[P]>
  }




  export type RetrospectiveGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RetrospectiveWhereInput
    orderBy?: RetrospectiveOrderByWithAggregationInput | RetrospectiveOrderByWithAggregationInput[]
    by: RetrospectiveScalarFieldEnum[] | RetrospectiveScalarFieldEnum
    having?: RetrospectiveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RetrospectiveCountAggregateInputType | true
    _min?: RetrospectiveMinAggregateInputType
    _max?: RetrospectiveMaxAggregateInputType
  }

  export type RetrospectiveGroupByOutputType = {
    id: string
    content: JsonValue
    sentimentSummary: string | null
    createdAt: Date
    updatedAt: Date
    sprintId: string
    _count: RetrospectiveCountAggregateOutputType | null
    _min: RetrospectiveMinAggregateOutputType | null
    _max: RetrospectiveMaxAggregateOutputType | null
  }

  type GetRetrospectiveGroupByPayload<T extends RetrospectiveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RetrospectiveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RetrospectiveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RetrospectiveGroupByOutputType[P]>
            : GetScalarType<T[P], RetrospectiveGroupByOutputType[P]>
        }
      >
    >


  export type RetrospectiveSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    sentimentSummary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sprintId?: boolean
    sprint?: boolean | SprintDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["retrospective"]>

  export type RetrospectiveSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    sentimentSummary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sprintId?: boolean
    sprint?: boolean | SprintDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["retrospective"]>

  export type RetrospectiveSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    sentimentSummary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sprintId?: boolean
    sprint?: boolean | SprintDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["retrospective"]>

  export type RetrospectiveSelectScalar = {
    id?: boolean
    content?: boolean
    sentimentSummary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sprintId?: boolean
  }

  export type RetrospectiveOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "sentimentSummary" | "createdAt" | "updatedAt" | "sprintId", ExtArgs["result"]["retrospective"]>
  export type RetrospectiveInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sprint?: boolean | SprintDefaultArgs<ExtArgs>
  }
  export type RetrospectiveIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sprint?: boolean | SprintDefaultArgs<ExtArgs>
  }
  export type RetrospectiveIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sprint?: boolean | SprintDefaultArgs<ExtArgs>
  }

  export type $RetrospectivePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Retrospective"
    objects: {
      sprint: Prisma.$SprintPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: Prisma.JsonValue
      sentimentSummary: string | null
      createdAt: Date
      updatedAt: Date
      sprintId: string
    }, ExtArgs["result"]["retrospective"]>
    composites: {}
  }

  type RetrospectiveGetPayload<S extends boolean | null | undefined | RetrospectiveDefaultArgs> = $Result.GetResult<Prisma.$RetrospectivePayload, S>

  type RetrospectiveCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RetrospectiveFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RetrospectiveCountAggregateInputType | true
    }

  export interface RetrospectiveDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Retrospective'], meta: { name: 'Retrospective' } }
    /**
     * Find zero or one Retrospective that matches the filter.
     * @param {RetrospectiveFindUniqueArgs} args - Arguments to find a Retrospective
     * @example
     * // Get one Retrospective
     * const retrospective = await prisma.retrospective.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RetrospectiveFindUniqueArgs>(args: SelectSubset<T, RetrospectiveFindUniqueArgs<ExtArgs>>): Prisma__RetrospectiveClient<$Result.GetResult<Prisma.$RetrospectivePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Retrospective that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RetrospectiveFindUniqueOrThrowArgs} args - Arguments to find a Retrospective
     * @example
     * // Get one Retrospective
     * const retrospective = await prisma.retrospective.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RetrospectiveFindUniqueOrThrowArgs>(args: SelectSubset<T, RetrospectiveFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RetrospectiveClient<$Result.GetResult<Prisma.$RetrospectivePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Retrospective that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetrospectiveFindFirstArgs} args - Arguments to find a Retrospective
     * @example
     * // Get one Retrospective
     * const retrospective = await prisma.retrospective.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RetrospectiveFindFirstArgs>(args?: SelectSubset<T, RetrospectiveFindFirstArgs<ExtArgs>>): Prisma__RetrospectiveClient<$Result.GetResult<Prisma.$RetrospectivePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Retrospective that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetrospectiveFindFirstOrThrowArgs} args - Arguments to find a Retrospective
     * @example
     * // Get one Retrospective
     * const retrospective = await prisma.retrospective.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RetrospectiveFindFirstOrThrowArgs>(args?: SelectSubset<T, RetrospectiveFindFirstOrThrowArgs<ExtArgs>>): Prisma__RetrospectiveClient<$Result.GetResult<Prisma.$RetrospectivePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Retrospectives that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetrospectiveFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Retrospectives
     * const retrospectives = await prisma.retrospective.findMany()
     * 
     * // Get first 10 Retrospectives
     * const retrospectives = await prisma.retrospective.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const retrospectiveWithIdOnly = await prisma.retrospective.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RetrospectiveFindManyArgs>(args?: SelectSubset<T, RetrospectiveFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RetrospectivePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Retrospective.
     * @param {RetrospectiveCreateArgs} args - Arguments to create a Retrospective.
     * @example
     * // Create one Retrospective
     * const Retrospective = await prisma.retrospective.create({
     *   data: {
     *     // ... data to create a Retrospective
     *   }
     * })
     * 
     */
    create<T extends RetrospectiveCreateArgs>(args: SelectSubset<T, RetrospectiveCreateArgs<ExtArgs>>): Prisma__RetrospectiveClient<$Result.GetResult<Prisma.$RetrospectivePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Retrospectives.
     * @param {RetrospectiveCreateManyArgs} args - Arguments to create many Retrospectives.
     * @example
     * // Create many Retrospectives
     * const retrospective = await prisma.retrospective.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RetrospectiveCreateManyArgs>(args?: SelectSubset<T, RetrospectiveCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Retrospectives and returns the data saved in the database.
     * @param {RetrospectiveCreateManyAndReturnArgs} args - Arguments to create many Retrospectives.
     * @example
     * // Create many Retrospectives
     * const retrospective = await prisma.retrospective.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Retrospectives and only return the `id`
     * const retrospectiveWithIdOnly = await prisma.retrospective.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RetrospectiveCreateManyAndReturnArgs>(args?: SelectSubset<T, RetrospectiveCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RetrospectivePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Retrospective.
     * @param {RetrospectiveDeleteArgs} args - Arguments to delete one Retrospective.
     * @example
     * // Delete one Retrospective
     * const Retrospective = await prisma.retrospective.delete({
     *   where: {
     *     // ... filter to delete one Retrospective
     *   }
     * })
     * 
     */
    delete<T extends RetrospectiveDeleteArgs>(args: SelectSubset<T, RetrospectiveDeleteArgs<ExtArgs>>): Prisma__RetrospectiveClient<$Result.GetResult<Prisma.$RetrospectivePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Retrospective.
     * @param {RetrospectiveUpdateArgs} args - Arguments to update one Retrospective.
     * @example
     * // Update one Retrospective
     * const retrospective = await prisma.retrospective.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RetrospectiveUpdateArgs>(args: SelectSubset<T, RetrospectiveUpdateArgs<ExtArgs>>): Prisma__RetrospectiveClient<$Result.GetResult<Prisma.$RetrospectivePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Retrospectives.
     * @param {RetrospectiveDeleteManyArgs} args - Arguments to filter Retrospectives to delete.
     * @example
     * // Delete a few Retrospectives
     * const { count } = await prisma.retrospective.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RetrospectiveDeleteManyArgs>(args?: SelectSubset<T, RetrospectiveDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Retrospectives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetrospectiveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Retrospectives
     * const retrospective = await prisma.retrospective.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RetrospectiveUpdateManyArgs>(args: SelectSubset<T, RetrospectiveUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Retrospectives and returns the data updated in the database.
     * @param {RetrospectiveUpdateManyAndReturnArgs} args - Arguments to update many Retrospectives.
     * @example
     * // Update many Retrospectives
     * const retrospective = await prisma.retrospective.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Retrospectives and only return the `id`
     * const retrospectiveWithIdOnly = await prisma.retrospective.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RetrospectiveUpdateManyAndReturnArgs>(args: SelectSubset<T, RetrospectiveUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RetrospectivePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Retrospective.
     * @param {RetrospectiveUpsertArgs} args - Arguments to update or create a Retrospective.
     * @example
     * // Update or create a Retrospective
     * const retrospective = await prisma.retrospective.upsert({
     *   create: {
     *     // ... data to create a Retrospective
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Retrospective we want to update
     *   }
     * })
     */
    upsert<T extends RetrospectiveUpsertArgs>(args: SelectSubset<T, RetrospectiveUpsertArgs<ExtArgs>>): Prisma__RetrospectiveClient<$Result.GetResult<Prisma.$RetrospectivePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Retrospectives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetrospectiveCountArgs} args - Arguments to filter Retrospectives to count.
     * @example
     * // Count the number of Retrospectives
     * const count = await prisma.retrospective.count({
     *   where: {
     *     // ... the filter for the Retrospectives we want to count
     *   }
     * })
    **/
    count<T extends RetrospectiveCountArgs>(
      args?: Subset<T, RetrospectiveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RetrospectiveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Retrospective.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetrospectiveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RetrospectiveAggregateArgs>(args: Subset<T, RetrospectiveAggregateArgs>): Prisma.PrismaPromise<GetRetrospectiveAggregateType<T>>

    /**
     * Group by Retrospective.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RetrospectiveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RetrospectiveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RetrospectiveGroupByArgs['orderBy'] }
        : { orderBy?: RetrospectiveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RetrospectiveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRetrospectiveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Retrospective model
   */
  readonly fields: RetrospectiveFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Retrospective.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RetrospectiveClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sprint<T extends SprintDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SprintDefaultArgs<ExtArgs>>): Prisma__SprintClient<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Retrospective model
   */
  interface RetrospectiveFieldRefs {
    readonly id: FieldRef<"Retrospective", 'String'>
    readonly content: FieldRef<"Retrospective", 'Json'>
    readonly sentimentSummary: FieldRef<"Retrospective", 'String'>
    readonly createdAt: FieldRef<"Retrospective", 'DateTime'>
    readonly updatedAt: FieldRef<"Retrospective", 'DateTime'>
    readonly sprintId: FieldRef<"Retrospective", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Retrospective findUnique
   */
  export type RetrospectiveFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Retrospective
     */
    select?: RetrospectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Retrospective
     */
    omit?: RetrospectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetrospectiveInclude<ExtArgs> | null
    /**
     * Filter, which Retrospective to fetch.
     */
    where: RetrospectiveWhereUniqueInput
  }

  /**
   * Retrospective findUniqueOrThrow
   */
  export type RetrospectiveFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Retrospective
     */
    select?: RetrospectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Retrospective
     */
    omit?: RetrospectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetrospectiveInclude<ExtArgs> | null
    /**
     * Filter, which Retrospective to fetch.
     */
    where: RetrospectiveWhereUniqueInput
  }

  /**
   * Retrospective findFirst
   */
  export type RetrospectiveFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Retrospective
     */
    select?: RetrospectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Retrospective
     */
    omit?: RetrospectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetrospectiveInclude<ExtArgs> | null
    /**
     * Filter, which Retrospective to fetch.
     */
    where?: RetrospectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Retrospectives to fetch.
     */
    orderBy?: RetrospectiveOrderByWithRelationInput | RetrospectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Retrospectives.
     */
    cursor?: RetrospectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Retrospectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Retrospectives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Retrospectives.
     */
    distinct?: RetrospectiveScalarFieldEnum | RetrospectiveScalarFieldEnum[]
  }

  /**
   * Retrospective findFirstOrThrow
   */
  export type RetrospectiveFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Retrospective
     */
    select?: RetrospectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Retrospective
     */
    omit?: RetrospectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetrospectiveInclude<ExtArgs> | null
    /**
     * Filter, which Retrospective to fetch.
     */
    where?: RetrospectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Retrospectives to fetch.
     */
    orderBy?: RetrospectiveOrderByWithRelationInput | RetrospectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Retrospectives.
     */
    cursor?: RetrospectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Retrospectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Retrospectives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Retrospectives.
     */
    distinct?: RetrospectiveScalarFieldEnum | RetrospectiveScalarFieldEnum[]
  }

  /**
   * Retrospective findMany
   */
  export type RetrospectiveFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Retrospective
     */
    select?: RetrospectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Retrospective
     */
    omit?: RetrospectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetrospectiveInclude<ExtArgs> | null
    /**
     * Filter, which Retrospectives to fetch.
     */
    where?: RetrospectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Retrospectives to fetch.
     */
    orderBy?: RetrospectiveOrderByWithRelationInput | RetrospectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Retrospectives.
     */
    cursor?: RetrospectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Retrospectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Retrospectives.
     */
    skip?: number
    distinct?: RetrospectiveScalarFieldEnum | RetrospectiveScalarFieldEnum[]
  }

  /**
   * Retrospective create
   */
  export type RetrospectiveCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Retrospective
     */
    select?: RetrospectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Retrospective
     */
    omit?: RetrospectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetrospectiveInclude<ExtArgs> | null
    /**
     * The data needed to create a Retrospective.
     */
    data: XOR<RetrospectiveCreateInput, RetrospectiveUncheckedCreateInput>
  }

  /**
   * Retrospective createMany
   */
  export type RetrospectiveCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Retrospectives.
     */
    data: RetrospectiveCreateManyInput | RetrospectiveCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Retrospective createManyAndReturn
   */
  export type RetrospectiveCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Retrospective
     */
    select?: RetrospectiveSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Retrospective
     */
    omit?: RetrospectiveOmit<ExtArgs> | null
    /**
     * The data used to create many Retrospectives.
     */
    data: RetrospectiveCreateManyInput | RetrospectiveCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetrospectiveIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Retrospective update
   */
  export type RetrospectiveUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Retrospective
     */
    select?: RetrospectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Retrospective
     */
    omit?: RetrospectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetrospectiveInclude<ExtArgs> | null
    /**
     * The data needed to update a Retrospective.
     */
    data: XOR<RetrospectiveUpdateInput, RetrospectiveUncheckedUpdateInput>
    /**
     * Choose, which Retrospective to update.
     */
    where: RetrospectiveWhereUniqueInput
  }

  /**
   * Retrospective updateMany
   */
  export type RetrospectiveUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Retrospectives.
     */
    data: XOR<RetrospectiveUpdateManyMutationInput, RetrospectiveUncheckedUpdateManyInput>
    /**
     * Filter which Retrospectives to update
     */
    where?: RetrospectiveWhereInput
    /**
     * Limit how many Retrospectives to update.
     */
    limit?: number
  }

  /**
   * Retrospective updateManyAndReturn
   */
  export type RetrospectiveUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Retrospective
     */
    select?: RetrospectiveSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Retrospective
     */
    omit?: RetrospectiveOmit<ExtArgs> | null
    /**
     * The data used to update Retrospectives.
     */
    data: XOR<RetrospectiveUpdateManyMutationInput, RetrospectiveUncheckedUpdateManyInput>
    /**
     * Filter which Retrospectives to update
     */
    where?: RetrospectiveWhereInput
    /**
     * Limit how many Retrospectives to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetrospectiveIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Retrospective upsert
   */
  export type RetrospectiveUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Retrospective
     */
    select?: RetrospectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Retrospective
     */
    omit?: RetrospectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetrospectiveInclude<ExtArgs> | null
    /**
     * The filter to search for the Retrospective to update in case it exists.
     */
    where: RetrospectiveWhereUniqueInput
    /**
     * In case the Retrospective found by the `where` argument doesn't exist, create a new Retrospective with this data.
     */
    create: XOR<RetrospectiveCreateInput, RetrospectiveUncheckedCreateInput>
    /**
     * In case the Retrospective was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RetrospectiveUpdateInput, RetrospectiveUncheckedUpdateInput>
  }

  /**
   * Retrospective delete
   */
  export type RetrospectiveDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Retrospective
     */
    select?: RetrospectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Retrospective
     */
    omit?: RetrospectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetrospectiveInclude<ExtArgs> | null
    /**
     * Filter which Retrospective to delete.
     */
    where: RetrospectiveWhereUniqueInput
  }

  /**
   * Retrospective deleteMany
   */
  export type RetrospectiveDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Retrospectives to delete
     */
    where?: RetrospectiveWhereInput
    /**
     * Limit how many Retrospectives to delete.
     */
    limit?: number
  }

  /**
   * Retrospective without action
   */
  export type RetrospectiveDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Retrospective
     */
    select?: RetrospectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Retrospective
     */
    omit?: RetrospectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RetrospectiveInclude<ExtArgs> | null
  }


  /**
   * Model WorkItem
   */

  export type AggregateWorkItem = {
    _count: WorkItemCountAggregateOutputType | null
    _avg: WorkItemAvgAggregateOutputType | null
    _sum: WorkItemSumAggregateOutputType | null
    _min: WorkItemMinAggregateOutputType | null
    _max: WorkItemMaxAggregateOutputType | null
  }

  export type WorkItemAvgAggregateOutputType = {
    storyPoints: number | null
    estimatedHours: number | null
    remainingHours: number | null
    order: number | null
  }

  export type WorkItemSumAggregateOutputType = {
    storyPoints: number | null
    estimatedHours: number | null
    remainingHours: number | null
    order: number | null
  }

  export type WorkItemMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    type: $Enums.WorkItemType | null
    priority: $Enums.Priority | null
    storyPoints: number | null
    estimatedHours: number | null
    remainingHours: number | null
    order: number | null
    dueDate: Date | null
    completedAt: Date | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    parentId: string | null
    epicId: string | null
    projectId: string | null
    stateId: string | null
    assigneeId: string | null
    creatorId: string | null
    sprintId: string | null
  }

  export type WorkItemMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    type: $Enums.WorkItemType | null
    priority: $Enums.Priority | null
    storyPoints: number | null
    estimatedHours: number | null
    remainingHours: number | null
    order: number | null
    dueDate: Date | null
    completedAt: Date | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    parentId: string | null
    epicId: string | null
    projectId: string | null
    stateId: string | null
    assigneeId: string | null
    creatorId: string | null
    sprintId: string | null
  }

  export type WorkItemCountAggregateOutputType = {
    id: number
    title: number
    description: number
    type: number
    priority: number
    storyPoints: number
    estimatedHours: number
    remainingHours: number
    order: number
    dueDate: number
    completedAt: number
    deletedAt: number
    createdAt: number
    updatedAt: number
    parentId: number
    epicId: number
    projectId: number
    stateId: number
    assigneeId: number
    creatorId: number
    sprintId: number
    _all: number
  }


  export type WorkItemAvgAggregateInputType = {
    storyPoints?: true
    estimatedHours?: true
    remainingHours?: true
    order?: true
  }

  export type WorkItemSumAggregateInputType = {
    storyPoints?: true
    estimatedHours?: true
    remainingHours?: true
    order?: true
  }

  export type WorkItemMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    priority?: true
    storyPoints?: true
    estimatedHours?: true
    remainingHours?: true
    order?: true
    dueDate?: true
    completedAt?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    parentId?: true
    epicId?: true
    projectId?: true
    stateId?: true
    assigneeId?: true
    creatorId?: true
    sprintId?: true
  }

  export type WorkItemMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    priority?: true
    storyPoints?: true
    estimatedHours?: true
    remainingHours?: true
    order?: true
    dueDate?: true
    completedAt?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    parentId?: true
    epicId?: true
    projectId?: true
    stateId?: true
    assigneeId?: true
    creatorId?: true
    sprintId?: true
  }

  export type WorkItemCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    priority?: true
    storyPoints?: true
    estimatedHours?: true
    remainingHours?: true
    order?: true
    dueDate?: true
    completedAt?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    parentId?: true
    epicId?: true
    projectId?: true
    stateId?: true
    assigneeId?: true
    creatorId?: true
    sprintId?: true
    _all?: true
  }

  export type WorkItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkItem to aggregate.
     */
    where?: WorkItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkItems to fetch.
     */
    orderBy?: WorkItemOrderByWithRelationInput | WorkItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkItems
    **/
    _count?: true | WorkItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkItemMaxAggregateInputType
  }

  export type GetWorkItemAggregateType<T extends WorkItemAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkItem[P]>
      : GetScalarType<T[P], AggregateWorkItem[P]>
  }




  export type WorkItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkItemWhereInput
    orderBy?: WorkItemOrderByWithAggregationInput | WorkItemOrderByWithAggregationInput[]
    by: WorkItemScalarFieldEnum[] | WorkItemScalarFieldEnum
    having?: WorkItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkItemCountAggregateInputType | true
    _avg?: WorkItemAvgAggregateInputType
    _sum?: WorkItemSumAggregateInputType
    _min?: WorkItemMinAggregateInputType
    _max?: WorkItemMaxAggregateInputType
  }

  export type WorkItemGroupByOutputType = {
    id: string
    title: string
    description: string | null
    type: $Enums.WorkItemType
    priority: $Enums.Priority
    storyPoints: number | null
    estimatedHours: number | null
    remainingHours: number | null
    order: number
    dueDate: Date | null
    completedAt: Date | null
    deletedAt: Date | null
    createdAt: Date
    updatedAt: Date
    parentId: string | null
    epicId: string | null
    projectId: string
    stateId: string | null
    assigneeId: string | null
    creatorId: string
    sprintId: string | null
    _count: WorkItemCountAggregateOutputType | null
    _avg: WorkItemAvgAggregateOutputType | null
    _sum: WorkItemSumAggregateOutputType | null
    _min: WorkItemMinAggregateOutputType | null
    _max: WorkItemMaxAggregateOutputType | null
  }

  type GetWorkItemGroupByPayload<T extends WorkItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkItemGroupByOutputType[P]>
            : GetScalarType<T[P], WorkItemGroupByOutputType[P]>
        }
      >
    >


  export type WorkItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    priority?: boolean
    storyPoints?: boolean
    estimatedHours?: boolean
    remainingHours?: boolean
    order?: boolean
    dueDate?: boolean
    completedAt?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parentId?: boolean
    epicId?: boolean
    projectId?: boolean
    stateId?: boolean
    assigneeId?: boolean
    creatorId?: boolean
    sprintId?: boolean
    parent?: boolean | WorkItem$parentArgs<ExtArgs>
    children?: boolean | WorkItem$childrenArgs<ExtArgs>
    epic?: boolean | WorkItem$epicArgs<ExtArgs>
    stories?: boolean | WorkItem$storiesArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    state?: boolean | WorkItem$stateArgs<ExtArgs>
    assignee?: boolean | WorkItem$assigneeArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    sprint?: boolean | WorkItem$sprintArgs<ExtArgs>
    details?: boolean | WorkItem$detailsArgs<ExtArgs>
    dependenciesAsSource?: boolean | WorkItem$dependenciesAsSourceArgs<ExtArgs>
    dependenciesAsTarget?: boolean | WorkItem$dependenciesAsTargetArgs<ExtArgs>
    comments?: boolean | WorkItem$commentsArgs<ExtArgs>
    attachments?: boolean | WorkItem$attachmentsArgs<ExtArgs>
    timeLogs?: boolean | WorkItem$timeLogsArgs<ExtArgs>
    snapshots?: boolean | WorkItem$snapshotsArgs<ExtArgs>
    tags?: boolean | WorkItem$tagsArgs<ExtArgs>
    components?: boolean | WorkItem$componentsArgs<ExtArgs>
    embedding?: boolean | WorkItem$embeddingArgs<ExtArgs>
    _count?: boolean | WorkItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workItem"]>

  export type WorkItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    priority?: boolean
    storyPoints?: boolean
    estimatedHours?: boolean
    remainingHours?: boolean
    order?: boolean
    dueDate?: boolean
    completedAt?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parentId?: boolean
    epicId?: boolean
    projectId?: boolean
    stateId?: boolean
    assigneeId?: boolean
    creatorId?: boolean
    sprintId?: boolean
    parent?: boolean | WorkItem$parentArgs<ExtArgs>
    epic?: boolean | WorkItem$epicArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    state?: boolean | WorkItem$stateArgs<ExtArgs>
    assignee?: boolean | WorkItem$assigneeArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    sprint?: boolean | WorkItem$sprintArgs<ExtArgs>
  }, ExtArgs["result"]["workItem"]>

  export type WorkItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    priority?: boolean
    storyPoints?: boolean
    estimatedHours?: boolean
    remainingHours?: boolean
    order?: boolean
    dueDate?: boolean
    completedAt?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parentId?: boolean
    epicId?: boolean
    projectId?: boolean
    stateId?: boolean
    assigneeId?: boolean
    creatorId?: boolean
    sprintId?: boolean
    parent?: boolean | WorkItem$parentArgs<ExtArgs>
    epic?: boolean | WorkItem$epicArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    state?: boolean | WorkItem$stateArgs<ExtArgs>
    assignee?: boolean | WorkItem$assigneeArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    sprint?: boolean | WorkItem$sprintArgs<ExtArgs>
  }, ExtArgs["result"]["workItem"]>

  export type WorkItemSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    priority?: boolean
    storyPoints?: boolean
    estimatedHours?: boolean
    remainingHours?: boolean
    order?: boolean
    dueDate?: boolean
    completedAt?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parentId?: boolean
    epicId?: boolean
    projectId?: boolean
    stateId?: boolean
    assigneeId?: boolean
    creatorId?: boolean
    sprintId?: boolean
  }

  export type WorkItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "type" | "priority" | "storyPoints" | "estimatedHours" | "remainingHours" | "order" | "dueDate" | "completedAt" | "deletedAt" | "createdAt" | "updatedAt" | "parentId" | "epicId" | "projectId" | "stateId" | "assigneeId" | "creatorId" | "sprintId", ExtArgs["result"]["workItem"]>
  export type WorkItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | WorkItem$parentArgs<ExtArgs>
    children?: boolean | WorkItem$childrenArgs<ExtArgs>
    epic?: boolean | WorkItem$epicArgs<ExtArgs>
    stories?: boolean | WorkItem$storiesArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    state?: boolean | WorkItem$stateArgs<ExtArgs>
    assignee?: boolean | WorkItem$assigneeArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    sprint?: boolean | WorkItem$sprintArgs<ExtArgs>
    details?: boolean | WorkItem$detailsArgs<ExtArgs>
    dependenciesAsSource?: boolean | WorkItem$dependenciesAsSourceArgs<ExtArgs>
    dependenciesAsTarget?: boolean | WorkItem$dependenciesAsTargetArgs<ExtArgs>
    comments?: boolean | WorkItem$commentsArgs<ExtArgs>
    attachments?: boolean | WorkItem$attachmentsArgs<ExtArgs>
    timeLogs?: boolean | WorkItem$timeLogsArgs<ExtArgs>
    snapshots?: boolean | WorkItem$snapshotsArgs<ExtArgs>
    tags?: boolean | WorkItem$tagsArgs<ExtArgs>
    components?: boolean | WorkItem$componentsArgs<ExtArgs>
    embedding?: boolean | WorkItem$embeddingArgs<ExtArgs>
    _count?: boolean | WorkItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | WorkItem$parentArgs<ExtArgs>
    epic?: boolean | WorkItem$epicArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    state?: boolean | WorkItem$stateArgs<ExtArgs>
    assignee?: boolean | WorkItem$assigneeArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    sprint?: boolean | WorkItem$sprintArgs<ExtArgs>
  }
  export type WorkItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | WorkItem$parentArgs<ExtArgs>
    epic?: boolean | WorkItem$epicArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    state?: boolean | WorkItem$stateArgs<ExtArgs>
    assignee?: boolean | WorkItem$assigneeArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    sprint?: boolean | WorkItem$sprintArgs<ExtArgs>
  }

  export type $WorkItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkItem"
    objects: {
      parent: Prisma.$WorkItemPayload<ExtArgs> | null
      children: Prisma.$WorkItemPayload<ExtArgs>[]
      epic: Prisma.$WorkItemPayload<ExtArgs> | null
      stories: Prisma.$WorkItemPayload<ExtArgs>[]
      project: Prisma.$ProjectPayload<ExtArgs>
      state: Prisma.$WorkItemStatePayload<ExtArgs> | null
      assignee: Prisma.$UserPayload<ExtArgs> | null
      creator: Prisma.$UserPayload<ExtArgs>
      sprint: Prisma.$SprintPayload<ExtArgs> | null
      details: Prisma.$WorkItemDetailPayload<ExtArgs> | null
      dependenciesAsSource: Prisma.$DependencyPayload<ExtArgs>[]
      dependenciesAsTarget: Prisma.$DependencyPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      attachments: Prisma.$AttachmentPayload<ExtArgs>[]
      timeLogs: Prisma.$TimeLogPayload<ExtArgs>[]
      snapshots: Prisma.$WorkItemSnapshotPayload<ExtArgs>[]
      tags: Prisma.$TagOnWorkItemPayload<ExtArgs>[]
      components: Prisma.$ComponentOnWorkItemPayload<ExtArgs>[]
      embedding: Prisma.$WorkItemEmbeddingPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      type: $Enums.WorkItemType
      priority: $Enums.Priority
      storyPoints: number | null
      estimatedHours: number | null
      remainingHours: number | null
      order: number
      dueDate: Date | null
      completedAt: Date | null
      deletedAt: Date | null
      createdAt: Date
      updatedAt: Date
      parentId: string | null
      epicId: string | null
      projectId: string
      stateId: string | null
      assigneeId: string | null
      creatorId: string
      sprintId: string | null
    }, ExtArgs["result"]["workItem"]>
    composites: {}
  }

  type WorkItemGetPayload<S extends boolean | null | undefined | WorkItemDefaultArgs> = $Result.GetResult<Prisma.$WorkItemPayload, S>

  type WorkItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkItemCountAggregateInputType | true
    }

  export interface WorkItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkItem'], meta: { name: 'WorkItem' } }
    /**
     * Find zero or one WorkItem that matches the filter.
     * @param {WorkItemFindUniqueArgs} args - Arguments to find a WorkItem
     * @example
     * // Get one WorkItem
     * const workItem = await prisma.workItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkItemFindUniqueArgs>(args: SelectSubset<T, WorkItemFindUniqueArgs<ExtArgs>>): Prisma__WorkItemClient<$Result.GetResult<Prisma.$WorkItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkItemFindUniqueOrThrowArgs} args - Arguments to find a WorkItem
     * @example
     * // Get one WorkItem
     * const workItem = await prisma.workItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkItemFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkItemClient<$Result.GetResult<Prisma.$WorkItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkItemFindFirstArgs} args - Arguments to find a WorkItem
     * @example
     * // Get one WorkItem
     * const workItem = await prisma.workItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkItemFindFirstArgs>(args?: SelectSubset<T, WorkItemFindFirstArgs<ExtArgs>>): Prisma__WorkItemClient<$Result.GetResult<Prisma.$WorkItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkItemFindFirstOrThrowArgs} args - Arguments to find a WorkItem
     * @example
     * // Get one WorkItem
     * const workItem = await prisma.workItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkItemFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkItemClient<$Result.GetResult<Prisma.$WorkItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkItems
     * const workItems = await prisma.workItem.findMany()
     * 
     * // Get first 10 WorkItems
     * const workItems = await prisma.workItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workItemWithIdOnly = await prisma.workItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkItemFindManyArgs>(args?: SelectSubset<T, WorkItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkItem.
     * @param {WorkItemCreateArgs} args - Arguments to create a WorkItem.
     * @example
     * // Create one WorkItem
     * const WorkItem = await prisma.workItem.create({
     *   data: {
     *     // ... data to create a WorkItem
     *   }
     * })
     * 
     */
    create<T extends WorkItemCreateArgs>(args: SelectSubset<T, WorkItemCreateArgs<ExtArgs>>): Prisma__WorkItemClient<$Result.GetResult<Prisma.$WorkItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkItems.
     * @param {WorkItemCreateManyArgs} args - Arguments to create many WorkItems.
     * @example
     * // Create many WorkItems
     * const workItem = await prisma.workItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkItemCreateManyArgs>(args?: SelectSubset<T, WorkItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkItems and returns the data saved in the database.
     * @param {WorkItemCreateManyAndReturnArgs} args - Arguments to create many WorkItems.
     * @example
     * // Create many WorkItems
     * const workItem = await prisma.workItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkItems and only return the `id`
     * const workItemWithIdOnly = await prisma.workItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkItemCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkItem.
     * @param {WorkItemDeleteArgs} args - Arguments to delete one WorkItem.
     * @example
     * // Delete one WorkItem
     * const WorkItem = await prisma.workItem.delete({
     *   where: {
     *     // ... filter to delete one WorkItem
     *   }
     * })
     * 
     */
    delete<T extends WorkItemDeleteArgs>(args: SelectSubset<T, WorkItemDeleteArgs<ExtArgs>>): Prisma__WorkItemClient<$Result.GetResult<Prisma.$WorkItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkItem.
     * @param {WorkItemUpdateArgs} args - Arguments to update one WorkItem.
     * @example
     * // Update one WorkItem
     * const workItem = await prisma.workItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkItemUpdateArgs>(args: SelectSubset<T, WorkItemUpdateArgs<ExtArgs>>): Prisma__WorkItemClient<$Result.GetResult<Prisma.$WorkItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkItems.
     * @param {WorkItemDeleteManyArgs} args - Arguments to filter WorkItems to delete.
     * @example
     * // Delete a few WorkItems
     * const { count } = await prisma.workItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkItemDeleteManyArgs>(args?: SelectSubset<T, WorkItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkItems
     * const workItem = await prisma.workItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkItemUpdateManyArgs>(args: SelectSubset<T, WorkItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkItems and returns the data updated in the database.
     * @param {WorkItemUpdateManyAndReturnArgs} args - Arguments to update many WorkItems.
     * @example
     * // Update many WorkItems
     * const workItem = await prisma.workItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkItems and only return the `id`
     * const workItemWithIdOnly = await prisma.workItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkItemUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkItem.
     * @param {WorkItemUpsertArgs} args - Arguments to update or create a WorkItem.
     * @example
     * // Update or create a WorkItem
     * const workItem = await prisma.workItem.upsert({
     *   create: {
     *     // ... data to create a WorkItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkItem we want to update
     *   }
     * })
     */
    upsert<T extends WorkItemUpsertArgs>(args: SelectSubset<T, WorkItemUpsertArgs<ExtArgs>>): Prisma__WorkItemClient<$Result.GetResult<Prisma.$WorkItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkItemCountArgs} args - Arguments to filter WorkItems to count.
     * @example
     * // Count the number of WorkItems
     * const count = await prisma.workItem.count({
     *   where: {
     *     // ... the filter for the WorkItems we want to count
     *   }
     * })
    **/
    count<T extends WorkItemCountArgs>(
      args?: Subset<T, WorkItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkItemAggregateArgs>(args: Subset<T, WorkItemAggregateArgs>): Prisma.PrismaPromise<GetWorkItemAggregateType<T>>

    /**
     * Group by WorkItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkItemGroupByArgs['orderBy'] }
        : { orderBy?: WorkItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkItem model
   */
  readonly fields: WorkItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends WorkItem$parentArgs<ExtArgs> = {}>(args?: Subset<T, WorkItem$parentArgs<ExtArgs>>): Prisma__WorkItemClient<$Result.GetResult<Prisma.$WorkItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends WorkItem$childrenArgs<ExtArgs> = {}>(args?: Subset<T, WorkItem$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    epic<T extends WorkItem$epicArgs<ExtArgs> = {}>(args?: Subset<T, WorkItem$epicArgs<ExtArgs>>): Prisma__WorkItemClient<$Result.GetResult<Prisma.$WorkItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    stories<T extends WorkItem$storiesArgs<ExtArgs> = {}>(args?: Subset<T, WorkItem$storiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    state<T extends WorkItem$stateArgs<ExtArgs> = {}>(args?: Subset<T, WorkItem$stateArgs<ExtArgs>>): Prisma__WorkItemStateClient<$Result.GetResult<Prisma.$WorkItemStatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    assignee<T extends WorkItem$assigneeArgs<ExtArgs> = {}>(args?: Subset<T, WorkItem$assigneeArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sprint<T extends WorkItem$sprintArgs<ExtArgs> = {}>(args?: Subset<T, WorkItem$sprintArgs<ExtArgs>>): Prisma__SprintClient<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    details<T extends WorkItem$detailsArgs<ExtArgs> = {}>(args?: Subset<T, WorkItem$detailsArgs<ExtArgs>>): Prisma__WorkItemDetailClient<$Result.GetResult<Prisma.$WorkItemDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    dependenciesAsSource<T extends WorkItem$dependenciesAsSourceArgs<ExtArgs> = {}>(args?: Subset<T, WorkItem$dependenciesAsSourceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DependencyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dependenciesAsTarget<T extends WorkItem$dependenciesAsTargetArgs<ExtArgs> = {}>(args?: Subset<T, WorkItem$dependenciesAsTargetArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DependencyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends WorkItem$commentsArgs<ExtArgs> = {}>(args?: Subset<T, WorkItem$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attachments<T extends WorkItem$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, WorkItem$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    timeLogs<T extends WorkItem$timeLogsArgs<ExtArgs> = {}>(args?: Subset<T, WorkItem$timeLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    snapshots<T extends WorkItem$snapshotsArgs<ExtArgs> = {}>(args?: Subset<T, WorkItem$snapshotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkItemSnapshotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags<T extends WorkItem$tagsArgs<ExtArgs> = {}>(args?: Subset<T, WorkItem$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagOnWorkItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    components<T extends WorkItem$componentsArgs<ExtArgs> = {}>(args?: Subset<T, WorkItem$componentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComponentOnWorkItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    embedding<T extends WorkItem$embeddingArgs<ExtArgs> = {}>(args?: Subset<T, WorkItem$embeddingArgs<ExtArgs>>): Prisma__WorkItemEmbeddingClient<$Result.GetResult<Prisma.$WorkItemEmbeddingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkItem model
   */
  interface WorkItemFieldRefs {
    readonly id: FieldRef<"WorkItem", 'String'>
    readonly title: FieldRef<"WorkItem", 'String'>
    readonly description: FieldRef<"WorkItem", 'String'>
    readonly type: FieldRef<"WorkItem", 'WorkItemType'>
    readonly priority: FieldRef<"WorkItem", 'Priority'>
    readonly storyPoints: FieldRef<"WorkItem", 'Float'>
    readonly estimatedHours: FieldRef<"WorkItem", 'Float'>
    readonly remainingHours: FieldRef<"WorkItem", 'Float'>
    readonly order: FieldRef<"WorkItem", 'Int'>
    readonly dueDate: FieldRef<"WorkItem", 'DateTime'>
    readonly completedAt: FieldRef<"WorkItem", 'DateTime'>
    readonly deletedAt: FieldRef<"WorkItem", 'DateTime'>
    readonly createdAt: FieldRef<"WorkItem", 'DateTime'>
    readonly updatedAt: FieldRef<"WorkItem", 'DateTime'>
    readonly parentId: FieldRef<"WorkItem", 'String'>
    readonly epicId: FieldRef<"WorkItem", 'String'>
    readonly projectId: FieldRef<"WorkItem", 'String'>
    readonly stateId: FieldRef<"WorkItem", 'String'>
    readonly assigneeId: FieldRef<"WorkItem", 'String'>
    readonly creatorId: FieldRef<"WorkItem", 'String'>
    readonly sprintId: FieldRef<"WorkItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WorkItem findUnique
   */
  export type WorkItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItem
     */
    select?: WorkItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItem
     */
    omit?: WorkItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemInclude<ExtArgs> | null
    /**
     * Filter, which WorkItem to fetch.
     */
    where: WorkItemWhereUniqueInput
  }

  /**
   * WorkItem findUniqueOrThrow
   */
  export type WorkItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItem
     */
    select?: WorkItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItem
     */
    omit?: WorkItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemInclude<ExtArgs> | null
    /**
     * Filter, which WorkItem to fetch.
     */
    where: WorkItemWhereUniqueInput
  }

  /**
   * WorkItem findFirst
   */
  export type WorkItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItem
     */
    select?: WorkItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItem
     */
    omit?: WorkItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemInclude<ExtArgs> | null
    /**
     * Filter, which WorkItem to fetch.
     */
    where?: WorkItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkItems to fetch.
     */
    orderBy?: WorkItemOrderByWithRelationInput | WorkItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkItems.
     */
    cursor?: WorkItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkItems.
     */
    distinct?: WorkItemScalarFieldEnum | WorkItemScalarFieldEnum[]
  }

  /**
   * WorkItem findFirstOrThrow
   */
  export type WorkItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItem
     */
    select?: WorkItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItem
     */
    omit?: WorkItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemInclude<ExtArgs> | null
    /**
     * Filter, which WorkItem to fetch.
     */
    where?: WorkItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkItems to fetch.
     */
    orderBy?: WorkItemOrderByWithRelationInput | WorkItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkItems.
     */
    cursor?: WorkItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkItems.
     */
    distinct?: WorkItemScalarFieldEnum | WorkItemScalarFieldEnum[]
  }

  /**
   * WorkItem findMany
   */
  export type WorkItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItem
     */
    select?: WorkItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItem
     */
    omit?: WorkItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemInclude<ExtArgs> | null
    /**
     * Filter, which WorkItems to fetch.
     */
    where?: WorkItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkItems to fetch.
     */
    orderBy?: WorkItemOrderByWithRelationInput | WorkItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkItems.
     */
    cursor?: WorkItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkItems.
     */
    skip?: number
    distinct?: WorkItemScalarFieldEnum | WorkItemScalarFieldEnum[]
  }

  /**
   * WorkItem create
   */
  export type WorkItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItem
     */
    select?: WorkItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItem
     */
    omit?: WorkItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkItem.
     */
    data: XOR<WorkItemCreateInput, WorkItemUncheckedCreateInput>
  }

  /**
   * WorkItem createMany
   */
  export type WorkItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkItems.
     */
    data: WorkItemCreateManyInput | WorkItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkItem createManyAndReturn
   */
  export type WorkItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItem
     */
    select?: WorkItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItem
     */
    omit?: WorkItemOmit<ExtArgs> | null
    /**
     * The data used to create many WorkItems.
     */
    data: WorkItemCreateManyInput | WorkItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkItem update
   */
  export type WorkItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItem
     */
    select?: WorkItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItem
     */
    omit?: WorkItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkItem.
     */
    data: XOR<WorkItemUpdateInput, WorkItemUncheckedUpdateInput>
    /**
     * Choose, which WorkItem to update.
     */
    where: WorkItemWhereUniqueInput
  }

  /**
   * WorkItem updateMany
   */
  export type WorkItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkItems.
     */
    data: XOR<WorkItemUpdateManyMutationInput, WorkItemUncheckedUpdateManyInput>
    /**
     * Filter which WorkItems to update
     */
    where?: WorkItemWhereInput
    /**
     * Limit how many WorkItems to update.
     */
    limit?: number
  }

  /**
   * WorkItem updateManyAndReturn
   */
  export type WorkItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItem
     */
    select?: WorkItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItem
     */
    omit?: WorkItemOmit<ExtArgs> | null
    /**
     * The data used to update WorkItems.
     */
    data: XOR<WorkItemUpdateManyMutationInput, WorkItemUncheckedUpdateManyInput>
    /**
     * Filter which WorkItems to update
     */
    where?: WorkItemWhereInput
    /**
     * Limit how many WorkItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkItem upsert
   */
  export type WorkItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItem
     */
    select?: WorkItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItem
     */
    omit?: WorkItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkItem to update in case it exists.
     */
    where: WorkItemWhereUniqueInput
    /**
     * In case the WorkItem found by the `where` argument doesn't exist, create a new WorkItem with this data.
     */
    create: XOR<WorkItemCreateInput, WorkItemUncheckedCreateInput>
    /**
     * In case the WorkItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkItemUpdateInput, WorkItemUncheckedUpdateInput>
  }

  /**
   * WorkItem delete
   */
  export type WorkItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItem
     */
    select?: WorkItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItem
     */
    omit?: WorkItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemInclude<ExtArgs> | null
    /**
     * Filter which WorkItem to delete.
     */
    where: WorkItemWhereUniqueInput
  }

  /**
   * WorkItem deleteMany
   */
  export type WorkItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkItems to delete
     */
    where?: WorkItemWhereInput
    /**
     * Limit how many WorkItems to delete.
     */
    limit?: number
  }

  /**
   * WorkItem.parent
   */
  export type WorkItem$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItem
     */
    select?: WorkItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItem
     */
    omit?: WorkItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemInclude<ExtArgs> | null
    where?: WorkItemWhereInput
  }

  /**
   * WorkItem.children
   */
  export type WorkItem$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItem
     */
    select?: WorkItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItem
     */
    omit?: WorkItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemInclude<ExtArgs> | null
    where?: WorkItemWhereInput
    orderBy?: WorkItemOrderByWithRelationInput | WorkItemOrderByWithRelationInput[]
    cursor?: WorkItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkItemScalarFieldEnum | WorkItemScalarFieldEnum[]
  }

  /**
   * WorkItem.epic
   */
  export type WorkItem$epicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItem
     */
    select?: WorkItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItem
     */
    omit?: WorkItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemInclude<ExtArgs> | null
    where?: WorkItemWhereInput
  }

  /**
   * WorkItem.stories
   */
  export type WorkItem$storiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItem
     */
    select?: WorkItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItem
     */
    omit?: WorkItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemInclude<ExtArgs> | null
    where?: WorkItemWhereInput
    orderBy?: WorkItemOrderByWithRelationInput | WorkItemOrderByWithRelationInput[]
    cursor?: WorkItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkItemScalarFieldEnum | WorkItemScalarFieldEnum[]
  }

  /**
   * WorkItem.state
   */
  export type WorkItem$stateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItemState
     */
    select?: WorkItemStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItemState
     */
    omit?: WorkItemStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemStateInclude<ExtArgs> | null
    where?: WorkItemStateWhereInput
  }

  /**
   * WorkItem.assignee
   */
  export type WorkItem$assigneeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * WorkItem.sprint
   */
  export type WorkItem$sprintArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    where?: SprintWhereInput
  }

  /**
   * WorkItem.details
   */
  export type WorkItem$detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItemDetail
     */
    select?: WorkItemDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItemDetail
     */
    omit?: WorkItemDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemDetailInclude<ExtArgs> | null
    where?: WorkItemDetailWhereInput
  }

  /**
   * WorkItem.dependenciesAsSource
   */
  export type WorkItem$dependenciesAsSourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dependency
     */
    select?: DependencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dependency
     */
    omit?: DependencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependencyInclude<ExtArgs> | null
    where?: DependencyWhereInput
    orderBy?: DependencyOrderByWithRelationInput | DependencyOrderByWithRelationInput[]
    cursor?: DependencyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DependencyScalarFieldEnum | DependencyScalarFieldEnum[]
  }

  /**
   * WorkItem.dependenciesAsTarget
   */
  export type WorkItem$dependenciesAsTargetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dependency
     */
    select?: DependencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dependency
     */
    omit?: DependencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependencyInclude<ExtArgs> | null
    where?: DependencyWhereInput
    orderBy?: DependencyOrderByWithRelationInput | DependencyOrderByWithRelationInput[]
    cursor?: DependencyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DependencyScalarFieldEnum | DependencyScalarFieldEnum[]
  }

  /**
   * WorkItem.comments
   */
  export type WorkItem$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * WorkItem.attachments
   */
  export type WorkItem$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    where?: AttachmentWhereInput
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    cursor?: AttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * WorkItem.timeLogs
   */
  export type WorkItem$timeLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeLog
     */
    select?: TimeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeLog
     */
    omit?: TimeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeLogInclude<ExtArgs> | null
    where?: TimeLogWhereInput
    orderBy?: TimeLogOrderByWithRelationInput | TimeLogOrderByWithRelationInput[]
    cursor?: TimeLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimeLogScalarFieldEnum | TimeLogScalarFieldEnum[]
  }

  /**
   * WorkItem.snapshots
   */
  export type WorkItem$snapshotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItemSnapshot
     */
    select?: WorkItemSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItemSnapshot
     */
    omit?: WorkItemSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemSnapshotInclude<ExtArgs> | null
    where?: WorkItemSnapshotWhereInput
    orderBy?: WorkItemSnapshotOrderByWithRelationInput | WorkItemSnapshotOrderByWithRelationInput[]
    cursor?: WorkItemSnapshotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkItemSnapshotScalarFieldEnum | WorkItemSnapshotScalarFieldEnum[]
  }

  /**
   * WorkItem.tags
   */
  export type WorkItem$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagOnWorkItem
     */
    select?: TagOnWorkItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagOnWorkItem
     */
    omit?: TagOnWorkItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagOnWorkItemInclude<ExtArgs> | null
    where?: TagOnWorkItemWhereInput
    orderBy?: TagOnWorkItemOrderByWithRelationInput | TagOnWorkItemOrderByWithRelationInput[]
    cursor?: TagOnWorkItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagOnWorkItemScalarFieldEnum | TagOnWorkItemScalarFieldEnum[]
  }

  /**
   * WorkItem.components
   */
  export type WorkItem$componentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentOnWorkItem
     */
    select?: ComponentOnWorkItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComponentOnWorkItem
     */
    omit?: ComponentOnWorkItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentOnWorkItemInclude<ExtArgs> | null
    where?: ComponentOnWorkItemWhereInput
    orderBy?: ComponentOnWorkItemOrderByWithRelationInput | ComponentOnWorkItemOrderByWithRelationInput[]
    cursor?: ComponentOnWorkItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComponentOnWorkItemScalarFieldEnum | ComponentOnWorkItemScalarFieldEnum[]
  }

  /**
   * WorkItem.embedding
   */
  export type WorkItem$embeddingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItemEmbedding
     */
    select?: WorkItemEmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItemEmbedding
     */
    omit?: WorkItemEmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemEmbeddingInclude<ExtArgs> | null
    where?: WorkItemEmbeddingWhereInput
  }

  /**
   * WorkItem without action
   */
  export type WorkItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItem
     */
    select?: WorkItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItem
     */
    omit?: WorkItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemInclude<ExtArgs> | null
  }


  /**
   * Model WorkItemDetail
   */

  export type AggregateWorkItemDetail = {
    _count: WorkItemDetailCountAggregateOutputType | null
    _min: WorkItemDetailMinAggregateOutputType | null
    _max: WorkItemDetailMaxAggregateOutputType | null
  }

  export type WorkItemDetailMinAggregateOutputType = {
    id: string | null
    acceptanceCriteria: string | null
    technicalNotes: string | null
    reproSteps: string | null
    businessValue: string | null
    userPersona: string | null
    externalReferences: string | null
    workItemId: string | null
  }

  export type WorkItemDetailMaxAggregateOutputType = {
    id: string | null
    acceptanceCriteria: string | null
    technicalNotes: string | null
    reproSteps: string | null
    businessValue: string | null
    userPersona: string | null
    externalReferences: string | null
    workItemId: string | null
  }

  export type WorkItemDetailCountAggregateOutputType = {
    id: number
    acceptanceCriteria: number
    technicalNotes: number
    reproSteps: number
    businessValue: number
    userPersona: number
    customFields: number
    externalReferences: number
    workItemId: number
    _all: number
  }


  export type WorkItemDetailMinAggregateInputType = {
    id?: true
    acceptanceCriteria?: true
    technicalNotes?: true
    reproSteps?: true
    businessValue?: true
    userPersona?: true
    externalReferences?: true
    workItemId?: true
  }

  export type WorkItemDetailMaxAggregateInputType = {
    id?: true
    acceptanceCriteria?: true
    technicalNotes?: true
    reproSteps?: true
    businessValue?: true
    userPersona?: true
    externalReferences?: true
    workItemId?: true
  }

  export type WorkItemDetailCountAggregateInputType = {
    id?: true
    acceptanceCriteria?: true
    technicalNotes?: true
    reproSteps?: true
    businessValue?: true
    userPersona?: true
    customFields?: true
    externalReferences?: true
    workItemId?: true
    _all?: true
  }

  export type WorkItemDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkItemDetail to aggregate.
     */
    where?: WorkItemDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkItemDetails to fetch.
     */
    orderBy?: WorkItemDetailOrderByWithRelationInput | WorkItemDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkItemDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkItemDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkItemDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkItemDetails
    **/
    _count?: true | WorkItemDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkItemDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkItemDetailMaxAggregateInputType
  }

  export type GetWorkItemDetailAggregateType<T extends WorkItemDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkItemDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkItemDetail[P]>
      : GetScalarType<T[P], AggregateWorkItemDetail[P]>
  }




  export type WorkItemDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkItemDetailWhereInput
    orderBy?: WorkItemDetailOrderByWithAggregationInput | WorkItemDetailOrderByWithAggregationInput[]
    by: WorkItemDetailScalarFieldEnum[] | WorkItemDetailScalarFieldEnum
    having?: WorkItemDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkItemDetailCountAggregateInputType | true
    _min?: WorkItemDetailMinAggregateInputType
    _max?: WorkItemDetailMaxAggregateInputType
  }

  export type WorkItemDetailGroupByOutputType = {
    id: string
    acceptanceCriteria: string | null
    technicalNotes: string | null
    reproSteps: string | null
    businessValue: string | null
    userPersona: string | null
    customFields: JsonValue
    externalReferences: string | null
    workItemId: string
    _count: WorkItemDetailCountAggregateOutputType | null
    _min: WorkItemDetailMinAggregateOutputType | null
    _max: WorkItemDetailMaxAggregateOutputType | null
  }

  type GetWorkItemDetailGroupByPayload<T extends WorkItemDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkItemDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkItemDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkItemDetailGroupByOutputType[P]>
            : GetScalarType<T[P], WorkItemDetailGroupByOutputType[P]>
        }
      >
    >


  export type WorkItemDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    acceptanceCriteria?: boolean
    technicalNotes?: boolean
    reproSteps?: boolean
    businessValue?: boolean
    userPersona?: boolean
    customFields?: boolean
    externalReferences?: boolean
    workItemId?: boolean
    workItem?: boolean | WorkItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workItemDetail"]>

  export type WorkItemDetailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    acceptanceCriteria?: boolean
    technicalNotes?: boolean
    reproSteps?: boolean
    businessValue?: boolean
    userPersona?: boolean
    customFields?: boolean
    externalReferences?: boolean
    workItemId?: boolean
    workItem?: boolean | WorkItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workItemDetail"]>

  export type WorkItemDetailSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    acceptanceCriteria?: boolean
    technicalNotes?: boolean
    reproSteps?: boolean
    businessValue?: boolean
    userPersona?: boolean
    customFields?: boolean
    externalReferences?: boolean
    workItemId?: boolean
    workItem?: boolean | WorkItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workItemDetail"]>

  export type WorkItemDetailSelectScalar = {
    id?: boolean
    acceptanceCriteria?: boolean
    technicalNotes?: boolean
    reproSteps?: boolean
    businessValue?: boolean
    userPersona?: boolean
    customFields?: boolean
    externalReferences?: boolean
    workItemId?: boolean
  }

  export type WorkItemDetailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "acceptanceCriteria" | "technicalNotes" | "reproSteps" | "businessValue" | "userPersona" | "customFields" | "externalReferences" | "workItemId", ExtArgs["result"]["workItemDetail"]>
  export type WorkItemDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workItem?: boolean | WorkItemDefaultArgs<ExtArgs>
  }
  export type WorkItemDetailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workItem?: boolean | WorkItemDefaultArgs<ExtArgs>
  }
  export type WorkItemDetailIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workItem?: boolean | WorkItemDefaultArgs<ExtArgs>
  }

  export type $WorkItemDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkItemDetail"
    objects: {
      workItem: Prisma.$WorkItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      acceptanceCriteria: string | null
      technicalNotes: string | null
      reproSteps: string | null
      businessValue: string | null
      userPersona: string | null
      customFields: Prisma.JsonValue
      externalReferences: string | null
      workItemId: string
    }, ExtArgs["result"]["workItemDetail"]>
    composites: {}
  }

  type WorkItemDetailGetPayload<S extends boolean | null | undefined | WorkItemDetailDefaultArgs> = $Result.GetResult<Prisma.$WorkItemDetailPayload, S>

  type WorkItemDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkItemDetailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkItemDetailCountAggregateInputType | true
    }

  export interface WorkItemDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkItemDetail'], meta: { name: 'WorkItemDetail' } }
    /**
     * Find zero or one WorkItemDetail that matches the filter.
     * @param {WorkItemDetailFindUniqueArgs} args - Arguments to find a WorkItemDetail
     * @example
     * // Get one WorkItemDetail
     * const workItemDetail = await prisma.workItemDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkItemDetailFindUniqueArgs>(args: SelectSubset<T, WorkItemDetailFindUniqueArgs<ExtArgs>>): Prisma__WorkItemDetailClient<$Result.GetResult<Prisma.$WorkItemDetailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkItemDetail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkItemDetailFindUniqueOrThrowArgs} args - Arguments to find a WorkItemDetail
     * @example
     * // Get one WorkItemDetail
     * const workItemDetail = await prisma.workItemDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkItemDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkItemDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkItemDetailClient<$Result.GetResult<Prisma.$WorkItemDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkItemDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkItemDetailFindFirstArgs} args - Arguments to find a WorkItemDetail
     * @example
     * // Get one WorkItemDetail
     * const workItemDetail = await prisma.workItemDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkItemDetailFindFirstArgs>(args?: SelectSubset<T, WorkItemDetailFindFirstArgs<ExtArgs>>): Prisma__WorkItemDetailClient<$Result.GetResult<Prisma.$WorkItemDetailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkItemDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkItemDetailFindFirstOrThrowArgs} args - Arguments to find a WorkItemDetail
     * @example
     * // Get one WorkItemDetail
     * const workItemDetail = await prisma.workItemDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkItemDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkItemDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkItemDetailClient<$Result.GetResult<Prisma.$WorkItemDetailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkItemDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkItemDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkItemDetails
     * const workItemDetails = await prisma.workItemDetail.findMany()
     * 
     * // Get first 10 WorkItemDetails
     * const workItemDetails = await prisma.workItemDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workItemDetailWithIdOnly = await prisma.workItemDetail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkItemDetailFindManyArgs>(args?: SelectSubset<T, WorkItemDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkItemDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkItemDetail.
     * @param {WorkItemDetailCreateArgs} args - Arguments to create a WorkItemDetail.
     * @example
     * // Create one WorkItemDetail
     * const WorkItemDetail = await prisma.workItemDetail.create({
     *   data: {
     *     // ... data to create a WorkItemDetail
     *   }
     * })
     * 
     */
    create<T extends WorkItemDetailCreateArgs>(args: SelectSubset<T, WorkItemDetailCreateArgs<ExtArgs>>): Prisma__WorkItemDetailClient<$Result.GetResult<Prisma.$WorkItemDetailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkItemDetails.
     * @param {WorkItemDetailCreateManyArgs} args - Arguments to create many WorkItemDetails.
     * @example
     * // Create many WorkItemDetails
     * const workItemDetail = await prisma.workItemDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkItemDetailCreateManyArgs>(args?: SelectSubset<T, WorkItemDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkItemDetails and returns the data saved in the database.
     * @param {WorkItemDetailCreateManyAndReturnArgs} args - Arguments to create many WorkItemDetails.
     * @example
     * // Create many WorkItemDetails
     * const workItemDetail = await prisma.workItemDetail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkItemDetails and only return the `id`
     * const workItemDetailWithIdOnly = await prisma.workItemDetail.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkItemDetailCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkItemDetailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkItemDetailPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkItemDetail.
     * @param {WorkItemDetailDeleteArgs} args - Arguments to delete one WorkItemDetail.
     * @example
     * // Delete one WorkItemDetail
     * const WorkItemDetail = await prisma.workItemDetail.delete({
     *   where: {
     *     // ... filter to delete one WorkItemDetail
     *   }
     * })
     * 
     */
    delete<T extends WorkItemDetailDeleteArgs>(args: SelectSubset<T, WorkItemDetailDeleteArgs<ExtArgs>>): Prisma__WorkItemDetailClient<$Result.GetResult<Prisma.$WorkItemDetailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkItemDetail.
     * @param {WorkItemDetailUpdateArgs} args - Arguments to update one WorkItemDetail.
     * @example
     * // Update one WorkItemDetail
     * const workItemDetail = await prisma.workItemDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkItemDetailUpdateArgs>(args: SelectSubset<T, WorkItemDetailUpdateArgs<ExtArgs>>): Prisma__WorkItemDetailClient<$Result.GetResult<Prisma.$WorkItemDetailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkItemDetails.
     * @param {WorkItemDetailDeleteManyArgs} args - Arguments to filter WorkItemDetails to delete.
     * @example
     * // Delete a few WorkItemDetails
     * const { count } = await prisma.workItemDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkItemDetailDeleteManyArgs>(args?: SelectSubset<T, WorkItemDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkItemDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkItemDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkItemDetails
     * const workItemDetail = await prisma.workItemDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkItemDetailUpdateManyArgs>(args: SelectSubset<T, WorkItemDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkItemDetails and returns the data updated in the database.
     * @param {WorkItemDetailUpdateManyAndReturnArgs} args - Arguments to update many WorkItemDetails.
     * @example
     * // Update many WorkItemDetails
     * const workItemDetail = await prisma.workItemDetail.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkItemDetails and only return the `id`
     * const workItemDetailWithIdOnly = await prisma.workItemDetail.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkItemDetailUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkItemDetailUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkItemDetailPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkItemDetail.
     * @param {WorkItemDetailUpsertArgs} args - Arguments to update or create a WorkItemDetail.
     * @example
     * // Update or create a WorkItemDetail
     * const workItemDetail = await prisma.workItemDetail.upsert({
     *   create: {
     *     // ... data to create a WorkItemDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkItemDetail we want to update
     *   }
     * })
     */
    upsert<T extends WorkItemDetailUpsertArgs>(args: SelectSubset<T, WorkItemDetailUpsertArgs<ExtArgs>>): Prisma__WorkItemDetailClient<$Result.GetResult<Prisma.$WorkItemDetailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkItemDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkItemDetailCountArgs} args - Arguments to filter WorkItemDetails to count.
     * @example
     * // Count the number of WorkItemDetails
     * const count = await prisma.workItemDetail.count({
     *   where: {
     *     // ... the filter for the WorkItemDetails we want to count
     *   }
     * })
    **/
    count<T extends WorkItemDetailCountArgs>(
      args?: Subset<T, WorkItemDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkItemDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkItemDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkItemDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkItemDetailAggregateArgs>(args: Subset<T, WorkItemDetailAggregateArgs>): Prisma.PrismaPromise<GetWorkItemDetailAggregateType<T>>

    /**
     * Group by WorkItemDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkItemDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkItemDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkItemDetailGroupByArgs['orderBy'] }
        : { orderBy?: WorkItemDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkItemDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkItemDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkItemDetail model
   */
  readonly fields: WorkItemDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkItemDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkItemDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workItem<T extends WorkItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkItemDefaultArgs<ExtArgs>>): Prisma__WorkItemClient<$Result.GetResult<Prisma.$WorkItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkItemDetail model
   */
  interface WorkItemDetailFieldRefs {
    readonly id: FieldRef<"WorkItemDetail", 'String'>
    readonly acceptanceCriteria: FieldRef<"WorkItemDetail", 'String'>
    readonly technicalNotes: FieldRef<"WorkItemDetail", 'String'>
    readonly reproSteps: FieldRef<"WorkItemDetail", 'String'>
    readonly businessValue: FieldRef<"WorkItemDetail", 'String'>
    readonly userPersona: FieldRef<"WorkItemDetail", 'String'>
    readonly customFields: FieldRef<"WorkItemDetail", 'Json'>
    readonly externalReferences: FieldRef<"WorkItemDetail", 'String'>
    readonly workItemId: FieldRef<"WorkItemDetail", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WorkItemDetail findUnique
   */
  export type WorkItemDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItemDetail
     */
    select?: WorkItemDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItemDetail
     */
    omit?: WorkItemDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemDetailInclude<ExtArgs> | null
    /**
     * Filter, which WorkItemDetail to fetch.
     */
    where: WorkItemDetailWhereUniqueInput
  }

  /**
   * WorkItemDetail findUniqueOrThrow
   */
  export type WorkItemDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItemDetail
     */
    select?: WorkItemDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItemDetail
     */
    omit?: WorkItemDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemDetailInclude<ExtArgs> | null
    /**
     * Filter, which WorkItemDetail to fetch.
     */
    where: WorkItemDetailWhereUniqueInput
  }

  /**
   * WorkItemDetail findFirst
   */
  export type WorkItemDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItemDetail
     */
    select?: WorkItemDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItemDetail
     */
    omit?: WorkItemDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemDetailInclude<ExtArgs> | null
    /**
     * Filter, which WorkItemDetail to fetch.
     */
    where?: WorkItemDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkItemDetails to fetch.
     */
    orderBy?: WorkItemDetailOrderByWithRelationInput | WorkItemDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkItemDetails.
     */
    cursor?: WorkItemDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkItemDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkItemDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkItemDetails.
     */
    distinct?: WorkItemDetailScalarFieldEnum | WorkItemDetailScalarFieldEnum[]
  }

  /**
   * WorkItemDetail findFirstOrThrow
   */
  export type WorkItemDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItemDetail
     */
    select?: WorkItemDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItemDetail
     */
    omit?: WorkItemDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemDetailInclude<ExtArgs> | null
    /**
     * Filter, which WorkItemDetail to fetch.
     */
    where?: WorkItemDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkItemDetails to fetch.
     */
    orderBy?: WorkItemDetailOrderByWithRelationInput | WorkItemDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkItemDetails.
     */
    cursor?: WorkItemDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkItemDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkItemDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkItemDetails.
     */
    distinct?: WorkItemDetailScalarFieldEnum | WorkItemDetailScalarFieldEnum[]
  }

  /**
   * WorkItemDetail findMany
   */
  export type WorkItemDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItemDetail
     */
    select?: WorkItemDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItemDetail
     */
    omit?: WorkItemDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemDetailInclude<ExtArgs> | null
    /**
     * Filter, which WorkItemDetails to fetch.
     */
    where?: WorkItemDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkItemDetails to fetch.
     */
    orderBy?: WorkItemDetailOrderByWithRelationInput | WorkItemDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkItemDetails.
     */
    cursor?: WorkItemDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkItemDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkItemDetails.
     */
    skip?: number
    distinct?: WorkItemDetailScalarFieldEnum | WorkItemDetailScalarFieldEnum[]
  }

  /**
   * WorkItemDetail create
   */
  export type WorkItemDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItemDetail
     */
    select?: WorkItemDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItemDetail
     */
    omit?: WorkItemDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkItemDetail.
     */
    data: XOR<WorkItemDetailCreateInput, WorkItemDetailUncheckedCreateInput>
  }

  /**
   * WorkItemDetail createMany
   */
  export type WorkItemDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkItemDetails.
     */
    data: WorkItemDetailCreateManyInput | WorkItemDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkItemDetail createManyAndReturn
   */
  export type WorkItemDetailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItemDetail
     */
    select?: WorkItemDetailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItemDetail
     */
    omit?: WorkItemDetailOmit<ExtArgs> | null
    /**
     * The data used to create many WorkItemDetails.
     */
    data: WorkItemDetailCreateManyInput | WorkItemDetailCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemDetailIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkItemDetail update
   */
  export type WorkItemDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItemDetail
     */
    select?: WorkItemDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItemDetail
     */
    omit?: WorkItemDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkItemDetail.
     */
    data: XOR<WorkItemDetailUpdateInput, WorkItemDetailUncheckedUpdateInput>
    /**
     * Choose, which WorkItemDetail to update.
     */
    where: WorkItemDetailWhereUniqueInput
  }

  /**
   * WorkItemDetail updateMany
   */
  export type WorkItemDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkItemDetails.
     */
    data: XOR<WorkItemDetailUpdateManyMutationInput, WorkItemDetailUncheckedUpdateManyInput>
    /**
     * Filter which WorkItemDetails to update
     */
    where?: WorkItemDetailWhereInput
    /**
     * Limit how many WorkItemDetails to update.
     */
    limit?: number
  }

  /**
   * WorkItemDetail updateManyAndReturn
   */
  export type WorkItemDetailUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItemDetail
     */
    select?: WorkItemDetailSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItemDetail
     */
    omit?: WorkItemDetailOmit<ExtArgs> | null
    /**
     * The data used to update WorkItemDetails.
     */
    data: XOR<WorkItemDetailUpdateManyMutationInput, WorkItemDetailUncheckedUpdateManyInput>
    /**
     * Filter which WorkItemDetails to update
     */
    where?: WorkItemDetailWhereInput
    /**
     * Limit how many WorkItemDetails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemDetailIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkItemDetail upsert
   */
  export type WorkItemDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItemDetail
     */
    select?: WorkItemDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItemDetail
     */
    omit?: WorkItemDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkItemDetail to update in case it exists.
     */
    where: WorkItemDetailWhereUniqueInput
    /**
     * In case the WorkItemDetail found by the `where` argument doesn't exist, create a new WorkItemDetail with this data.
     */
    create: XOR<WorkItemDetailCreateInput, WorkItemDetailUncheckedCreateInput>
    /**
     * In case the WorkItemDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkItemDetailUpdateInput, WorkItemDetailUncheckedUpdateInput>
  }

  /**
   * WorkItemDetail delete
   */
  export type WorkItemDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItemDetail
     */
    select?: WorkItemDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItemDetail
     */
    omit?: WorkItemDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemDetailInclude<ExtArgs> | null
    /**
     * Filter which WorkItemDetail to delete.
     */
    where: WorkItemDetailWhereUniqueInput
  }

  /**
   * WorkItemDetail deleteMany
   */
  export type WorkItemDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkItemDetails to delete
     */
    where?: WorkItemDetailWhereInput
    /**
     * Limit how many WorkItemDetails to delete.
     */
    limit?: number
  }

  /**
   * WorkItemDetail without action
   */
  export type WorkItemDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItemDetail
     */
    select?: WorkItemDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItemDetail
     */
    omit?: WorkItemDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemDetailInclude<ExtArgs> | null
  }


  /**
   * Model WorkItemState
   */

  export type AggregateWorkItemState = {
    _count: WorkItemStateCountAggregateOutputType | null
    _avg: WorkItemStateAvgAggregateOutputType | null
    _sum: WorkItemStateSumAggregateOutputType | null
    _min: WorkItemStateMinAggregateOutputType | null
    _max: WorkItemStateMaxAggregateOutputType | null
  }

  export type WorkItemStateAvgAggregateOutputType = {
    position: number | null
    wipLimit: number | null
  }

  export type WorkItemStateSumAggregateOutputType = {
    position: number | null
    wipLimit: number | null
  }

  export type WorkItemStateMinAggregateOutputType = {
    id: string | null
    name: string | null
    category: $Enums.WorkItemStateCategory | null
    position: number | null
    wipLimit: number | null
    color: string | null
    icon: string | null
    isInitial: boolean | null
    isFinal: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
  }

  export type WorkItemStateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    category: $Enums.WorkItemStateCategory | null
    position: number | null
    wipLimit: number | null
    color: string | null
    icon: string | null
    isInitial: boolean | null
    isFinal: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
  }

  export type WorkItemStateCountAggregateOutputType = {
    id: number
    name: number
    category: number
    position: number
    wipLimit: number
    color: number
    icon: number
    isInitial: number
    isFinal: number
    createdAt: number
    updatedAt: number
    projectId: number
    _all: number
  }


  export type WorkItemStateAvgAggregateInputType = {
    position?: true
    wipLimit?: true
  }

  export type WorkItemStateSumAggregateInputType = {
    position?: true
    wipLimit?: true
  }

  export type WorkItemStateMinAggregateInputType = {
    id?: true
    name?: true
    category?: true
    position?: true
    wipLimit?: true
    color?: true
    icon?: true
    isInitial?: true
    isFinal?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type WorkItemStateMaxAggregateInputType = {
    id?: true
    name?: true
    category?: true
    position?: true
    wipLimit?: true
    color?: true
    icon?: true
    isInitial?: true
    isFinal?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type WorkItemStateCountAggregateInputType = {
    id?: true
    name?: true
    category?: true
    position?: true
    wipLimit?: true
    color?: true
    icon?: true
    isInitial?: true
    isFinal?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    _all?: true
  }

  export type WorkItemStateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkItemState to aggregate.
     */
    where?: WorkItemStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkItemStates to fetch.
     */
    orderBy?: WorkItemStateOrderByWithRelationInput | WorkItemStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkItemStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkItemStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkItemStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkItemStates
    **/
    _count?: true | WorkItemStateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkItemStateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkItemStateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkItemStateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkItemStateMaxAggregateInputType
  }

  export type GetWorkItemStateAggregateType<T extends WorkItemStateAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkItemState]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkItemState[P]>
      : GetScalarType<T[P], AggregateWorkItemState[P]>
  }




  export type WorkItemStateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkItemStateWhereInput
    orderBy?: WorkItemStateOrderByWithAggregationInput | WorkItemStateOrderByWithAggregationInput[]
    by: WorkItemStateScalarFieldEnum[] | WorkItemStateScalarFieldEnum
    having?: WorkItemStateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkItemStateCountAggregateInputType | true
    _avg?: WorkItemStateAvgAggregateInputType
    _sum?: WorkItemStateSumAggregateInputType
    _min?: WorkItemStateMinAggregateInputType
    _max?: WorkItemStateMaxAggregateInputType
  }

  export type WorkItemStateGroupByOutputType = {
    id: string
    name: string
    category: $Enums.WorkItemStateCategory
    position: number
    wipLimit: number | null
    color: string
    icon: string | null
    isInitial: boolean
    isFinal: boolean
    createdAt: Date
    updatedAt: Date
    projectId: string
    _count: WorkItemStateCountAggregateOutputType | null
    _avg: WorkItemStateAvgAggregateOutputType | null
    _sum: WorkItemStateSumAggregateOutputType | null
    _min: WorkItemStateMinAggregateOutputType | null
    _max: WorkItemStateMaxAggregateOutputType | null
  }

  type GetWorkItemStateGroupByPayload<T extends WorkItemStateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkItemStateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkItemStateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkItemStateGroupByOutputType[P]>
            : GetScalarType<T[P], WorkItemStateGroupByOutputType[P]>
        }
      >
    >


  export type WorkItemStateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    position?: boolean
    wipLimit?: boolean
    color?: boolean
    icon?: boolean
    isInitial?: boolean
    isFinal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    workItems?: boolean | WorkItemState$workItemsArgs<ExtArgs>
    _count?: boolean | WorkItemStateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workItemState"]>

  export type WorkItemStateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    position?: boolean
    wipLimit?: boolean
    color?: boolean
    icon?: boolean
    isInitial?: boolean
    isFinal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workItemState"]>

  export type WorkItemStateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    position?: boolean
    wipLimit?: boolean
    color?: boolean
    icon?: boolean
    isInitial?: boolean
    isFinal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workItemState"]>

  export type WorkItemStateSelectScalar = {
    id?: boolean
    name?: boolean
    category?: boolean
    position?: boolean
    wipLimit?: boolean
    color?: boolean
    icon?: boolean
    isInitial?: boolean
    isFinal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
  }

  export type WorkItemStateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "category" | "position" | "wipLimit" | "color" | "icon" | "isInitial" | "isFinal" | "createdAt" | "updatedAt" | "projectId", ExtArgs["result"]["workItemState"]>
  export type WorkItemStateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    workItems?: boolean | WorkItemState$workItemsArgs<ExtArgs>
    _count?: boolean | WorkItemStateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkItemStateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type WorkItemStateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $WorkItemStatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkItemState"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      workItems: Prisma.$WorkItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      category: $Enums.WorkItemStateCategory
      position: number
      wipLimit: number | null
      color: string
      icon: string | null
      isInitial: boolean
      isFinal: boolean
      createdAt: Date
      updatedAt: Date
      projectId: string
    }, ExtArgs["result"]["workItemState"]>
    composites: {}
  }

  type WorkItemStateGetPayload<S extends boolean | null | undefined | WorkItemStateDefaultArgs> = $Result.GetResult<Prisma.$WorkItemStatePayload, S>

  type WorkItemStateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkItemStateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkItemStateCountAggregateInputType | true
    }

  export interface WorkItemStateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkItemState'], meta: { name: 'WorkItemState' } }
    /**
     * Find zero or one WorkItemState that matches the filter.
     * @param {WorkItemStateFindUniqueArgs} args - Arguments to find a WorkItemState
     * @example
     * // Get one WorkItemState
     * const workItemState = await prisma.workItemState.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkItemStateFindUniqueArgs>(args: SelectSubset<T, WorkItemStateFindUniqueArgs<ExtArgs>>): Prisma__WorkItemStateClient<$Result.GetResult<Prisma.$WorkItemStatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkItemState that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkItemStateFindUniqueOrThrowArgs} args - Arguments to find a WorkItemState
     * @example
     * // Get one WorkItemState
     * const workItemState = await prisma.workItemState.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkItemStateFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkItemStateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkItemStateClient<$Result.GetResult<Prisma.$WorkItemStatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkItemState that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkItemStateFindFirstArgs} args - Arguments to find a WorkItemState
     * @example
     * // Get one WorkItemState
     * const workItemState = await prisma.workItemState.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkItemStateFindFirstArgs>(args?: SelectSubset<T, WorkItemStateFindFirstArgs<ExtArgs>>): Prisma__WorkItemStateClient<$Result.GetResult<Prisma.$WorkItemStatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkItemState that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkItemStateFindFirstOrThrowArgs} args - Arguments to find a WorkItemState
     * @example
     * // Get one WorkItemState
     * const workItemState = await prisma.workItemState.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkItemStateFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkItemStateFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkItemStateClient<$Result.GetResult<Prisma.$WorkItemStatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkItemStates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkItemStateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkItemStates
     * const workItemStates = await prisma.workItemState.findMany()
     * 
     * // Get first 10 WorkItemStates
     * const workItemStates = await prisma.workItemState.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workItemStateWithIdOnly = await prisma.workItemState.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkItemStateFindManyArgs>(args?: SelectSubset<T, WorkItemStateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkItemStatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkItemState.
     * @param {WorkItemStateCreateArgs} args - Arguments to create a WorkItemState.
     * @example
     * // Create one WorkItemState
     * const WorkItemState = await prisma.workItemState.create({
     *   data: {
     *     // ... data to create a WorkItemState
     *   }
     * })
     * 
     */
    create<T extends WorkItemStateCreateArgs>(args: SelectSubset<T, WorkItemStateCreateArgs<ExtArgs>>): Prisma__WorkItemStateClient<$Result.GetResult<Prisma.$WorkItemStatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkItemStates.
     * @param {WorkItemStateCreateManyArgs} args - Arguments to create many WorkItemStates.
     * @example
     * // Create many WorkItemStates
     * const workItemState = await prisma.workItemState.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkItemStateCreateManyArgs>(args?: SelectSubset<T, WorkItemStateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkItemStates and returns the data saved in the database.
     * @param {WorkItemStateCreateManyAndReturnArgs} args - Arguments to create many WorkItemStates.
     * @example
     * // Create many WorkItemStates
     * const workItemState = await prisma.workItemState.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkItemStates and only return the `id`
     * const workItemStateWithIdOnly = await prisma.workItemState.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkItemStateCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkItemStateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkItemStatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkItemState.
     * @param {WorkItemStateDeleteArgs} args - Arguments to delete one WorkItemState.
     * @example
     * // Delete one WorkItemState
     * const WorkItemState = await prisma.workItemState.delete({
     *   where: {
     *     // ... filter to delete one WorkItemState
     *   }
     * })
     * 
     */
    delete<T extends WorkItemStateDeleteArgs>(args: SelectSubset<T, WorkItemStateDeleteArgs<ExtArgs>>): Prisma__WorkItemStateClient<$Result.GetResult<Prisma.$WorkItemStatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkItemState.
     * @param {WorkItemStateUpdateArgs} args - Arguments to update one WorkItemState.
     * @example
     * // Update one WorkItemState
     * const workItemState = await prisma.workItemState.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkItemStateUpdateArgs>(args: SelectSubset<T, WorkItemStateUpdateArgs<ExtArgs>>): Prisma__WorkItemStateClient<$Result.GetResult<Prisma.$WorkItemStatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkItemStates.
     * @param {WorkItemStateDeleteManyArgs} args - Arguments to filter WorkItemStates to delete.
     * @example
     * // Delete a few WorkItemStates
     * const { count } = await prisma.workItemState.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkItemStateDeleteManyArgs>(args?: SelectSubset<T, WorkItemStateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkItemStates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkItemStateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkItemStates
     * const workItemState = await prisma.workItemState.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkItemStateUpdateManyArgs>(args: SelectSubset<T, WorkItemStateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkItemStates and returns the data updated in the database.
     * @param {WorkItemStateUpdateManyAndReturnArgs} args - Arguments to update many WorkItemStates.
     * @example
     * // Update many WorkItemStates
     * const workItemState = await prisma.workItemState.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkItemStates and only return the `id`
     * const workItemStateWithIdOnly = await prisma.workItemState.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkItemStateUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkItemStateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkItemStatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkItemState.
     * @param {WorkItemStateUpsertArgs} args - Arguments to update or create a WorkItemState.
     * @example
     * // Update or create a WorkItemState
     * const workItemState = await prisma.workItemState.upsert({
     *   create: {
     *     // ... data to create a WorkItemState
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkItemState we want to update
     *   }
     * })
     */
    upsert<T extends WorkItemStateUpsertArgs>(args: SelectSubset<T, WorkItemStateUpsertArgs<ExtArgs>>): Prisma__WorkItemStateClient<$Result.GetResult<Prisma.$WorkItemStatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkItemStates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkItemStateCountArgs} args - Arguments to filter WorkItemStates to count.
     * @example
     * // Count the number of WorkItemStates
     * const count = await prisma.workItemState.count({
     *   where: {
     *     // ... the filter for the WorkItemStates we want to count
     *   }
     * })
    **/
    count<T extends WorkItemStateCountArgs>(
      args?: Subset<T, WorkItemStateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkItemStateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkItemState.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkItemStateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkItemStateAggregateArgs>(args: Subset<T, WorkItemStateAggregateArgs>): Prisma.PrismaPromise<GetWorkItemStateAggregateType<T>>

    /**
     * Group by WorkItemState.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkItemStateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkItemStateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkItemStateGroupByArgs['orderBy'] }
        : { orderBy?: WorkItemStateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkItemStateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkItemStateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkItemState model
   */
  readonly fields: WorkItemStateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkItemState.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkItemStateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    workItems<T extends WorkItemState$workItemsArgs<ExtArgs> = {}>(args?: Subset<T, WorkItemState$workItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkItemState model
   */
  interface WorkItemStateFieldRefs {
    readonly id: FieldRef<"WorkItemState", 'String'>
    readonly name: FieldRef<"WorkItemState", 'String'>
    readonly category: FieldRef<"WorkItemState", 'WorkItemStateCategory'>
    readonly position: FieldRef<"WorkItemState", 'Int'>
    readonly wipLimit: FieldRef<"WorkItemState", 'Int'>
    readonly color: FieldRef<"WorkItemState", 'String'>
    readonly icon: FieldRef<"WorkItemState", 'String'>
    readonly isInitial: FieldRef<"WorkItemState", 'Boolean'>
    readonly isFinal: FieldRef<"WorkItemState", 'Boolean'>
    readonly createdAt: FieldRef<"WorkItemState", 'DateTime'>
    readonly updatedAt: FieldRef<"WorkItemState", 'DateTime'>
    readonly projectId: FieldRef<"WorkItemState", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WorkItemState findUnique
   */
  export type WorkItemStateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItemState
     */
    select?: WorkItemStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItemState
     */
    omit?: WorkItemStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemStateInclude<ExtArgs> | null
    /**
     * Filter, which WorkItemState to fetch.
     */
    where: WorkItemStateWhereUniqueInput
  }

  /**
   * WorkItemState findUniqueOrThrow
   */
  export type WorkItemStateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItemState
     */
    select?: WorkItemStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItemState
     */
    omit?: WorkItemStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemStateInclude<ExtArgs> | null
    /**
     * Filter, which WorkItemState to fetch.
     */
    where: WorkItemStateWhereUniqueInput
  }

  /**
   * WorkItemState findFirst
   */
  export type WorkItemStateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItemState
     */
    select?: WorkItemStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItemState
     */
    omit?: WorkItemStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemStateInclude<ExtArgs> | null
    /**
     * Filter, which WorkItemState to fetch.
     */
    where?: WorkItemStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkItemStates to fetch.
     */
    orderBy?: WorkItemStateOrderByWithRelationInput | WorkItemStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkItemStates.
     */
    cursor?: WorkItemStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkItemStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkItemStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkItemStates.
     */
    distinct?: WorkItemStateScalarFieldEnum | WorkItemStateScalarFieldEnum[]
  }

  /**
   * WorkItemState findFirstOrThrow
   */
  export type WorkItemStateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItemState
     */
    select?: WorkItemStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItemState
     */
    omit?: WorkItemStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemStateInclude<ExtArgs> | null
    /**
     * Filter, which WorkItemState to fetch.
     */
    where?: WorkItemStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkItemStates to fetch.
     */
    orderBy?: WorkItemStateOrderByWithRelationInput | WorkItemStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkItemStates.
     */
    cursor?: WorkItemStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkItemStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkItemStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkItemStates.
     */
    distinct?: WorkItemStateScalarFieldEnum | WorkItemStateScalarFieldEnum[]
  }

  /**
   * WorkItemState findMany
   */
  export type WorkItemStateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItemState
     */
    select?: WorkItemStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItemState
     */
    omit?: WorkItemStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemStateInclude<ExtArgs> | null
    /**
     * Filter, which WorkItemStates to fetch.
     */
    where?: WorkItemStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkItemStates to fetch.
     */
    orderBy?: WorkItemStateOrderByWithRelationInput | WorkItemStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkItemStates.
     */
    cursor?: WorkItemStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkItemStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkItemStates.
     */
    skip?: number
    distinct?: WorkItemStateScalarFieldEnum | WorkItemStateScalarFieldEnum[]
  }

  /**
   * WorkItemState create
   */
  export type WorkItemStateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItemState
     */
    select?: WorkItemStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItemState
     */
    omit?: WorkItemStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemStateInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkItemState.
     */
    data: XOR<WorkItemStateCreateInput, WorkItemStateUncheckedCreateInput>
  }

  /**
   * WorkItemState createMany
   */
  export type WorkItemStateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkItemStates.
     */
    data: WorkItemStateCreateManyInput | WorkItemStateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkItemState createManyAndReturn
   */
  export type WorkItemStateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItemState
     */
    select?: WorkItemStateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItemState
     */
    omit?: WorkItemStateOmit<ExtArgs> | null
    /**
     * The data used to create many WorkItemStates.
     */
    data: WorkItemStateCreateManyInput | WorkItemStateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemStateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkItemState update
   */
  export type WorkItemStateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItemState
     */
    select?: WorkItemStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItemState
     */
    omit?: WorkItemStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemStateInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkItemState.
     */
    data: XOR<WorkItemStateUpdateInput, WorkItemStateUncheckedUpdateInput>
    /**
     * Choose, which WorkItemState to update.
     */
    where: WorkItemStateWhereUniqueInput
  }

  /**
   * WorkItemState updateMany
   */
  export type WorkItemStateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkItemStates.
     */
    data: XOR<WorkItemStateUpdateManyMutationInput, WorkItemStateUncheckedUpdateManyInput>
    /**
     * Filter which WorkItemStates to update
     */
    where?: WorkItemStateWhereInput
    /**
     * Limit how many WorkItemStates to update.
     */
    limit?: number
  }

  /**
   * WorkItemState updateManyAndReturn
   */
  export type WorkItemStateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItemState
     */
    select?: WorkItemStateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItemState
     */
    omit?: WorkItemStateOmit<ExtArgs> | null
    /**
     * The data used to update WorkItemStates.
     */
    data: XOR<WorkItemStateUpdateManyMutationInput, WorkItemStateUncheckedUpdateManyInput>
    /**
     * Filter which WorkItemStates to update
     */
    where?: WorkItemStateWhereInput
    /**
     * Limit how many WorkItemStates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemStateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkItemState upsert
   */
  export type WorkItemStateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItemState
     */
    select?: WorkItemStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItemState
     */
    omit?: WorkItemStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemStateInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkItemState to update in case it exists.
     */
    where: WorkItemStateWhereUniqueInput
    /**
     * In case the WorkItemState found by the `where` argument doesn't exist, create a new WorkItemState with this data.
     */
    create: XOR<WorkItemStateCreateInput, WorkItemStateUncheckedCreateInput>
    /**
     * In case the WorkItemState was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkItemStateUpdateInput, WorkItemStateUncheckedUpdateInput>
  }

  /**
   * WorkItemState delete
   */
  export type WorkItemStateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItemState
     */
    select?: WorkItemStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItemState
     */
    omit?: WorkItemStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemStateInclude<ExtArgs> | null
    /**
     * Filter which WorkItemState to delete.
     */
    where: WorkItemStateWhereUniqueInput
  }

  /**
   * WorkItemState deleteMany
   */
  export type WorkItemStateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkItemStates to delete
     */
    where?: WorkItemStateWhereInput
    /**
     * Limit how many WorkItemStates to delete.
     */
    limit?: number
  }

  /**
   * WorkItemState.workItems
   */
  export type WorkItemState$workItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItem
     */
    select?: WorkItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItem
     */
    omit?: WorkItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemInclude<ExtArgs> | null
    where?: WorkItemWhereInput
    orderBy?: WorkItemOrderByWithRelationInput | WorkItemOrderByWithRelationInput[]
    cursor?: WorkItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkItemScalarFieldEnum | WorkItemScalarFieldEnum[]
  }

  /**
   * WorkItemState without action
   */
  export type WorkItemStateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItemState
     */
    select?: WorkItemStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItemState
     */
    omit?: WorkItemStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemStateInclude<ExtArgs> | null
  }


  /**
   * Model Board
   */

  export type AggregateBoard = {
    _count: BoardCountAggregateOutputType | null
    _min: BoardMinAggregateOutputType | null
    _max: BoardMaxAggregateOutputType | null
  }

  export type BoardMinAggregateOutputType = {
    id: string | null
    name: string | null
    boardType: string | null
    isDefault: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
    sprintId: string | null
  }

  export type BoardMaxAggregateOutputType = {
    id: string | null
    name: string | null
    boardType: string | null
    isDefault: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
    sprintId: string | null
  }

  export type BoardCountAggregateOutputType = {
    id: number
    name: number
    boardType: number
    filterQuery: number
    settings: number
    isDefault: number
    createdAt: number
    updatedAt: number
    projectId: number
    sprintId: number
    _all: number
  }


  export type BoardMinAggregateInputType = {
    id?: true
    name?: true
    boardType?: true
    isDefault?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    sprintId?: true
  }

  export type BoardMaxAggregateInputType = {
    id?: true
    name?: true
    boardType?: true
    isDefault?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    sprintId?: true
  }

  export type BoardCountAggregateInputType = {
    id?: true
    name?: true
    boardType?: true
    filterQuery?: true
    settings?: true
    isDefault?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    sprintId?: true
    _all?: true
  }

  export type BoardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Board to aggregate.
     */
    where?: BoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Boards to fetch.
     */
    orderBy?: BoardOrderByWithRelationInput | BoardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Boards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Boards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Boards
    **/
    _count?: true | BoardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BoardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BoardMaxAggregateInputType
  }

  export type GetBoardAggregateType<T extends BoardAggregateArgs> = {
        [P in keyof T & keyof AggregateBoard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBoard[P]>
      : GetScalarType<T[P], AggregateBoard[P]>
  }




  export type BoardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BoardWhereInput
    orderBy?: BoardOrderByWithAggregationInput | BoardOrderByWithAggregationInput[]
    by: BoardScalarFieldEnum[] | BoardScalarFieldEnum
    having?: BoardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BoardCountAggregateInputType | true
    _min?: BoardMinAggregateInputType
    _max?: BoardMaxAggregateInputType
  }

  export type BoardGroupByOutputType = {
    id: string
    name: string
    boardType: string
    filterQuery: JsonValue
    settings: JsonValue
    isDefault: boolean
    createdAt: Date
    updatedAt: Date
    projectId: string
    sprintId: string | null
    _count: BoardCountAggregateOutputType | null
    _min: BoardMinAggregateOutputType | null
    _max: BoardMaxAggregateOutputType | null
  }

  type GetBoardGroupByPayload<T extends BoardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BoardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BoardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BoardGroupByOutputType[P]>
            : GetScalarType<T[P], BoardGroupByOutputType[P]>
        }
      >
    >


  export type BoardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    boardType?: boolean
    filterQuery?: boolean
    settings?: boolean
    isDefault?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    sprintId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    sprint?: boolean | Board$sprintArgs<ExtArgs>
    lanes?: boolean | Board$lanesArgs<ExtArgs>
    _count?: boolean | BoardCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["board"]>

  export type BoardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    boardType?: boolean
    filterQuery?: boolean
    settings?: boolean
    isDefault?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    sprintId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    sprint?: boolean | Board$sprintArgs<ExtArgs>
  }, ExtArgs["result"]["board"]>

  export type BoardSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    boardType?: boolean
    filterQuery?: boolean
    settings?: boolean
    isDefault?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    sprintId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    sprint?: boolean | Board$sprintArgs<ExtArgs>
  }, ExtArgs["result"]["board"]>

  export type BoardSelectScalar = {
    id?: boolean
    name?: boolean
    boardType?: boolean
    filterQuery?: boolean
    settings?: boolean
    isDefault?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    sprintId?: boolean
  }

  export type BoardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "boardType" | "filterQuery" | "settings" | "isDefault" | "createdAt" | "updatedAt" | "projectId" | "sprintId", ExtArgs["result"]["board"]>
  export type BoardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    sprint?: boolean | Board$sprintArgs<ExtArgs>
    lanes?: boolean | Board$lanesArgs<ExtArgs>
    _count?: boolean | BoardCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BoardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    sprint?: boolean | Board$sprintArgs<ExtArgs>
  }
  export type BoardIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    sprint?: boolean | Board$sprintArgs<ExtArgs>
  }

  export type $BoardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Board"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      sprint: Prisma.$SprintPayload<ExtArgs> | null
      lanes: Prisma.$BoardLanePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      boardType: string
      filterQuery: Prisma.JsonValue
      settings: Prisma.JsonValue
      isDefault: boolean
      createdAt: Date
      updatedAt: Date
      projectId: string
      sprintId: string | null
    }, ExtArgs["result"]["board"]>
    composites: {}
  }

  type BoardGetPayload<S extends boolean | null | undefined | BoardDefaultArgs> = $Result.GetResult<Prisma.$BoardPayload, S>

  type BoardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BoardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BoardCountAggregateInputType | true
    }

  export interface BoardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Board'], meta: { name: 'Board' } }
    /**
     * Find zero or one Board that matches the filter.
     * @param {BoardFindUniqueArgs} args - Arguments to find a Board
     * @example
     * // Get one Board
     * const board = await prisma.board.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BoardFindUniqueArgs>(args: SelectSubset<T, BoardFindUniqueArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Board that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BoardFindUniqueOrThrowArgs} args - Arguments to find a Board
     * @example
     * // Get one Board
     * const board = await prisma.board.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BoardFindUniqueOrThrowArgs>(args: SelectSubset<T, BoardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Board that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardFindFirstArgs} args - Arguments to find a Board
     * @example
     * // Get one Board
     * const board = await prisma.board.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BoardFindFirstArgs>(args?: SelectSubset<T, BoardFindFirstArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Board that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardFindFirstOrThrowArgs} args - Arguments to find a Board
     * @example
     * // Get one Board
     * const board = await prisma.board.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BoardFindFirstOrThrowArgs>(args?: SelectSubset<T, BoardFindFirstOrThrowArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Boards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Boards
     * const boards = await prisma.board.findMany()
     * 
     * // Get first 10 Boards
     * const boards = await prisma.board.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const boardWithIdOnly = await prisma.board.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BoardFindManyArgs>(args?: SelectSubset<T, BoardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Board.
     * @param {BoardCreateArgs} args - Arguments to create a Board.
     * @example
     * // Create one Board
     * const Board = await prisma.board.create({
     *   data: {
     *     // ... data to create a Board
     *   }
     * })
     * 
     */
    create<T extends BoardCreateArgs>(args: SelectSubset<T, BoardCreateArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Boards.
     * @param {BoardCreateManyArgs} args - Arguments to create many Boards.
     * @example
     * // Create many Boards
     * const board = await prisma.board.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BoardCreateManyArgs>(args?: SelectSubset<T, BoardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Boards and returns the data saved in the database.
     * @param {BoardCreateManyAndReturnArgs} args - Arguments to create many Boards.
     * @example
     * // Create many Boards
     * const board = await prisma.board.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Boards and only return the `id`
     * const boardWithIdOnly = await prisma.board.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BoardCreateManyAndReturnArgs>(args?: SelectSubset<T, BoardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Board.
     * @param {BoardDeleteArgs} args - Arguments to delete one Board.
     * @example
     * // Delete one Board
     * const Board = await prisma.board.delete({
     *   where: {
     *     // ... filter to delete one Board
     *   }
     * })
     * 
     */
    delete<T extends BoardDeleteArgs>(args: SelectSubset<T, BoardDeleteArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Board.
     * @param {BoardUpdateArgs} args - Arguments to update one Board.
     * @example
     * // Update one Board
     * const board = await prisma.board.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BoardUpdateArgs>(args: SelectSubset<T, BoardUpdateArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Boards.
     * @param {BoardDeleteManyArgs} args - Arguments to filter Boards to delete.
     * @example
     * // Delete a few Boards
     * const { count } = await prisma.board.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BoardDeleteManyArgs>(args?: SelectSubset<T, BoardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Boards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Boards
     * const board = await prisma.board.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BoardUpdateManyArgs>(args: SelectSubset<T, BoardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Boards and returns the data updated in the database.
     * @param {BoardUpdateManyAndReturnArgs} args - Arguments to update many Boards.
     * @example
     * // Update many Boards
     * const board = await prisma.board.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Boards and only return the `id`
     * const boardWithIdOnly = await prisma.board.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BoardUpdateManyAndReturnArgs>(args: SelectSubset<T, BoardUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Board.
     * @param {BoardUpsertArgs} args - Arguments to update or create a Board.
     * @example
     * // Update or create a Board
     * const board = await prisma.board.upsert({
     *   create: {
     *     // ... data to create a Board
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Board we want to update
     *   }
     * })
     */
    upsert<T extends BoardUpsertArgs>(args: SelectSubset<T, BoardUpsertArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Boards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardCountArgs} args - Arguments to filter Boards to count.
     * @example
     * // Count the number of Boards
     * const count = await prisma.board.count({
     *   where: {
     *     // ... the filter for the Boards we want to count
     *   }
     * })
    **/
    count<T extends BoardCountArgs>(
      args?: Subset<T, BoardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BoardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Board.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BoardAggregateArgs>(args: Subset<T, BoardAggregateArgs>): Prisma.PrismaPromise<GetBoardAggregateType<T>>

    /**
     * Group by Board.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BoardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BoardGroupByArgs['orderBy'] }
        : { orderBy?: BoardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BoardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBoardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Board model
   */
  readonly fields: BoardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Board.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BoardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sprint<T extends Board$sprintArgs<ExtArgs> = {}>(args?: Subset<T, Board$sprintArgs<ExtArgs>>): Prisma__SprintClient<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    lanes<T extends Board$lanesArgs<ExtArgs> = {}>(args?: Subset<T, Board$lanesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoardLanePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Board model
   */
  interface BoardFieldRefs {
    readonly id: FieldRef<"Board", 'String'>
    readonly name: FieldRef<"Board", 'String'>
    readonly boardType: FieldRef<"Board", 'String'>
    readonly filterQuery: FieldRef<"Board", 'Json'>
    readonly settings: FieldRef<"Board", 'Json'>
    readonly isDefault: FieldRef<"Board", 'Boolean'>
    readonly createdAt: FieldRef<"Board", 'DateTime'>
    readonly updatedAt: FieldRef<"Board", 'DateTime'>
    readonly projectId: FieldRef<"Board", 'String'>
    readonly sprintId: FieldRef<"Board", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Board findUnique
   */
  export type BoardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * Filter, which Board to fetch.
     */
    where: BoardWhereUniqueInput
  }

  /**
   * Board findUniqueOrThrow
   */
  export type BoardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * Filter, which Board to fetch.
     */
    where: BoardWhereUniqueInput
  }

  /**
   * Board findFirst
   */
  export type BoardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * Filter, which Board to fetch.
     */
    where?: BoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Boards to fetch.
     */
    orderBy?: BoardOrderByWithRelationInput | BoardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Boards.
     */
    cursor?: BoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Boards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Boards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Boards.
     */
    distinct?: BoardScalarFieldEnum | BoardScalarFieldEnum[]
  }

  /**
   * Board findFirstOrThrow
   */
  export type BoardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * Filter, which Board to fetch.
     */
    where?: BoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Boards to fetch.
     */
    orderBy?: BoardOrderByWithRelationInput | BoardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Boards.
     */
    cursor?: BoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Boards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Boards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Boards.
     */
    distinct?: BoardScalarFieldEnum | BoardScalarFieldEnum[]
  }

  /**
   * Board findMany
   */
  export type BoardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * Filter, which Boards to fetch.
     */
    where?: BoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Boards to fetch.
     */
    orderBy?: BoardOrderByWithRelationInput | BoardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Boards.
     */
    cursor?: BoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Boards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Boards.
     */
    skip?: number
    distinct?: BoardScalarFieldEnum | BoardScalarFieldEnum[]
  }

  /**
   * Board create
   */
  export type BoardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * The data needed to create a Board.
     */
    data: XOR<BoardCreateInput, BoardUncheckedCreateInput>
  }

  /**
   * Board createMany
   */
  export type BoardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Boards.
     */
    data: BoardCreateManyInput | BoardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Board createManyAndReturn
   */
  export type BoardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * The data used to create many Boards.
     */
    data: BoardCreateManyInput | BoardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Board update
   */
  export type BoardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * The data needed to update a Board.
     */
    data: XOR<BoardUpdateInput, BoardUncheckedUpdateInput>
    /**
     * Choose, which Board to update.
     */
    where: BoardWhereUniqueInput
  }

  /**
   * Board updateMany
   */
  export type BoardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Boards.
     */
    data: XOR<BoardUpdateManyMutationInput, BoardUncheckedUpdateManyInput>
    /**
     * Filter which Boards to update
     */
    where?: BoardWhereInput
    /**
     * Limit how many Boards to update.
     */
    limit?: number
  }

  /**
   * Board updateManyAndReturn
   */
  export type BoardUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * The data used to update Boards.
     */
    data: XOR<BoardUpdateManyMutationInput, BoardUncheckedUpdateManyInput>
    /**
     * Filter which Boards to update
     */
    where?: BoardWhereInput
    /**
     * Limit how many Boards to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Board upsert
   */
  export type BoardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * The filter to search for the Board to update in case it exists.
     */
    where: BoardWhereUniqueInput
    /**
     * In case the Board found by the `where` argument doesn't exist, create a new Board with this data.
     */
    create: XOR<BoardCreateInput, BoardUncheckedCreateInput>
    /**
     * In case the Board was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BoardUpdateInput, BoardUncheckedUpdateInput>
  }

  /**
   * Board delete
   */
  export type BoardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * Filter which Board to delete.
     */
    where: BoardWhereUniqueInput
  }

  /**
   * Board deleteMany
   */
  export type BoardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Boards to delete
     */
    where?: BoardWhereInput
    /**
     * Limit how many Boards to delete.
     */
    limit?: number
  }

  /**
   * Board.sprint
   */
  export type Board$sprintArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    where?: SprintWhereInput
  }

  /**
   * Board.lanes
   */
  export type Board$lanesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardLane
     */
    select?: BoardLaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoardLane
     */
    omit?: BoardLaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardLaneInclude<ExtArgs> | null
    where?: BoardLaneWhereInput
    orderBy?: BoardLaneOrderByWithRelationInput | BoardLaneOrderByWithRelationInput[]
    cursor?: BoardLaneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BoardLaneScalarFieldEnum | BoardLaneScalarFieldEnum[]
  }

  /**
   * Board without action
   */
  export type BoardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
  }


  /**
   * Model BoardLane
   */

  export type AggregateBoardLane = {
    _count: BoardLaneCountAggregateOutputType | null
    _avg: BoardLaneAvgAggregateOutputType | null
    _sum: BoardLaneSumAggregateOutputType | null
    _min: BoardLaneMinAggregateOutputType | null
    _max: BoardLaneMaxAggregateOutputType | null
  }

  export type BoardLaneAvgAggregateOutputType = {
    position: number | null
    wipLimit: number | null
  }

  export type BoardLaneSumAggregateOutputType = {
    position: number | null
    wipLimit: number | null
  }

  export type BoardLaneMinAggregateOutputType = {
    id: string | null
    name: string | null
    position: number | null
    wipLimit: number | null
    isCollapsed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    boardId: string | null
  }

  export type BoardLaneMaxAggregateOutputType = {
    id: string | null
    name: string | null
    position: number | null
    wipLimit: number | null
    isCollapsed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    boardId: string | null
  }

  export type BoardLaneCountAggregateOutputType = {
    id: number
    name: number
    position: number
    wipLimit: number
    colorConfig: number
    mappedStates: number
    isCollapsed: number
    createdAt: number
    updatedAt: number
    boardId: number
    _all: number
  }


  export type BoardLaneAvgAggregateInputType = {
    position?: true
    wipLimit?: true
  }

  export type BoardLaneSumAggregateInputType = {
    position?: true
    wipLimit?: true
  }

  export type BoardLaneMinAggregateInputType = {
    id?: true
    name?: true
    position?: true
    wipLimit?: true
    isCollapsed?: true
    createdAt?: true
    updatedAt?: true
    boardId?: true
  }

  export type BoardLaneMaxAggregateInputType = {
    id?: true
    name?: true
    position?: true
    wipLimit?: true
    isCollapsed?: true
    createdAt?: true
    updatedAt?: true
    boardId?: true
  }

  export type BoardLaneCountAggregateInputType = {
    id?: true
    name?: true
    position?: true
    wipLimit?: true
    colorConfig?: true
    mappedStates?: true
    isCollapsed?: true
    createdAt?: true
    updatedAt?: true
    boardId?: true
    _all?: true
  }

  export type BoardLaneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BoardLane to aggregate.
     */
    where?: BoardLaneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoardLanes to fetch.
     */
    orderBy?: BoardLaneOrderByWithRelationInput | BoardLaneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BoardLaneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoardLanes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoardLanes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BoardLanes
    **/
    _count?: true | BoardLaneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BoardLaneAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BoardLaneSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BoardLaneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BoardLaneMaxAggregateInputType
  }

  export type GetBoardLaneAggregateType<T extends BoardLaneAggregateArgs> = {
        [P in keyof T & keyof AggregateBoardLane]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBoardLane[P]>
      : GetScalarType<T[P], AggregateBoardLane[P]>
  }




  export type BoardLaneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BoardLaneWhereInput
    orderBy?: BoardLaneOrderByWithAggregationInput | BoardLaneOrderByWithAggregationInput[]
    by: BoardLaneScalarFieldEnum[] | BoardLaneScalarFieldEnum
    having?: BoardLaneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BoardLaneCountAggregateInputType | true
    _avg?: BoardLaneAvgAggregateInputType
    _sum?: BoardLaneSumAggregateInputType
    _min?: BoardLaneMinAggregateInputType
    _max?: BoardLaneMaxAggregateInputType
  }

  export type BoardLaneGroupByOutputType = {
    id: string
    name: string
    position: number
    wipLimit: number | null
    colorConfig: JsonValue
    mappedStates: string[]
    isCollapsed: boolean
    createdAt: Date
    updatedAt: Date
    boardId: string
    _count: BoardLaneCountAggregateOutputType | null
    _avg: BoardLaneAvgAggregateOutputType | null
    _sum: BoardLaneSumAggregateOutputType | null
    _min: BoardLaneMinAggregateOutputType | null
    _max: BoardLaneMaxAggregateOutputType | null
  }

  type GetBoardLaneGroupByPayload<T extends BoardLaneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BoardLaneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BoardLaneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BoardLaneGroupByOutputType[P]>
            : GetScalarType<T[P], BoardLaneGroupByOutputType[P]>
        }
      >
    >


  export type BoardLaneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    position?: boolean
    wipLimit?: boolean
    colorConfig?: boolean
    mappedStates?: boolean
    isCollapsed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    boardId?: boolean
    board?: boolean | BoardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["boardLane"]>

  export type BoardLaneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    position?: boolean
    wipLimit?: boolean
    colorConfig?: boolean
    mappedStates?: boolean
    isCollapsed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    boardId?: boolean
    board?: boolean | BoardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["boardLane"]>

  export type BoardLaneSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    position?: boolean
    wipLimit?: boolean
    colorConfig?: boolean
    mappedStates?: boolean
    isCollapsed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    boardId?: boolean
    board?: boolean | BoardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["boardLane"]>

  export type BoardLaneSelectScalar = {
    id?: boolean
    name?: boolean
    position?: boolean
    wipLimit?: boolean
    colorConfig?: boolean
    mappedStates?: boolean
    isCollapsed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    boardId?: boolean
  }

  export type BoardLaneOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "position" | "wipLimit" | "colorConfig" | "mappedStates" | "isCollapsed" | "createdAt" | "updatedAt" | "boardId", ExtArgs["result"]["boardLane"]>
  export type BoardLaneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    board?: boolean | BoardDefaultArgs<ExtArgs>
  }
  export type BoardLaneIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    board?: boolean | BoardDefaultArgs<ExtArgs>
  }
  export type BoardLaneIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    board?: boolean | BoardDefaultArgs<ExtArgs>
  }

  export type $BoardLanePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BoardLane"
    objects: {
      board: Prisma.$BoardPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      position: number
      wipLimit: number | null
      colorConfig: Prisma.JsonValue
      mappedStates: string[]
      isCollapsed: boolean
      createdAt: Date
      updatedAt: Date
      boardId: string
    }, ExtArgs["result"]["boardLane"]>
    composites: {}
  }

  type BoardLaneGetPayload<S extends boolean | null | undefined | BoardLaneDefaultArgs> = $Result.GetResult<Prisma.$BoardLanePayload, S>

  type BoardLaneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BoardLaneFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BoardLaneCountAggregateInputType | true
    }

  export interface BoardLaneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BoardLane'], meta: { name: 'BoardLane' } }
    /**
     * Find zero or one BoardLane that matches the filter.
     * @param {BoardLaneFindUniqueArgs} args - Arguments to find a BoardLane
     * @example
     * // Get one BoardLane
     * const boardLane = await prisma.boardLane.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BoardLaneFindUniqueArgs>(args: SelectSubset<T, BoardLaneFindUniqueArgs<ExtArgs>>): Prisma__BoardLaneClient<$Result.GetResult<Prisma.$BoardLanePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BoardLane that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BoardLaneFindUniqueOrThrowArgs} args - Arguments to find a BoardLane
     * @example
     * // Get one BoardLane
     * const boardLane = await prisma.boardLane.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BoardLaneFindUniqueOrThrowArgs>(args: SelectSubset<T, BoardLaneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BoardLaneClient<$Result.GetResult<Prisma.$BoardLanePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BoardLane that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardLaneFindFirstArgs} args - Arguments to find a BoardLane
     * @example
     * // Get one BoardLane
     * const boardLane = await prisma.boardLane.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BoardLaneFindFirstArgs>(args?: SelectSubset<T, BoardLaneFindFirstArgs<ExtArgs>>): Prisma__BoardLaneClient<$Result.GetResult<Prisma.$BoardLanePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BoardLane that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardLaneFindFirstOrThrowArgs} args - Arguments to find a BoardLane
     * @example
     * // Get one BoardLane
     * const boardLane = await prisma.boardLane.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BoardLaneFindFirstOrThrowArgs>(args?: SelectSubset<T, BoardLaneFindFirstOrThrowArgs<ExtArgs>>): Prisma__BoardLaneClient<$Result.GetResult<Prisma.$BoardLanePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BoardLanes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardLaneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BoardLanes
     * const boardLanes = await prisma.boardLane.findMany()
     * 
     * // Get first 10 BoardLanes
     * const boardLanes = await prisma.boardLane.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const boardLaneWithIdOnly = await prisma.boardLane.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BoardLaneFindManyArgs>(args?: SelectSubset<T, BoardLaneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoardLanePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BoardLane.
     * @param {BoardLaneCreateArgs} args - Arguments to create a BoardLane.
     * @example
     * // Create one BoardLane
     * const BoardLane = await prisma.boardLane.create({
     *   data: {
     *     // ... data to create a BoardLane
     *   }
     * })
     * 
     */
    create<T extends BoardLaneCreateArgs>(args: SelectSubset<T, BoardLaneCreateArgs<ExtArgs>>): Prisma__BoardLaneClient<$Result.GetResult<Prisma.$BoardLanePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BoardLanes.
     * @param {BoardLaneCreateManyArgs} args - Arguments to create many BoardLanes.
     * @example
     * // Create many BoardLanes
     * const boardLane = await prisma.boardLane.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BoardLaneCreateManyArgs>(args?: SelectSubset<T, BoardLaneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BoardLanes and returns the data saved in the database.
     * @param {BoardLaneCreateManyAndReturnArgs} args - Arguments to create many BoardLanes.
     * @example
     * // Create many BoardLanes
     * const boardLane = await prisma.boardLane.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BoardLanes and only return the `id`
     * const boardLaneWithIdOnly = await prisma.boardLane.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BoardLaneCreateManyAndReturnArgs>(args?: SelectSubset<T, BoardLaneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoardLanePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BoardLane.
     * @param {BoardLaneDeleteArgs} args - Arguments to delete one BoardLane.
     * @example
     * // Delete one BoardLane
     * const BoardLane = await prisma.boardLane.delete({
     *   where: {
     *     // ... filter to delete one BoardLane
     *   }
     * })
     * 
     */
    delete<T extends BoardLaneDeleteArgs>(args: SelectSubset<T, BoardLaneDeleteArgs<ExtArgs>>): Prisma__BoardLaneClient<$Result.GetResult<Prisma.$BoardLanePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BoardLane.
     * @param {BoardLaneUpdateArgs} args - Arguments to update one BoardLane.
     * @example
     * // Update one BoardLane
     * const boardLane = await prisma.boardLane.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BoardLaneUpdateArgs>(args: SelectSubset<T, BoardLaneUpdateArgs<ExtArgs>>): Prisma__BoardLaneClient<$Result.GetResult<Prisma.$BoardLanePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BoardLanes.
     * @param {BoardLaneDeleteManyArgs} args - Arguments to filter BoardLanes to delete.
     * @example
     * // Delete a few BoardLanes
     * const { count } = await prisma.boardLane.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BoardLaneDeleteManyArgs>(args?: SelectSubset<T, BoardLaneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BoardLanes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardLaneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BoardLanes
     * const boardLane = await prisma.boardLane.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BoardLaneUpdateManyArgs>(args: SelectSubset<T, BoardLaneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BoardLanes and returns the data updated in the database.
     * @param {BoardLaneUpdateManyAndReturnArgs} args - Arguments to update many BoardLanes.
     * @example
     * // Update many BoardLanes
     * const boardLane = await prisma.boardLane.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BoardLanes and only return the `id`
     * const boardLaneWithIdOnly = await prisma.boardLane.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BoardLaneUpdateManyAndReturnArgs>(args: SelectSubset<T, BoardLaneUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoardLanePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BoardLane.
     * @param {BoardLaneUpsertArgs} args - Arguments to update or create a BoardLane.
     * @example
     * // Update or create a BoardLane
     * const boardLane = await prisma.boardLane.upsert({
     *   create: {
     *     // ... data to create a BoardLane
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BoardLane we want to update
     *   }
     * })
     */
    upsert<T extends BoardLaneUpsertArgs>(args: SelectSubset<T, BoardLaneUpsertArgs<ExtArgs>>): Prisma__BoardLaneClient<$Result.GetResult<Prisma.$BoardLanePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BoardLanes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardLaneCountArgs} args - Arguments to filter BoardLanes to count.
     * @example
     * // Count the number of BoardLanes
     * const count = await prisma.boardLane.count({
     *   where: {
     *     // ... the filter for the BoardLanes we want to count
     *   }
     * })
    **/
    count<T extends BoardLaneCountArgs>(
      args?: Subset<T, BoardLaneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BoardLaneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BoardLane.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardLaneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BoardLaneAggregateArgs>(args: Subset<T, BoardLaneAggregateArgs>): Prisma.PrismaPromise<GetBoardLaneAggregateType<T>>

    /**
     * Group by BoardLane.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardLaneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BoardLaneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BoardLaneGroupByArgs['orderBy'] }
        : { orderBy?: BoardLaneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BoardLaneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBoardLaneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BoardLane model
   */
  readonly fields: BoardLaneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BoardLane.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BoardLaneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    board<T extends BoardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BoardDefaultArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BoardLane model
   */
  interface BoardLaneFieldRefs {
    readonly id: FieldRef<"BoardLane", 'String'>
    readonly name: FieldRef<"BoardLane", 'String'>
    readonly position: FieldRef<"BoardLane", 'Int'>
    readonly wipLimit: FieldRef<"BoardLane", 'Int'>
    readonly colorConfig: FieldRef<"BoardLane", 'Json'>
    readonly mappedStates: FieldRef<"BoardLane", 'String[]'>
    readonly isCollapsed: FieldRef<"BoardLane", 'Boolean'>
    readonly createdAt: FieldRef<"BoardLane", 'DateTime'>
    readonly updatedAt: FieldRef<"BoardLane", 'DateTime'>
    readonly boardId: FieldRef<"BoardLane", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BoardLane findUnique
   */
  export type BoardLaneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardLane
     */
    select?: BoardLaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoardLane
     */
    omit?: BoardLaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardLaneInclude<ExtArgs> | null
    /**
     * Filter, which BoardLane to fetch.
     */
    where: BoardLaneWhereUniqueInput
  }

  /**
   * BoardLane findUniqueOrThrow
   */
  export type BoardLaneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardLane
     */
    select?: BoardLaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoardLane
     */
    omit?: BoardLaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardLaneInclude<ExtArgs> | null
    /**
     * Filter, which BoardLane to fetch.
     */
    where: BoardLaneWhereUniqueInput
  }

  /**
   * BoardLane findFirst
   */
  export type BoardLaneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardLane
     */
    select?: BoardLaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoardLane
     */
    omit?: BoardLaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardLaneInclude<ExtArgs> | null
    /**
     * Filter, which BoardLane to fetch.
     */
    where?: BoardLaneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoardLanes to fetch.
     */
    orderBy?: BoardLaneOrderByWithRelationInput | BoardLaneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BoardLanes.
     */
    cursor?: BoardLaneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoardLanes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoardLanes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BoardLanes.
     */
    distinct?: BoardLaneScalarFieldEnum | BoardLaneScalarFieldEnum[]
  }

  /**
   * BoardLane findFirstOrThrow
   */
  export type BoardLaneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardLane
     */
    select?: BoardLaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoardLane
     */
    omit?: BoardLaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardLaneInclude<ExtArgs> | null
    /**
     * Filter, which BoardLane to fetch.
     */
    where?: BoardLaneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoardLanes to fetch.
     */
    orderBy?: BoardLaneOrderByWithRelationInput | BoardLaneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BoardLanes.
     */
    cursor?: BoardLaneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoardLanes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoardLanes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BoardLanes.
     */
    distinct?: BoardLaneScalarFieldEnum | BoardLaneScalarFieldEnum[]
  }

  /**
   * BoardLane findMany
   */
  export type BoardLaneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardLane
     */
    select?: BoardLaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoardLane
     */
    omit?: BoardLaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardLaneInclude<ExtArgs> | null
    /**
     * Filter, which BoardLanes to fetch.
     */
    where?: BoardLaneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoardLanes to fetch.
     */
    orderBy?: BoardLaneOrderByWithRelationInput | BoardLaneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BoardLanes.
     */
    cursor?: BoardLaneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoardLanes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoardLanes.
     */
    skip?: number
    distinct?: BoardLaneScalarFieldEnum | BoardLaneScalarFieldEnum[]
  }

  /**
   * BoardLane create
   */
  export type BoardLaneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardLane
     */
    select?: BoardLaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoardLane
     */
    omit?: BoardLaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardLaneInclude<ExtArgs> | null
    /**
     * The data needed to create a BoardLane.
     */
    data: XOR<BoardLaneCreateInput, BoardLaneUncheckedCreateInput>
  }

  /**
   * BoardLane createMany
   */
  export type BoardLaneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BoardLanes.
     */
    data: BoardLaneCreateManyInput | BoardLaneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BoardLane createManyAndReturn
   */
  export type BoardLaneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardLane
     */
    select?: BoardLaneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BoardLane
     */
    omit?: BoardLaneOmit<ExtArgs> | null
    /**
     * The data used to create many BoardLanes.
     */
    data: BoardLaneCreateManyInput | BoardLaneCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardLaneIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BoardLane update
   */
  export type BoardLaneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardLane
     */
    select?: BoardLaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoardLane
     */
    omit?: BoardLaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardLaneInclude<ExtArgs> | null
    /**
     * The data needed to update a BoardLane.
     */
    data: XOR<BoardLaneUpdateInput, BoardLaneUncheckedUpdateInput>
    /**
     * Choose, which BoardLane to update.
     */
    where: BoardLaneWhereUniqueInput
  }

  /**
   * BoardLane updateMany
   */
  export type BoardLaneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BoardLanes.
     */
    data: XOR<BoardLaneUpdateManyMutationInput, BoardLaneUncheckedUpdateManyInput>
    /**
     * Filter which BoardLanes to update
     */
    where?: BoardLaneWhereInput
    /**
     * Limit how many BoardLanes to update.
     */
    limit?: number
  }

  /**
   * BoardLane updateManyAndReturn
   */
  export type BoardLaneUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardLane
     */
    select?: BoardLaneSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BoardLane
     */
    omit?: BoardLaneOmit<ExtArgs> | null
    /**
     * The data used to update BoardLanes.
     */
    data: XOR<BoardLaneUpdateManyMutationInput, BoardLaneUncheckedUpdateManyInput>
    /**
     * Filter which BoardLanes to update
     */
    where?: BoardLaneWhereInput
    /**
     * Limit how many BoardLanes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardLaneIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BoardLane upsert
   */
  export type BoardLaneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardLane
     */
    select?: BoardLaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoardLane
     */
    omit?: BoardLaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardLaneInclude<ExtArgs> | null
    /**
     * The filter to search for the BoardLane to update in case it exists.
     */
    where: BoardLaneWhereUniqueInput
    /**
     * In case the BoardLane found by the `where` argument doesn't exist, create a new BoardLane with this data.
     */
    create: XOR<BoardLaneCreateInput, BoardLaneUncheckedCreateInput>
    /**
     * In case the BoardLane was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BoardLaneUpdateInput, BoardLaneUncheckedUpdateInput>
  }

  /**
   * BoardLane delete
   */
  export type BoardLaneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardLane
     */
    select?: BoardLaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoardLane
     */
    omit?: BoardLaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardLaneInclude<ExtArgs> | null
    /**
     * Filter which BoardLane to delete.
     */
    where: BoardLaneWhereUniqueInput
  }

  /**
   * BoardLane deleteMany
   */
  export type BoardLaneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BoardLanes to delete
     */
    where?: BoardLaneWhereInput
    /**
     * Limit how many BoardLanes to delete.
     */
    limit?: number
  }

  /**
   * BoardLane without action
   */
  export type BoardLaneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardLane
     */
    select?: BoardLaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BoardLane
     */
    omit?: BoardLaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardLaneInclude<ExtArgs> | null
  }


  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagMinAggregateOutputType = {
    id: string | null
    name: string | null
    color: string | null
    description: string | null
    createdAt: Date | null
  }

  export type TagMaxAggregateOutputType = {
    id: string | null
    name: string | null
    color: string | null
    description: string | null
    createdAt: Date | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    name: number
    color: number
    description: number
    createdAt: number
    _all: number
  }


  export type TagMinAggregateInputType = {
    id?: true
    name?: true
    color?: true
    description?: true
    createdAt?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    name?: true
    color?: true
    description?: true
    createdAt?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    name?: true
    color?: true
    description?: true
    createdAt?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: string
    name: string
    color: string
    description: string | null
    createdAt: Date
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    description?: boolean
    createdAt?: boolean
    workItems?: boolean | Tag$workItemsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    description?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    description?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectScalar = {
    id?: boolean
    name?: boolean
    color?: boolean
    description?: boolean
    createdAt?: boolean
  }

  export type TagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "color" | "description" | "createdAt", ExtArgs["result"]["tag"]>
  export type TagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workItems?: boolean | Tag$workItemsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      workItems: Prisma.$TagOnWorkItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      color: string
      description: string | null
      createdAt: Date
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }

  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagFindUniqueArgs>(args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(args: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagFindFirstArgs>(args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagFindManyArgs>(args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
     */
    create<T extends TagCreateArgs>(args: SelectSubset<T, TagCreateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {TagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagCreateManyArgs>(args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {TagCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagCreateManyAndReturnArgs>(args?: SelectSubset<T, TagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
     */
    delete<T extends TagDeleteArgs>(args: SelectSubset<T, TagDeleteArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagUpdateArgs>(args: SelectSubset<T, TagUpdateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagDeleteManyArgs>(args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagUpdateManyArgs>(args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags and returns the data updated in the database.
     * @param {TagUpdateManyAndReturnArgs} args - Arguments to update many Tags.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TagUpdateManyAndReturnArgs>(args: SelectSubset<T, TagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends TagUpsertArgs>(args: SelectSubset<T, TagUpsertArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workItems<T extends Tag$workItemsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$workItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagOnWorkItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tag model
   */
  interface TagFieldRefs {
    readonly id: FieldRef<"Tag", 'String'>
    readonly name: FieldRef<"Tag", 'String'>
    readonly color: FieldRef<"Tag", 'String'>
    readonly description: FieldRef<"Tag", 'String'>
    readonly createdAt: FieldRef<"Tag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }

  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag createManyAndReturn
   */
  export type TagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag updateManyAndReturn
   */
  export type TagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }

  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to delete.
     */
    limit?: number
  }

  /**
   * Tag.workItems
   */
  export type Tag$workItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagOnWorkItem
     */
    select?: TagOnWorkItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagOnWorkItem
     */
    omit?: TagOnWorkItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagOnWorkItemInclude<ExtArgs> | null
    where?: TagOnWorkItemWhereInput
    orderBy?: TagOnWorkItemOrderByWithRelationInput | TagOnWorkItemOrderByWithRelationInput[]
    cursor?: TagOnWorkItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagOnWorkItemScalarFieldEnum | TagOnWorkItemScalarFieldEnum[]
  }

  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
  }


  /**
   * Model TagOnWorkItem
   */

  export type AggregateTagOnWorkItem = {
    _count: TagOnWorkItemCountAggregateOutputType | null
    _min: TagOnWorkItemMinAggregateOutputType | null
    _max: TagOnWorkItemMaxAggregateOutputType | null
  }

  export type TagOnWorkItemMinAggregateOutputType = {
    workItemId: string | null
    tagId: string | null
  }

  export type TagOnWorkItemMaxAggregateOutputType = {
    workItemId: string | null
    tagId: string | null
  }

  export type TagOnWorkItemCountAggregateOutputType = {
    workItemId: number
    tagId: number
    _all: number
  }


  export type TagOnWorkItemMinAggregateInputType = {
    workItemId?: true
    tagId?: true
  }

  export type TagOnWorkItemMaxAggregateInputType = {
    workItemId?: true
    tagId?: true
  }

  export type TagOnWorkItemCountAggregateInputType = {
    workItemId?: true
    tagId?: true
    _all?: true
  }

  export type TagOnWorkItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TagOnWorkItem to aggregate.
     */
    where?: TagOnWorkItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TagOnWorkItems to fetch.
     */
    orderBy?: TagOnWorkItemOrderByWithRelationInput | TagOnWorkItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagOnWorkItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TagOnWorkItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TagOnWorkItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TagOnWorkItems
    **/
    _count?: true | TagOnWorkItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagOnWorkItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagOnWorkItemMaxAggregateInputType
  }

  export type GetTagOnWorkItemAggregateType<T extends TagOnWorkItemAggregateArgs> = {
        [P in keyof T & keyof AggregateTagOnWorkItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTagOnWorkItem[P]>
      : GetScalarType<T[P], AggregateTagOnWorkItem[P]>
  }




  export type TagOnWorkItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagOnWorkItemWhereInput
    orderBy?: TagOnWorkItemOrderByWithAggregationInput | TagOnWorkItemOrderByWithAggregationInput[]
    by: TagOnWorkItemScalarFieldEnum[] | TagOnWorkItemScalarFieldEnum
    having?: TagOnWorkItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagOnWorkItemCountAggregateInputType | true
    _min?: TagOnWorkItemMinAggregateInputType
    _max?: TagOnWorkItemMaxAggregateInputType
  }

  export type TagOnWorkItemGroupByOutputType = {
    workItemId: string
    tagId: string
    _count: TagOnWorkItemCountAggregateOutputType | null
    _min: TagOnWorkItemMinAggregateOutputType | null
    _max: TagOnWorkItemMaxAggregateOutputType | null
  }

  type GetTagOnWorkItemGroupByPayload<T extends TagOnWorkItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagOnWorkItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagOnWorkItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagOnWorkItemGroupByOutputType[P]>
            : GetScalarType<T[P], TagOnWorkItemGroupByOutputType[P]>
        }
      >
    >


  export type TagOnWorkItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workItemId?: boolean
    tagId?: boolean
    workItem?: boolean | WorkItemDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tagOnWorkItem"]>

  export type TagOnWorkItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workItemId?: boolean
    tagId?: boolean
    workItem?: boolean | WorkItemDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tagOnWorkItem"]>

  export type TagOnWorkItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workItemId?: boolean
    tagId?: boolean
    workItem?: boolean | WorkItemDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tagOnWorkItem"]>

  export type TagOnWorkItemSelectScalar = {
    workItemId?: boolean
    tagId?: boolean
  }

  export type TagOnWorkItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"workItemId" | "tagId", ExtArgs["result"]["tagOnWorkItem"]>
  export type TagOnWorkItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workItem?: boolean | WorkItemDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type TagOnWorkItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workItem?: boolean | WorkItemDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type TagOnWorkItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workItem?: boolean | WorkItemDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }

  export type $TagOnWorkItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TagOnWorkItem"
    objects: {
      workItem: Prisma.$WorkItemPayload<ExtArgs>
      tag: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      workItemId: string
      tagId: string
    }, ExtArgs["result"]["tagOnWorkItem"]>
    composites: {}
  }

  type TagOnWorkItemGetPayload<S extends boolean | null | undefined | TagOnWorkItemDefaultArgs> = $Result.GetResult<Prisma.$TagOnWorkItemPayload, S>

  type TagOnWorkItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagOnWorkItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagOnWorkItemCountAggregateInputType | true
    }

  export interface TagOnWorkItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TagOnWorkItem'], meta: { name: 'TagOnWorkItem' } }
    /**
     * Find zero or one TagOnWorkItem that matches the filter.
     * @param {TagOnWorkItemFindUniqueArgs} args - Arguments to find a TagOnWorkItem
     * @example
     * // Get one TagOnWorkItem
     * const tagOnWorkItem = await prisma.tagOnWorkItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagOnWorkItemFindUniqueArgs>(args: SelectSubset<T, TagOnWorkItemFindUniqueArgs<ExtArgs>>): Prisma__TagOnWorkItemClient<$Result.GetResult<Prisma.$TagOnWorkItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TagOnWorkItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagOnWorkItemFindUniqueOrThrowArgs} args - Arguments to find a TagOnWorkItem
     * @example
     * // Get one TagOnWorkItem
     * const tagOnWorkItem = await prisma.tagOnWorkItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagOnWorkItemFindUniqueOrThrowArgs>(args: SelectSubset<T, TagOnWorkItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagOnWorkItemClient<$Result.GetResult<Prisma.$TagOnWorkItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TagOnWorkItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagOnWorkItemFindFirstArgs} args - Arguments to find a TagOnWorkItem
     * @example
     * // Get one TagOnWorkItem
     * const tagOnWorkItem = await prisma.tagOnWorkItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagOnWorkItemFindFirstArgs>(args?: SelectSubset<T, TagOnWorkItemFindFirstArgs<ExtArgs>>): Prisma__TagOnWorkItemClient<$Result.GetResult<Prisma.$TagOnWorkItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TagOnWorkItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagOnWorkItemFindFirstOrThrowArgs} args - Arguments to find a TagOnWorkItem
     * @example
     * // Get one TagOnWorkItem
     * const tagOnWorkItem = await prisma.tagOnWorkItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagOnWorkItemFindFirstOrThrowArgs>(args?: SelectSubset<T, TagOnWorkItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagOnWorkItemClient<$Result.GetResult<Prisma.$TagOnWorkItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TagOnWorkItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagOnWorkItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TagOnWorkItems
     * const tagOnWorkItems = await prisma.tagOnWorkItem.findMany()
     * 
     * // Get first 10 TagOnWorkItems
     * const tagOnWorkItems = await prisma.tagOnWorkItem.findMany({ take: 10 })
     * 
     * // Only select the `workItemId`
     * const tagOnWorkItemWithWorkItemIdOnly = await prisma.tagOnWorkItem.findMany({ select: { workItemId: true } })
     * 
     */
    findMany<T extends TagOnWorkItemFindManyArgs>(args?: SelectSubset<T, TagOnWorkItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagOnWorkItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TagOnWorkItem.
     * @param {TagOnWorkItemCreateArgs} args - Arguments to create a TagOnWorkItem.
     * @example
     * // Create one TagOnWorkItem
     * const TagOnWorkItem = await prisma.tagOnWorkItem.create({
     *   data: {
     *     // ... data to create a TagOnWorkItem
     *   }
     * })
     * 
     */
    create<T extends TagOnWorkItemCreateArgs>(args: SelectSubset<T, TagOnWorkItemCreateArgs<ExtArgs>>): Prisma__TagOnWorkItemClient<$Result.GetResult<Prisma.$TagOnWorkItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TagOnWorkItems.
     * @param {TagOnWorkItemCreateManyArgs} args - Arguments to create many TagOnWorkItems.
     * @example
     * // Create many TagOnWorkItems
     * const tagOnWorkItem = await prisma.tagOnWorkItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagOnWorkItemCreateManyArgs>(args?: SelectSubset<T, TagOnWorkItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TagOnWorkItems and returns the data saved in the database.
     * @param {TagOnWorkItemCreateManyAndReturnArgs} args - Arguments to create many TagOnWorkItems.
     * @example
     * // Create many TagOnWorkItems
     * const tagOnWorkItem = await prisma.tagOnWorkItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TagOnWorkItems and only return the `workItemId`
     * const tagOnWorkItemWithWorkItemIdOnly = await prisma.tagOnWorkItem.createManyAndReturn({
     *   select: { workItemId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagOnWorkItemCreateManyAndReturnArgs>(args?: SelectSubset<T, TagOnWorkItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagOnWorkItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TagOnWorkItem.
     * @param {TagOnWorkItemDeleteArgs} args - Arguments to delete one TagOnWorkItem.
     * @example
     * // Delete one TagOnWorkItem
     * const TagOnWorkItem = await prisma.tagOnWorkItem.delete({
     *   where: {
     *     // ... filter to delete one TagOnWorkItem
     *   }
     * })
     * 
     */
    delete<T extends TagOnWorkItemDeleteArgs>(args: SelectSubset<T, TagOnWorkItemDeleteArgs<ExtArgs>>): Prisma__TagOnWorkItemClient<$Result.GetResult<Prisma.$TagOnWorkItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TagOnWorkItem.
     * @param {TagOnWorkItemUpdateArgs} args - Arguments to update one TagOnWorkItem.
     * @example
     * // Update one TagOnWorkItem
     * const tagOnWorkItem = await prisma.tagOnWorkItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagOnWorkItemUpdateArgs>(args: SelectSubset<T, TagOnWorkItemUpdateArgs<ExtArgs>>): Prisma__TagOnWorkItemClient<$Result.GetResult<Prisma.$TagOnWorkItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TagOnWorkItems.
     * @param {TagOnWorkItemDeleteManyArgs} args - Arguments to filter TagOnWorkItems to delete.
     * @example
     * // Delete a few TagOnWorkItems
     * const { count } = await prisma.tagOnWorkItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagOnWorkItemDeleteManyArgs>(args?: SelectSubset<T, TagOnWorkItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TagOnWorkItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagOnWorkItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TagOnWorkItems
     * const tagOnWorkItem = await prisma.tagOnWorkItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagOnWorkItemUpdateManyArgs>(args: SelectSubset<T, TagOnWorkItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TagOnWorkItems and returns the data updated in the database.
     * @param {TagOnWorkItemUpdateManyAndReturnArgs} args - Arguments to update many TagOnWorkItems.
     * @example
     * // Update many TagOnWorkItems
     * const tagOnWorkItem = await prisma.tagOnWorkItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TagOnWorkItems and only return the `workItemId`
     * const tagOnWorkItemWithWorkItemIdOnly = await prisma.tagOnWorkItem.updateManyAndReturn({
     *   select: { workItemId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TagOnWorkItemUpdateManyAndReturnArgs>(args: SelectSubset<T, TagOnWorkItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagOnWorkItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TagOnWorkItem.
     * @param {TagOnWorkItemUpsertArgs} args - Arguments to update or create a TagOnWorkItem.
     * @example
     * // Update or create a TagOnWorkItem
     * const tagOnWorkItem = await prisma.tagOnWorkItem.upsert({
     *   create: {
     *     // ... data to create a TagOnWorkItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TagOnWorkItem we want to update
     *   }
     * })
     */
    upsert<T extends TagOnWorkItemUpsertArgs>(args: SelectSubset<T, TagOnWorkItemUpsertArgs<ExtArgs>>): Prisma__TagOnWorkItemClient<$Result.GetResult<Prisma.$TagOnWorkItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TagOnWorkItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagOnWorkItemCountArgs} args - Arguments to filter TagOnWorkItems to count.
     * @example
     * // Count the number of TagOnWorkItems
     * const count = await prisma.tagOnWorkItem.count({
     *   where: {
     *     // ... the filter for the TagOnWorkItems we want to count
     *   }
     * })
    **/
    count<T extends TagOnWorkItemCountArgs>(
      args?: Subset<T, TagOnWorkItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagOnWorkItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TagOnWorkItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagOnWorkItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagOnWorkItemAggregateArgs>(args: Subset<T, TagOnWorkItemAggregateArgs>): Prisma.PrismaPromise<GetTagOnWorkItemAggregateType<T>>

    /**
     * Group by TagOnWorkItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagOnWorkItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagOnWorkItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagOnWorkItemGroupByArgs['orderBy'] }
        : { orderBy?: TagOnWorkItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagOnWorkItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagOnWorkItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TagOnWorkItem model
   */
  readonly fields: TagOnWorkItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TagOnWorkItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagOnWorkItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workItem<T extends WorkItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkItemDefaultArgs<ExtArgs>>): Prisma__WorkItemClient<$Result.GetResult<Prisma.$WorkItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TagOnWorkItem model
   */
  interface TagOnWorkItemFieldRefs {
    readonly workItemId: FieldRef<"TagOnWorkItem", 'String'>
    readonly tagId: FieldRef<"TagOnWorkItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TagOnWorkItem findUnique
   */
  export type TagOnWorkItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagOnWorkItem
     */
    select?: TagOnWorkItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagOnWorkItem
     */
    omit?: TagOnWorkItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagOnWorkItemInclude<ExtArgs> | null
    /**
     * Filter, which TagOnWorkItem to fetch.
     */
    where: TagOnWorkItemWhereUniqueInput
  }

  /**
   * TagOnWorkItem findUniqueOrThrow
   */
  export type TagOnWorkItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagOnWorkItem
     */
    select?: TagOnWorkItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagOnWorkItem
     */
    omit?: TagOnWorkItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagOnWorkItemInclude<ExtArgs> | null
    /**
     * Filter, which TagOnWorkItem to fetch.
     */
    where: TagOnWorkItemWhereUniqueInput
  }

  /**
   * TagOnWorkItem findFirst
   */
  export type TagOnWorkItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagOnWorkItem
     */
    select?: TagOnWorkItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagOnWorkItem
     */
    omit?: TagOnWorkItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagOnWorkItemInclude<ExtArgs> | null
    /**
     * Filter, which TagOnWorkItem to fetch.
     */
    where?: TagOnWorkItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TagOnWorkItems to fetch.
     */
    orderBy?: TagOnWorkItemOrderByWithRelationInput | TagOnWorkItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TagOnWorkItems.
     */
    cursor?: TagOnWorkItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TagOnWorkItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TagOnWorkItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TagOnWorkItems.
     */
    distinct?: TagOnWorkItemScalarFieldEnum | TagOnWorkItemScalarFieldEnum[]
  }

  /**
   * TagOnWorkItem findFirstOrThrow
   */
  export type TagOnWorkItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagOnWorkItem
     */
    select?: TagOnWorkItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagOnWorkItem
     */
    omit?: TagOnWorkItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagOnWorkItemInclude<ExtArgs> | null
    /**
     * Filter, which TagOnWorkItem to fetch.
     */
    where?: TagOnWorkItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TagOnWorkItems to fetch.
     */
    orderBy?: TagOnWorkItemOrderByWithRelationInput | TagOnWorkItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TagOnWorkItems.
     */
    cursor?: TagOnWorkItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TagOnWorkItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TagOnWorkItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TagOnWorkItems.
     */
    distinct?: TagOnWorkItemScalarFieldEnum | TagOnWorkItemScalarFieldEnum[]
  }

  /**
   * TagOnWorkItem findMany
   */
  export type TagOnWorkItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagOnWorkItem
     */
    select?: TagOnWorkItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagOnWorkItem
     */
    omit?: TagOnWorkItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagOnWorkItemInclude<ExtArgs> | null
    /**
     * Filter, which TagOnWorkItems to fetch.
     */
    where?: TagOnWorkItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TagOnWorkItems to fetch.
     */
    orderBy?: TagOnWorkItemOrderByWithRelationInput | TagOnWorkItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TagOnWorkItems.
     */
    cursor?: TagOnWorkItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TagOnWorkItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TagOnWorkItems.
     */
    skip?: number
    distinct?: TagOnWorkItemScalarFieldEnum | TagOnWorkItemScalarFieldEnum[]
  }

  /**
   * TagOnWorkItem create
   */
  export type TagOnWorkItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagOnWorkItem
     */
    select?: TagOnWorkItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagOnWorkItem
     */
    omit?: TagOnWorkItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagOnWorkItemInclude<ExtArgs> | null
    /**
     * The data needed to create a TagOnWorkItem.
     */
    data: XOR<TagOnWorkItemCreateInput, TagOnWorkItemUncheckedCreateInput>
  }

  /**
   * TagOnWorkItem createMany
   */
  export type TagOnWorkItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TagOnWorkItems.
     */
    data: TagOnWorkItemCreateManyInput | TagOnWorkItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TagOnWorkItem createManyAndReturn
   */
  export type TagOnWorkItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagOnWorkItem
     */
    select?: TagOnWorkItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TagOnWorkItem
     */
    omit?: TagOnWorkItemOmit<ExtArgs> | null
    /**
     * The data used to create many TagOnWorkItems.
     */
    data: TagOnWorkItemCreateManyInput | TagOnWorkItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagOnWorkItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TagOnWorkItem update
   */
  export type TagOnWorkItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagOnWorkItem
     */
    select?: TagOnWorkItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagOnWorkItem
     */
    omit?: TagOnWorkItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagOnWorkItemInclude<ExtArgs> | null
    /**
     * The data needed to update a TagOnWorkItem.
     */
    data: XOR<TagOnWorkItemUpdateInput, TagOnWorkItemUncheckedUpdateInput>
    /**
     * Choose, which TagOnWorkItem to update.
     */
    where: TagOnWorkItemWhereUniqueInput
  }

  /**
   * TagOnWorkItem updateMany
   */
  export type TagOnWorkItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TagOnWorkItems.
     */
    data: XOR<TagOnWorkItemUpdateManyMutationInput, TagOnWorkItemUncheckedUpdateManyInput>
    /**
     * Filter which TagOnWorkItems to update
     */
    where?: TagOnWorkItemWhereInput
    /**
     * Limit how many TagOnWorkItems to update.
     */
    limit?: number
  }

  /**
   * TagOnWorkItem updateManyAndReturn
   */
  export type TagOnWorkItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagOnWorkItem
     */
    select?: TagOnWorkItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TagOnWorkItem
     */
    omit?: TagOnWorkItemOmit<ExtArgs> | null
    /**
     * The data used to update TagOnWorkItems.
     */
    data: XOR<TagOnWorkItemUpdateManyMutationInput, TagOnWorkItemUncheckedUpdateManyInput>
    /**
     * Filter which TagOnWorkItems to update
     */
    where?: TagOnWorkItemWhereInput
    /**
     * Limit how many TagOnWorkItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagOnWorkItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TagOnWorkItem upsert
   */
  export type TagOnWorkItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagOnWorkItem
     */
    select?: TagOnWorkItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagOnWorkItem
     */
    omit?: TagOnWorkItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagOnWorkItemInclude<ExtArgs> | null
    /**
     * The filter to search for the TagOnWorkItem to update in case it exists.
     */
    where: TagOnWorkItemWhereUniqueInput
    /**
     * In case the TagOnWorkItem found by the `where` argument doesn't exist, create a new TagOnWorkItem with this data.
     */
    create: XOR<TagOnWorkItemCreateInput, TagOnWorkItemUncheckedCreateInput>
    /**
     * In case the TagOnWorkItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagOnWorkItemUpdateInput, TagOnWorkItemUncheckedUpdateInput>
  }

  /**
   * TagOnWorkItem delete
   */
  export type TagOnWorkItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagOnWorkItem
     */
    select?: TagOnWorkItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagOnWorkItem
     */
    omit?: TagOnWorkItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagOnWorkItemInclude<ExtArgs> | null
    /**
     * Filter which TagOnWorkItem to delete.
     */
    where: TagOnWorkItemWhereUniqueInput
  }

  /**
   * TagOnWorkItem deleteMany
   */
  export type TagOnWorkItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TagOnWorkItems to delete
     */
    where?: TagOnWorkItemWhereInput
    /**
     * Limit how many TagOnWorkItems to delete.
     */
    limit?: number
  }

  /**
   * TagOnWorkItem without action
   */
  export type TagOnWorkItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagOnWorkItem
     */
    select?: TagOnWorkItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagOnWorkItem
     */
    omit?: TagOnWorkItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagOnWorkItemInclude<ExtArgs> | null
  }


  /**
   * Model Component
   */

  export type AggregateComponent = {
    _count: ComponentCountAggregateOutputType | null
    _avg: ComponentAvgAggregateOutputType | null
    _sum: ComponentSumAggregateOutputType | null
    _min: ComponentMinAggregateOutputType | null
    _max: ComponentMaxAggregateOutputType | null
  }

  export type ComponentAvgAggregateOutputType = {
    position: number | null
  }

  export type ComponentSumAggregateOutputType = {
    position: number | null
  }

  export type ComponentMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    color: string | null
    position: number | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
  }

  export type ComponentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    color: string | null
    position: number | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
  }

  export type ComponentCountAggregateOutputType = {
    id: number
    name: number
    description: number
    color: number
    position: number
    createdAt: number
    updatedAt: number
    projectId: number
    _all: number
  }


  export type ComponentAvgAggregateInputType = {
    position?: true
  }

  export type ComponentSumAggregateInputType = {
    position?: true
  }

  export type ComponentMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    color?: true
    position?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type ComponentMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    color?: true
    position?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type ComponentCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    color?: true
    position?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    _all?: true
  }

  export type ComponentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Component to aggregate.
     */
    where?: ComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Components to fetch.
     */
    orderBy?: ComponentOrderByWithRelationInput | ComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Components from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Components.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Components
    **/
    _count?: true | ComponentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComponentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComponentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComponentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComponentMaxAggregateInputType
  }

  export type GetComponentAggregateType<T extends ComponentAggregateArgs> = {
        [P in keyof T & keyof AggregateComponent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComponent[P]>
      : GetScalarType<T[P], AggregateComponent[P]>
  }




  export type ComponentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComponentWhereInput
    orderBy?: ComponentOrderByWithAggregationInput | ComponentOrderByWithAggregationInput[]
    by: ComponentScalarFieldEnum[] | ComponentScalarFieldEnum
    having?: ComponentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComponentCountAggregateInputType | true
    _avg?: ComponentAvgAggregateInputType
    _sum?: ComponentSumAggregateInputType
    _min?: ComponentMinAggregateInputType
    _max?: ComponentMaxAggregateInputType
  }

  export type ComponentGroupByOutputType = {
    id: string
    name: string
    description: string | null
    color: string
    position: number
    createdAt: Date
    updatedAt: Date
    projectId: string
    _count: ComponentCountAggregateOutputType | null
    _avg: ComponentAvgAggregateOutputType | null
    _sum: ComponentSumAggregateOutputType | null
    _min: ComponentMinAggregateOutputType | null
    _max: ComponentMaxAggregateOutputType | null
  }

  type GetComponentGroupByPayload<T extends ComponentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComponentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComponentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComponentGroupByOutputType[P]>
            : GetScalarType<T[P], ComponentGroupByOutputType[P]>
        }
      >
    >


  export type ComponentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    workItems?: boolean | Component$workItemsArgs<ExtArgs>
    _count?: boolean | ComponentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["component"]>

  export type ComponentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["component"]>

  export type ComponentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["component"]>

  export type ComponentSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
  }

  export type ComponentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "color" | "position" | "createdAt" | "updatedAt" | "projectId", ExtArgs["result"]["component"]>
  export type ComponentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    workItems?: boolean | Component$workItemsArgs<ExtArgs>
    _count?: boolean | ComponentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ComponentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ComponentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $ComponentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Component"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      workItems: Prisma.$ComponentOnWorkItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      color: string
      position: number
      createdAt: Date
      updatedAt: Date
      projectId: string
    }, ExtArgs["result"]["component"]>
    composites: {}
  }

  type ComponentGetPayload<S extends boolean | null | undefined | ComponentDefaultArgs> = $Result.GetResult<Prisma.$ComponentPayload, S>

  type ComponentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ComponentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ComponentCountAggregateInputType | true
    }

  export interface ComponentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Component'], meta: { name: 'Component' } }
    /**
     * Find zero or one Component that matches the filter.
     * @param {ComponentFindUniqueArgs} args - Arguments to find a Component
     * @example
     * // Get one Component
     * const component = await prisma.component.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComponentFindUniqueArgs>(args: SelectSubset<T, ComponentFindUniqueArgs<ExtArgs>>): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Component that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ComponentFindUniqueOrThrowArgs} args - Arguments to find a Component
     * @example
     * // Get one Component
     * const component = await prisma.component.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComponentFindUniqueOrThrowArgs>(args: SelectSubset<T, ComponentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Component that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentFindFirstArgs} args - Arguments to find a Component
     * @example
     * // Get one Component
     * const component = await prisma.component.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComponentFindFirstArgs>(args?: SelectSubset<T, ComponentFindFirstArgs<ExtArgs>>): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Component that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentFindFirstOrThrowArgs} args - Arguments to find a Component
     * @example
     * // Get one Component
     * const component = await prisma.component.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComponentFindFirstOrThrowArgs>(args?: SelectSubset<T, ComponentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Components that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Components
     * const components = await prisma.component.findMany()
     * 
     * // Get first 10 Components
     * const components = await prisma.component.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const componentWithIdOnly = await prisma.component.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ComponentFindManyArgs>(args?: SelectSubset<T, ComponentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Component.
     * @param {ComponentCreateArgs} args - Arguments to create a Component.
     * @example
     * // Create one Component
     * const Component = await prisma.component.create({
     *   data: {
     *     // ... data to create a Component
     *   }
     * })
     * 
     */
    create<T extends ComponentCreateArgs>(args: SelectSubset<T, ComponentCreateArgs<ExtArgs>>): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Components.
     * @param {ComponentCreateManyArgs} args - Arguments to create many Components.
     * @example
     * // Create many Components
     * const component = await prisma.component.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComponentCreateManyArgs>(args?: SelectSubset<T, ComponentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Components and returns the data saved in the database.
     * @param {ComponentCreateManyAndReturnArgs} args - Arguments to create many Components.
     * @example
     * // Create many Components
     * const component = await prisma.component.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Components and only return the `id`
     * const componentWithIdOnly = await prisma.component.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ComponentCreateManyAndReturnArgs>(args?: SelectSubset<T, ComponentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Component.
     * @param {ComponentDeleteArgs} args - Arguments to delete one Component.
     * @example
     * // Delete one Component
     * const Component = await prisma.component.delete({
     *   where: {
     *     // ... filter to delete one Component
     *   }
     * })
     * 
     */
    delete<T extends ComponentDeleteArgs>(args: SelectSubset<T, ComponentDeleteArgs<ExtArgs>>): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Component.
     * @param {ComponentUpdateArgs} args - Arguments to update one Component.
     * @example
     * // Update one Component
     * const component = await prisma.component.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComponentUpdateArgs>(args: SelectSubset<T, ComponentUpdateArgs<ExtArgs>>): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Components.
     * @param {ComponentDeleteManyArgs} args - Arguments to filter Components to delete.
     * @example
     * // Delete a few Components
     * const { count } = await prisma.component.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComponentDeleteManyArgs>(args?: SelectSubset<T, ComponentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Components.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Components
     * const component = await prisma.component.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComponentUpdateManyArgs>(args: SelectSubset<T, ComponentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Components and returns the data updated in the database.
     * @param {ComponentUpdateManyAndReturnArgs} args - Arguments to update many Components.
     * @example
     * // Update many Components
     * const component = await prisma.component.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Components and only return the `id`
     * const componentWithIdOnly = await prisma.component.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ComponentUpdateManyAndReturnArgs>(args: SelectSubset<T, ComponentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Component.
     * @param {ComponentUpsertArgs} args - Arguments to update or create a Component.
     * @example
     * // Update or create a Component
     * const component = await prisma.component.upsert({
     *   create: {
     *     // ... data to create a Component
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Component we want to update
     *   }
     * })
     */
    upsert<T extends ComponentUpsertArgs>(args: SelectSubset<T, ComponentUpsertArgs<ExtArgs>>): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Components.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentCountArgs} args - Arguments to filter Components to count.
     * @example
     * // Count the number of Components
     * const count = await prisma.component.count({
     *   where: {
     *     // ... the filter for the Components we want to count
     *   }
     * })
    **/
    count<T extends ComponentCountArgs>(
      args?: Subset<T, ComponentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComponentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Component.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComponentAggregateArgs>(args: Subset<T, ComponentAggregateArgs>): Prisma.PrismaPromise<GetComponentAggregateType<T>>

    /**
     * Group by Component.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComponentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComponentGroupByArgs['orderBy'] }
        : { orderBy?: ComponentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComponentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComponentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Component model
   */
  readonly fields: ComponentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Component.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComponentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    workItems<T extends Component$workItemsArgs<ExtArgs> = {}>(args?: Subset<T, Component$workItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComponentOnWorkItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Component model
   */
  interface ComponentFieldRefs {
    readonly id: FieldRef<"Component", 'String'>
    readonly name: FieldRef<"Component", 'String'>
    readonly description: FieldRef<"Component", 'String'>
    readonly color: FieldRef<"Component", 'String'>
    readonly position: FieldRef<"Component", 'Int'>
    readonly createdAt: FieldRef<"Component", 'DateTime'>
    readonly updatedAt: FieldRef<"Component", 'DateTime'>
    readonly projectId: FieldRef<"Component", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Component findUnique
   */
  export type ComponentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Component
     */
    omit?: ComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
    /**
     * Filter, which Component to fetch.
     */
    where: ComponentWhereUniqueInput
  }

  /**
   * Component findUniqueOrThrow
   */
  export type ComponentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Component
     */
    omit?: ComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
    /**
     * Filter, which Component to fetch.
     */
    where: ComponentWhereUniqueInput
  }

  /**
   * Component findFirst
   */
  export type ComponentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Component
     */
    omit?: ComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
    /**
     * Filter, which Component to fetch.
     */
    where?: ComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Components to fetch.
     */
    orderBy?: ComponentOrderByWithRelationInput | ComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Components.
     */
    cursor?: ComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Components from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Components.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Components.
     */
    distinct?: ComponentScalarFieldEnum | ComponentScalarFieldEnum[]
  }

  /**
   * Component findFirstOrThrow
   */
  export type ComponentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Component
     */
    omit?: ComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
    /**
     * Filter, which Component to fetch.
     */
    where?: ComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Components to fetch.
     */
    orderBy?: ComponentOrderByWithRelationInput | ComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Components.
     */
    cursor?: ComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Components from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Components.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Components.
     */
    distinct?: ComponentScalarFieldEnum | ComponentScalarFieldEnum[]
  }

  /**
   * Component findMany
   */
  export type ComponentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Component
     */
    omit?: ComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
    /**
     * Filter, which Components to fetch.
     */
    where?: ComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Components to fetch.
     */
    orderBy?: ComponentOrderByWithRelationInput | ComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Components.
     */
    cursor?: ComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Components from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Components.
     */
    skip?: number
    distinct?: ComponentScalarFieldEnum | ComponentScalarFieldEnum[]
  }

  /**
   * Component create
   */
  export type ComponentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Component
     */
    omit?: ComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
    /**
     * The data needed to create a Component.
     */
    data: XOR<ComponentCreateInput, ComponentUncheckedCreateInput>
  }

  /**
   * Component createMany
   */
  export type ComponentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Components.
     */
    data: ComponentCreateManyInput | ComponentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Component createManyAndReturn
   */
  export type ComponentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Component
     */
    omit?: ComponentOmit<ExtArgs> | null
    /**
     * The data used to create many Components.
     */
    data: ComponentCreateManyInput | ComponentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Component update
   */
  export type ComponentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Component
     */
    omit?: ComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
    /**
     * The data needed to update a Component.
     */
    data: XOR<ComponentUpdateInput, ComponentUncheckedUpdateInput>
    /**
     * Choose, which Component to update.
     */
    where: ComponentWhereUniqueInput
  }

  /**
   * Component updateMany
   */
  export type ComponentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Components.
     */
    data: XOR<ComponentUpdateManyMutationInput, ComponentUncheckedUpdateManyInput>
    /**
     * Filter which Components to update
     */
    where?: ComponentWhereInput
    /**
     * Limit how many Components to update.
     */
    limit?: number
  }

  /**
   * Component updateManyAndReturn
   */
  export type ComponentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Component
     */
    omit?: ComponentOmit<ExtArgs> | null
    /**
     * The data used to update Components.
     */
    data: XOR<ComponentUpdateManyMutationInput, ComponentUncheckedUpdateManyInput>
    /**
     * Filter which Components to update
     */
    where?: ComponentWhereInput
    /**
     * Limit how many Components to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Component upsert
   */
  export type ComponentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Component
     */
    omit?: ComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
    /**
     * The filter to search for the Component to update in case it exists.
     */
    where: ComponentWhereUniqueInput
    /**
     * In case the Component found by the `where` argument doesn't exist, create a new Component with this data.
     */
    create: XOR<ComponentCreateInput, ComponentUncheckedCreateInput>
    /**
     * In case the Component was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComponentUpdateInput, ComponentUncheckedUpdateInput>
  }

  /**
   * Component delete
   */
  export type ComponentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Component
     */
    omit?: ComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
    /**
     * Filter which Component to delete.
     */
    where: ComponentWhereUniqueInput
  }

  /**
   * Component deleteMany
   */
  export type ComponentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Components to delete
     */
    where?: ComponentWhereInput
    /**
     * Limit how many Components to delete.
     */
    limit?: number
  }

  /**
   * Component.workItems
   */
  export type Component$workItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentOnWorkItem
     */
    select?: ComponentOnWorkItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComponentOnWorkItem
     */
    omit?: ComponentOnWorkItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentOnWorkItemInclude<ExtArgs> | null
    where?: ComponentOnWorkItemWhereInput
    orderBy?: ComponentOnWorkItemOrderByWithRelationInput | ComponentOnWorkItemOrderByWithRelationInput[]
    cursor?: ComponentOnWorkItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComponentOnWorkItemScalarFieldEnum | ComponentOnWorkItemScalarFieldEnum[]
  }

  /**
   * Component without action
   */
  export type ComponentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Component
     */
    omit?: ComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
  }


  /**
   * Model ComponentOnWorkItem
   */

  export type AggregateComponentOnWorkItem = {
    _count: ComponentOnWorkItemCountAggregateOutputType | null
    _min: ComponentOnWorkItemMinAggregateOutputType | null
    _max: ComponentOnWorkItemMaxAggregateOutputType | null
  }

  export type ComponentOnWorkItemMinAggregateOutputType = {
    workItemId: string | null
    componentId: string | null
    assignedAt: Date | null
  }

  export type ComponentOnWorkItemMaxAggregateOutputType = {
    workItemId: string | null
    componentId: string | null
    assignedAt: Date | null
  }

  export type ComponentOnWorkItemCountAggregateOutputType = {
    workItemId: number
    componentId: number
    assignedAt: number
    _all: number
  }


  export type ComponentOnWorkItemMinAggregateInputType = {
    workItemId?: true
    componentId?: true
    assignedAt?: true
  }

  export type ComponentOnWorkItemMaxAggregateInputType = {
    workItemId?: true
    componentId?: true
    assignedAt?: true
  }

  export type ComponentOnWorkItemCountAggregateInputType = {
    workItemId?: true
    componentId?: true
    assignedAt?: true
    _all?: true
  }

  export type ComponentOnWorkItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComponentOnWorkItem to aggregate.
     */
    where?: ComponentOnWorkItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComponentOnWorkItems to fetch.
     */
    orderBy?: ComponentOnWorkItemOrderByWithRelationInput | ComponentOnWorkItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComponentOnWorkItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComponentOnWorkItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComponentOnWorkItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ComponentOnWorkItems
    **/
    _count?: true | ComponentOnWorkItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComponentOnWorkItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComponentOnWorkItemMaxAggregateInputType
  }

  export type GetComponentOnWorkItemAggregateType<T extends ComponentOnWorkItemAggregateArgs> = {
        [P in keyof T & keyof AggregateComponentOnWorkItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComponentOnWorkItem[P]>
      : GetScalarType<T[P], AggregateComponentOnWorkItem[P]>
  }




  export type ComponentOnWorkItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComponentOnWorkItemWhereInput
    orderBy?: ComponentOnWorkItemOrderByWithAggregationInput | ComponentOnWorkItemOrderByWithAggregationInput[]
    by: ComponentOnWorkItemScalarFieldEnum[] | ComponentOnWorkItemScalarFieldEnum
    having?: ComponentOnWorkItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComponentOnWorkItemCountAggregateInputType | true
    _min?: ComponentOnWorkItemMinAggregateInputType
    _max?: ComponentOnWorkItemMaxAggregateInputType
  }

  export type ComponentOnWorkItemGroupByOutputType = {
    workItemId: string
    componentId: string
    assignedAt: Date
    _count: ComponentOnWorkItemCountAggregateOutputType | null
    _min: ComponentOnWorkItemMinAggregateOutputType | null
    _max: ComponentOnWorkItemMaxAggregateOutputType | null
  }

  type GetComponentOnWorkItemGroupByPayload<T extends ComponentOnWorkItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComponentOnWorkItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComponentOnWorkItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComponentOnWorkItemGroupByOutputType[P]>
            : GetScalarType<T[P], ComponentOnWorkItemGroupByOutputType[P]>
        }
      >
    >


  export type ComponentOnWorkItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workItemId?: boolean
    componentId?: boolean
    assignedAt?: boolean
    workItem?: boolean | WorkItemDefaultArgs<ExtArgs>
    component?: boolean | ComponentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["componentOnWorkItem"]>

  export type ComponentOnWorkItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workItemId?: boolean
    componentId?: boolean
    assignedAt?: boolean
    workItem?: boolean | WorkItemDefaultArgs<ExtArgs>
    component?: boolean | ComponentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["componentOnWorkItem"]>

  export type ComponentOnWorkItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workItemId?: boolean
    componentId?: boolean
    assignedAt?: boolean
    workItem?: boolean | WorkItemDefaultArgs<ExtArgs>
    component?: boolean | ComponentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["componentOnWorkItem"]>

  export type ComponentOnWorkItemSelectScalar = {
    workItemId?: boolean
    componentId?: boolean
    assignedAt?: boolean
  }

  export type ComponentOnWorkItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"workItemId" | "componentId" | "assignedAt", ExtArgs["result"]["componentOnWorkItem"]>
  export type ComponentOnWorkItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workItem?: boolean | WorkItemDefaultArgs<ExtArgs>
    component?: boolean | ComponentDefaultArgs<ExtArgs>
  }
  export type ComponentOnWorkItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workItem?: boolean | WorkItemDefaultArgs<ExtArgs>
    component?: boolean | ComponentDefaultArgs<ExtArgs>
  }
  export type ComponentOnWorkItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workItem?: boolean | WorkItemDefaultArgs<ExtArgs>
    component?: boolean | ComponentDefaultArgs<ExtArgs>
  }

  export type $ComponentOnWorkItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ComponentOnWorkItem"
    objects: {
      workItem: Prisma.$WorkItemPayload<ExtArgs>
      component: Prisma.$ComponentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      workItemId: string
      componentId: string
      assignedAt: Date
    }, ExtArgs["result"]["componentOnWorkItem"]>
    composites: {}
  }

  type ComponentOnWorkItemGetPayload<S extends boolean | null | undefined | ComponentOnWorkItemDefaultArgs> = $Result.GetResult<Prisma.$ComponentOnWorkItemPayload, S>

  type ComponentOnWorkItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ComponentOnWorkItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ComponentOnWorkItemCountAggregateInputType | true
    }

  export interface ComponentOnWorkItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ComponentOnWorkItem'], meta: { name: 'ComponentOnWorkItem' } }
    /**
     * Find zero or one ComponentOnWorkItem that matches the filter.
     * @param {ComponentOnWorkItemFindUniqueArgs} args - Arguments to find a ComponentOnWorkItem
     * @example
     * // Get one ComponentOnWorkItem
     * const componentOnWorkItem = await prisma.componentOnWorkItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComponentOnWorkItemFindUniqueArgs>(args: SelectSubset<T, ComponentOnWorkItemFindUniqueArgs<ExtArgs>>): Prisma__ComponentOnWorkItemClient<$Result.GetResult<Prisma.$ComponentOnWorkItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ComponentOnWorkItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ComponentOnWorkItemFindUniqueOrThrowArgs} args - Arguments to find a ComponentOnWorkItem
     * @example
     * // Get one ComponentOnWorkItem
     * const componentOnWorkItem = await prisma.componentOnWorkItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComponentOnWorkItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ComponentOnWorkItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComponentOnWorkItemClient<$Result.GetResult<Prisma.$ComponentOnWorkItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ComponentOnWorkItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentOnWorkItemFindFirstArgs} args - Arguments to find a ComponentOnWorkItem
     * @example
     * // Get one ComponentOnWorkItem
     * const componentOnWorkItem = await prisma.componentOnWorkItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComponentOnWorkItemFindFirstArgs>(args?: SelectSubset<T, ComponentOnWorkItemFindFirstArgs<ExtArgs>>): Prisma__ComponentOnWorkItemClient<$Result.GetResult<Prisma.$ComponentOnWorkItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ComponentOnWorkItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentOnWorkItemFindFirstOrThrowArgs} args - Arguments to find a ComponentOnWorkItem
     * @example
     * // Get one ComponentOnWorkItem
     * const componentOnWorkItem = await prisma.componentOnWorkItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComponentOnWorkItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ComponentOnWorkItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComponentOnWorkItemClient<$Result.GetResult<Prisma.$ComponentOnWorkItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ComponentOnWorkItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentOnWorkItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ComponentOnWorkItems
     * const componentOnWorkItems = await prisma.componentOnWorkItem.findMany()
     * 
     * // Get first 10 ComponentOnWorkItems
     * const componentOnWorkItems = await prisma.componentOnWorkItem.findMany({ take: 10 })
     * 
     * // Only select the `workItemId`
     * const componentOnWorkItemWithWorkItemIdOnly = await prisma.componentOnWorkItem.findMany({ select: { workItemId: true } })
     * 
     */
    findMany<T extends ComponentOnWorkItemFindManyArgs>(args?: SelectSubset<T, ComponentOnWorkItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComponentOnWorkItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ComponentOnWorkItem.
     * @param {ComponentOnWorkItemCreateArgs} args - Arguments to create a ComponentOnWorkItem.
     * @example
     * // Create one ComponentOnWorkItem
     * const ComponentOnWorkItem = await prisma.componentOnWorkItem.create({
     *   data: {
     *     // ... data to create a ComponentOnWorkItem
     *   }
     * })
     * 
     */
    create<T extends ComponentOnWorkItemCreateArgs>(args: SelectSubset<T, ComponentOnWorkItemCreateArgs<ExtArgs>>): Prisma__ComponentOnWorkItemClient<$Result.GetResult<Prisma.$ComponentOnWorkItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ComponentOnWorkItems.
     * @param {ComponentOnWorkItemCreateManyArgs} args - Arguments to create many ComponentOnWorkItems.
     * @example
     * // Create many ComponentOnWorkItems
     * const componentOnWorkItem = await prisma.componentOnWorkItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComponentOnWorkItemCreateManyArgs>(args?: SelectSubset<T, ComponentOnWorkItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ComponentOnWorkItems and returns the data saved in the database.
     * @param {ComponentOnWorkItemCreateManyAndReturnArgs} args - Arguments to create many ComponentOnWorkItems.
     * @example
     * // Create many ComponentOnWorkItems
     * const componentOnWorkItem = await prisma.componentOnWorkItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ComponentOnWorkItems and only return the `workItemId`
     * const componentOnWorkItemWithWorkItemIdOnly = await prisma.componentOnWorkItem.createManyAndReturn({
     *   select: { workItemId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ComponentOnWorkItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ComponentOnWorkItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComponentOnWorkItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ComponentOnWorkItem.
     * @param {ComponentOnWorkItemDeleteArgs} args - Arguments to delete one ComponentOnWorkItem.
     * @example
     * // Delete one ComponentOnWorkItem
     * const ComponentOnWorkItem = await prisma.componentOnWorkItem.delete({
     *   where: {
     *     // ... filter to delete one ComponentOnWorkItem
     *   }
     * })
     * 
     */
    delete<T extends ComponentOnWorkItemDeleteArgs>(args: SelectSubset<T, ComponentOnWorkItemDeleteArgs<ExtArgs>>): Prisma__ComponentOnWorkItemClient<$Result.GetResult<Prisma.$ComponentOnWorkItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ComponentOnWorkItem.
     * @param {ComponentOnWorkItemUpdateArgs} args - Arguments to update one ComponentOnWorkItem.
     * @example
     * // Update one ComponentOnWorkItem
     * const componentOnWorkItem = await prisma.componentOnWorkItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComponentOnWorkItemUpdateArgs>(args: SelectSubset<T, ComponentOnWorkItemUpdateArgs<ExtArgs>>): Prisma__ComponentOnWorkItemClient<$Result.GetResult<Prisma.$ComponentOnWorkItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ComponentOnWorkItems.
     * @param {ComponentOnWorkItemDeleteManyArgs} args - Arguments to filter ComponentOnWorkItems to delete.
     * @example
     * // Delete a few ComponentOnWorkItems
     * const { count } = await prisma.componentOnWorkItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComponentOnWorkItemDeleteManyArgs>(args?: SelectSubset<T, ComponentOnWorkItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ComponentOnWorkItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentOnWorkItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ComponentOnWorkItems
     * const componentOnWorkItem = await prisma.componentOnWorkItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComponentOnWorkItemUpdateManyArgs>(args: SelectSubset<T, ComponentOnWorkItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ComponentOnWorkItems and returns the data updated in the database.
     * @param {ComponentOnWorkItemUpdateManyAndReturnArgs} args - Arguments to update many ComponentOnWorkItems.
     * @example
     * // Update many ComponentOnWorkItems
     * const componentOnWorkItem = await prisma.componentOnWorkItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ComponentOnWorkItems and only return the `workItemId`
     * const componentOnWorkItemWithWorkItemIdOnly = await prisma.componentOnWorkItem.updateManyAndReturn({
     *   select: { workItemId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ComponentOnWorkItemUpdateManyAndReturnArgs>(args: SelectSubset<T, ComponentOnWorkItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComponentOnWorkItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ComponentOnWorkItem.
     * @param {ComponentOnWorkItemUpsertArgs} args - Arguments to update or create a ComponentOnWorkItem.
     * @example
     * // Update or create a ComponentOnWorkItem
     * const componentOnWorkItem = await prisma.componentOnWorkItem.upsert({
     *   create: {
     *     // ... data to create a ComponentOnWorkItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ComponentOnWorkItem we want to update
     *   }
     * })
     */
    upsert<T extends ComponentOnWorkItemUpsertArgs>(args: SelectSubset<T, ComponentOnWorkItemUpsertArgs<ExtArgs>>): Prisma__ComponentOnWorkItemClient<$Result.GetResult<Prisma.$ComponentOnWorkItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ComponentOnWorkItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentOnWorkItemCountArgs} args - Arguments to filter ComponentOnWorkItems to count.
     * @example
     * // Count the number of ComponentOnWorkItems
     * const count = await prisma.componentOnWorkItem.count({
     *   where: {
     *     // ... the filter for the ComponentOnWorkItems we want to count
     *   }
     * })
    **/
    count<T extends ComponentOnWorkItemCountArgs>(
      args?: Subset<T, ComponentOnWorkItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComponentOnWorkItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ComponentOnWorkItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentOnWorkItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComponentOnWorkItemAggregateArgs>(args: Subset<T, ComponentOnWorkItemAggregateArgs>): Prisma.PrismaPromise<GetComponentOnWorkItemAggregateType<T>>

    /**
     * Group by ComponentOnWorkItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentOnWorkItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComponentOnWorkItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComponentOnWorkItemGroupByArgs['orderBy'] }
        : { orderBy?: ComponentOnWorkItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComponentOnWorkItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComponentOnWorkItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ComponentOnWorkItem model
   */
  readonly fields: ComponentOnWorkItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ComponentOnWorkItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComponentOnWorkItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workItem<T extends WorkItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkItemDefaultArgs<ExtArgs>>): Prisma__WorkItemClient<$Result.GetResult<Prisma.$WorkItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    component<T extends ComponentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ComponentDefaultArgs<ExtArgs>>): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ComponentOnWorkItem model
   */
  interface ComponentOnWorkItemFieldRefs {
    readonly workItemId: FieldRef<"ComponentOnWorkItem", 'String'>
    readonly componentId: FieldRef<"ComponentOnWorkItem", 'String'>
    readonly assignedAt: FieldRef<"ComponentOnWorkItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ComponentOnWorkItem findUnique
   */
  export type ComponentOnWorkItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentOnWorkItem
     */
    select?: ComponentOnWorkItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComponentOnWorkItem
     */
    omit?: ComponentOnWorkItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentOnWorkItemInclude<ExtArgs> | null
    /**
     * Filter, which ComponentOnWorkItem to fetch.
     */
    where: ComponentOnWorkItemWhereUniqueInput
  }

  /**
   * ComponentOnWorkItem findUniqueOrThrow
   */
  export type ComponentOnWorkItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentOnWorkItem
     */
    select?: ComponentOnWorkItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComponentOnWorkItem
     */
    omit?: ComponentOnWorkItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentOnWorkItemInclude<ExtArgs> | null
    /**
     * Filter, which ComponentOnWorkItem to fetch.
     */
    where: ComponentOnWorkItemWhereUniqueInput
  }

  /**
   * ComponentOnWorkItem findFirst
   */
  export type ComponentOnWorkItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentOnWorkItem
     */
    select?: ComponentOnWorkItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComponentOnWorkItem
     */
    omit?: ComponentOnWorkItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentOnWorkItemInclude<ExtArgs> | null
    /**
     * Filter, which ComponentOnWorkItem to fetch.
     */
    where?: ComponentOnWorkItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComponentOnWorkItems to fetch.
     */
    orderBy?: ComponentOnWorkItemOrderByWithRelationInput | ComponentOnWorkItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComponentOnWorkItems.
     */
    cursor?: ComponentOnWorkItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComponentOnWorkItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComponentOnWorkItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComponentOnWorkItems.
     */
    distinct?: ComponentOnWorkItemScalarFieldEnum | ComponentOnWorkItemScalarFieldEnum[]
  }

  /**
   * ComponentOnWorkItem findFirstOrThrow
   */
  export type ComponentOnWorkItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentOnWorkItem
     */
    select?: ComponentOnWorkItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComponentOnWorkItem
     */
    omit?: ComponentOnWorkItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentOnWorkItemInclude<ExtArgs> | null
    /**
     * Filter, which ComponentOnWorkItem to fetch.
     */
    where?: ComponentOnWorkItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComponentOnWorkItems to fetch.
     */
    orderBy?: ComponentOnWorkItemOrderByWithRelationInput | ComponentOnWorkItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComponentOnWorkItems.
     */
    cursor?: ComponentOnWorkItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComponentOnWorkItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComponentOnWorkItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComponentOnWorkItems.
     */
    distinct?: ComponentOnWorkItemScalarFieldEnum | ComponentOnWorkItemScalarFieldEnum[]
  }

  /**
   * ComponentOnWorkItem findMany
   */
  export type ComponentOnWorkItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentOnWorkItem
     */
    select?: ComponentOnWorkItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComponentOnWorkItem
     */
    omit?: ComponentOnWorkItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentOnWorkItemInclude<ExtArgs> | null
    /**
     * Filter, which ComponentOnWorkItems to fetch.
     */
    where?: ComponentOnWorkItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComponentOnWorkItems to fetch.
     */
    orderBy?: ComponentOnWorkItemOrderByWithRelationInput | ComponentOnWorkItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ComponentOnWorkItems.
     */
    cursor?: ComponentOnWorkItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComponentOnWorkItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComponentOnWorkItems.
     */
    skip?: number
    distinct?: ComponentOnWorkItemScalarFieldEnum | ComponentOnWorkItemScalarFieldEnum[]
  }

  /**
   * ComponentOnWorkItem create
   */
  export type ComponentOnWorkItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentOnWorkItem
     */
    select?: ComponentOnWorkItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComponentOnWorkItem
     */
    omit?: ComponentOnWorkItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentOnWorkItemInclude<ExtArgs> | null
    /**
     * The data needed to create a ComponentOnWorkItem.
     */
    data: XOR<ComponentOnWorkItemCreateInput, ComponentOnWorkItemUncheckedCreateInput>
  }

  /**
   * ComponentOnWorkItem createMany
   */
  export type ComponentOnWorkItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ComponentOnWorkItems.
     */
    data: ComponentOnWorkItemCreateManyInput | ComponentOnWorkItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ComponentOnWorkItem createManyAndReturn
   */
  export type ComponentOnWorkItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentOnWorkItem
     */
    select?: ComponentOnWorkItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ComponentOnWorkItem
     */
    omit?: ComponentOnWorkItemOmit<ExtArgs> | null
    /**
     * The data used to create many ComponentOnWorkItems.
     */
    data: ComponentOnWorkItemCreateManyInput | ComponentOnWorkItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentOnWorkItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ComponentOnWorkItem update
   */
  export type ComponentOnWorkItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentOnWorkItem
     */
    select?: ComponentOnWorkItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComponentOnWorkItem
     */
    omit?: ComponentOnWorkItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentOnWorkItemInclude<ExtArgs> | null
    /**
     * The data needed to update a ComponentOnWorkItem.
     */
    data: XOR<ComponentOnWorkItemUpdateInput, ComponentOnWorkItemUncheckedUpdateInput>
    /**
     * Choose, which ComponentOnWorkItem to update.
     */
    where: ComponentOnWorkItemWhereUniqueInput
  }

  /**
   * ComponentOnWorkItem updateMany
   */
  export type ComponentOnWorkItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ComponentOnWorkItems.
     */
    data: XOR<ComponentOnWorkItemUpdateManyMutationInput, ComponentOnWorkItemUncheckedUpdateManyInput>
    /**
     * Filter which ComponentOnWorkItems to update
     */
    where?: ComponentOnWorkItemWhereInput
    /**
     * Limit how many ComponentOnWorkItems to update.
     */
    limit?: number
  }

  /**
   * ComponentOnWorkItem updateManyAndReturn
   */
  export type ComponentOnWorkItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentOnWorkItem
     */
    select?: ComponentOnWorkItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ComponentOnWorkItem
     */
    omit?: ComponentOnWorkItemOmit<ExtArgs> | null
    /**
     * The data used to update ComponentOnWorkItems.
     */
    data: XOR<ComponentOnWorkItemUpdateManyMutationInput, ComponentOnWorkItemUncheckedUpdateManyInput>
    /**
     * Filter which ComponentOnWorkItems to update
     */
    where?: ComponentOnWorkItemWhereInput
    /**
     * Limit how many ComponentOnWorkItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentOnWorkItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ComponentOnWorkItem upsert
   */
  export type ComponentOnWorkItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentOnWorkItem
     */
    select?: ComponentOnWorkItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComponentOnWorkItem
     */
    omit?: ComponentOnWorkItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentOnWorkItemInclude<ExtArgs> | null
    /**
     * The filter to search for the ComponentOnWorkItem to update in case it exists.
     */
    where: ComponentOnWorkItemWhereUniqueInput
    /**
     * In case the ComponentOnWorkItem found by the `where` argument doesn't exist, create a new ComponentOnWorkItem with this data.
     */
    create: XOR<ComponentOnWorkItemCreateInput, ComponentOnWorkItemUncheckedCreateInput>
    /**
     * In case the ComponentOnWorkItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComponentOnWorkItemUpdateInput, ComponentOnWorkItemUncheckedUpdateInput>
  }

  /**
   * ComponentOnWorkItem delete
   */
  export type ComponentOnWorkItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentOnWorkItem
     */
    select?: ComponentOnWorkItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComponentOnWorkItem
     */
    omit?: ComponentOnWorkItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentOnWorkItemInclude<ExtArgs> | null
    /**
     * Filter which ComponentOnWorkItem to delete.
     */
    where: ComponentOnWorkItemWhereUniqueInput
  }

  /**
   * ComponentOnWorkItem deleteMany
   */
  export type ComponentOnWorkItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComponentOnWorkItems to delete
     */
    where?: ComponentOnWorkItemWhereInput
    /**
     * Limit how many ComponentOnWorkItems to delete.
     */
    limit?: number
  }

  /**
   * ComponentOnWorkItem without action
   */
  export type ComponentOnWorkItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentOnWorkItem
     */
    select?: ComponentOnWorkItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComponentOnWorkItem
     */
    omit?: ComponentOnWorkItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentOnWorkItemInclude<ExtArgs> | null
  }


  /**
   * Model Dependency
   */

  export type AggregateDependency = {
    _count: DependencyCountAggregateOutputType | null
    _min: DependencyMinAggregateOutputType | null
    _max: DependencyMaxAggregateOutputType | null
  }

  export type DependencyMinAggregateOutputType = {
    id: string | null
    dependencyType: string | null
    description: string | null
    createdAt: Date | null
    sourceItemId: string | null
    targetItemId: string | null
  }

  export type DependencyMaxAggregateOutputType = {
    id: string | null
    dependencyType: string | null
    description: string | null
    createdAt: Date | null
    sourceItemId: string | null
    targetItemId: string | null
  }

  export type DependencyCountAggregateOutputType = {
    id: number
    dependencyType: number
    description: number
    createdAt: number
    sourceItemId: number
    targetItemId: number
    _all: number
  }


  export type DependencyMinAggregateInputType = {
    id?: true
    dependencyType?: true
    description?: true
    createdAt?: true
    sourceItemId?: true
    targetItemId?: true
  }

  export type DependencyMaxAggregateInputType = {
    id?: true
    dependencyType?: true
    description?: true
    createdAt?: true
    sourceItemId?: true
    targetItemId?: true
  }

  export type DependencyCountAggregateInputType = {
    id?: true
    dependencyType?: true
    description?: true
    createdAt?: true
    sourceItemId?: true
    targetItemId?: true
    _all?: true
  }

  export type DependencyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dependency to aggregate.
     */
    where?: DependencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dependencies to fetch.
     */
    orderBy?: DependencyOrderByWithRelationInput | DependencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DependencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dependencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dependencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Dependencies
    **/
    _count?: true | DependencyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DependencyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DependencyMaxAggregateInputType
  }

  export type GetDependencyAggregateType<T extends DependencyAggregateArgs> = {
        [P in keyof T & keyof AggregateDependency]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDependency[P]>
      : GetScalarType<T[P], AggregateDependency[P]>
  }




  export type DependencyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DependencyWhereInput
    orderBy?: DependencyOrderByWithAggregationInput | DependencyOrderByWithAggregationInput[]
    by: DependencyScalarFieldEnum[] | DependencyScalarFieldEnum
    having?: DependencyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DependencyCountAggregateInputType | true
    _min?: DependencyMinAggregateInputType
    _max?: DependencyMaxAggregateInputType
  }

  export type DependencyGroupByOutputType = {
    id: string
    dependencyType: string
    description: string | null
    createdAt: Date
    sourceItemId: string
    targetItemId: string
    _count: DependencyCountAggregateOutputType | null
    _min: DependencyMinAggregateOutputType | null
    _max: DependencyMaxAggregateOutputType | null
  }

  type GetDependencyGroupByPayload<T extends DependencyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DependencyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DependencyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DependencyGroupByOutputType[P]>
            : GetScalarType<T[P], DependencyGroupByOutputType[P]>
        }
      >
    >


  export type DependencySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dependencyType?: boolean
    description?: boolean
    createdAt?: boolean
    sourceItemId?: boolean
    targetItemId?: boolean
    sourceItem?: boolean | WorkItemDefaultArgs<ExtArgs>
    targetItem?: boolean | WorkItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dependency"]>

  export type DependencySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dependencyType?: boolean
    description?: boolean
    createdAt?: boolean
    sourceItemId?: boolean
    targetItemId?: boolean
    sourceItem?: boolean | WorkItemDefaultArgs<ExtArgs>
    targetItem?: boolean | WorkItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dependency"]>

  export type DependencySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dependencyType?: boolean
    description?: boolean
    createdAt?: boolean
    sourceItemId?: boolean
    targetItemId?: boolean
    sourceItem?: boolean | WorkItemDefaultArgs<ExtArgs>
    targetItem?: boolean | WorkItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dependency"]>

  export type DependencySelectScalar = {
    id?: boolean
    dependencyType?: boolean
    description?: boolean
    createdAt?: boolean
    sourceItemId?: boolean
    targetItemId?: boolean
  }

  export type DependencyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "dependencyType" | "description" | "createdAt" | "sourceItemId" | "targetItemId", ExtArgs["result"]["dependency"]>
  export type DependencyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sourceItem?: boolean | WorkItemDefaultArgs<ExtArgs>
    targetItem?: boolean | WorkItemDefaultArgs<ExtArgs>
  }
  export type DependencyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sourceItem?: boolean | WorkItemDefaultArgs<ExtArgs>
    targetItem?: boolean | WorkItemDefaultArgs<ExtArgs>
  }
  export type DependencyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sourceItem?: boolean | WorkItemDefaultArgs<ExtArgs>
    targetItem?: boolean | WorkItemDefaultArgs<ExtArgs>
  }

  export type $DependencyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Dependency"
    objects: {
      sourceItem: Prisma.$WorkItemPayload<ExtArgs>
      targetItem: Prisma.$WorkItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      dependencyType: string
      description: string | null
      createdAt: Date
      sourceItemId: string
      targetItemId: string
    }, ExtArgs["result"]["dependency"]>
    composites: {}
  }

  type DependencyGetPayload<S extends boolean | null | undefined | DependencyDefaultArgs> = $Result.GetResult<Prisma.$DependencyPayload, S>

  type DependencyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DependencyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DependencyCountAggregateInputType | true
    }

  export interface DependencyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Dependency'], meta: { name: 'Dependency' } }
    /**
     * Find zero or one Dependency that matches the filter.
     * @param {DependencyFindUniqueArgs} args - Arguments to find a Dependency
     * @example
     * // Get one Dependency
     * const dependency = await prisma.dependency.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DependencyFindUniqueArgs>(args: SelectSubset<T, DependencyFindUniqueArgs<ExtArgs>>): Prisma__DependencyClient<$Result.GetResult<Prisma.$DependencyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Dependency that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DependencyFindUniqueOrThrowArgs} args - Arguments to find a Dependency
     * @example
     * // Get one Dependency
     * const dependency = await prisma.dependency.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DependencyFindUniqueOrThrowArgs>(args: SelectSubset<T, DependencyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DependencyClient<$Result.GetResult<Prisma.$DependencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Dependency that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DependencyFindFirstArgs} args - Arguments to find a Dependency
     * @example
     * // Get one Dependency
     * const dependency = await prisma.dependency.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DependencyFindFirstArgs>(args?: SelectSubset<T, DependencyFindFirstArgs<ExtArgs>>): Prisma__DependencyClient<$Result.GetResult<Prisma.$DependencyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Dependency that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DependencyFindFirstOrThrowArgs} args - Arguments to find a Dependency
     * @example
     * // Get one Dependency
     * const dependency = await prisma.dependency.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DependencyFindFirstOrThrowArgs>(args?: SelectSubset<T, DependencyFindFirstOrThrowArgs<ExtArgs>>): Prisma__DependencyClient<$Result.GetResult<Prisma.$DependencyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Dependencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DependencyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Dependencies
     * const dependencies = await prisma.dependency.findMany()
     * 
     * // Get first 10 Dependencies
     * const dependencies = await prisma.dependency.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dependencyWithIdOnly = await prisma.dependency.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DependencyFindManyArgs>(args?: SelectSubset<T, DependencyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DependencyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Dependency.
     * @param {DependencyCreateArgs} args - Arguments to create a Dependency.
     * @example
     * // Create one Dependency
     * const Dependency = await prisma.dependency.create({
     *   data: {
     *     // ... data to create a Dependency
     *   }
     * })
     * 
     */
    create<T extends DependencyCreateArgs>(args: SelectSubset<T, DependencyCreateArgs<ExtArgs>>): Prisma__DependencyClient<$Result.GetResult<Prisma.$DependencyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Dependencies.
     * @param {DependencyCreateManyArgs} args - Arguments to create many Dependencies.
     * @example
     * // Create many Dependencies
     * const dependency = await prisma.dependency.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DependencyCreateManyArgs>(args?: SelectSubset<T, DependencyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Dependencies and returns the data saved in the database.
     * @param {DependencyCreateManyAndReturnArgs} args - Arguments to create many Dependencies.
     * @example
     * // Create many Dependencies
     * const dependency = await prisma.dependency.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Dependencies and only return the `id`
     * const dependencyWithIdOnly = await prisma.dependency.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DependencyCreateManyAndReturnArgs>(args?: SelectSubset<T, DependencyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DependencyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Dependency.
     * @param {DependencyDeleteArgs} args - Arguments to delete one Dependency.
     * @example
     * // Delete one Dependency
     * const Dependency = await prisma.dependency.delete({
     *   where: {
     *     // ... filter to delete one Dependency
     *   }
     * })
     * 
     */
    delete<T extends DependencyDeleteArgs>(args: SelectSubset<T, DependencyDeleteArgs<ExtArgs>>): Prisma__DependencyClient<$Result.GetResult<Prisma.$DependencyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Dependency.
     * @param {DependencyUpdateArgs} args - Arguments to update one Dependency.
     * @example
     * // Update one Dependency
     * const dependency = await prisma.dependency.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DependencyUpdateArgs>(args: SelectSubset<T, DependencyUpdateArgs<ExtArgs>>): Prisma__DependencyClient<$Result.GetResult<Prisma.$DependencyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Dependencies.
     * @param {DependencyDeleteManyArgs} args - Arguments to filter Dependencies to delete.
     * @example
     * // Delete a few Dependencies
     * const { count } = await prisma.dependency.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DependencyDeleteManyArgs>(args?: SelectSubset<T, DependencyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dependencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DependencyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Dependencies
     * const dependency = await prisma.dependency.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DependencyUpdateManyArgs>(args: SelectSubset<T, DependencyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dependencies and returns the data updated in the database.
     * @param {DependencyUpdateManyAndReturnArgs} args - Arguments to update many Dependencies.
     * @example
     * // Update many Dependencies
     * const dependency = await prisma.dependency.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Dependencies and only return the `id`
     * const dependencyWithIdOnly = await prisma.dependency.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DependencyUpdateManyAndReturnArgs>(args: SelectSubset<T, DependencyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DependencyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Dependency.
     * @param {DependencyUpsertArgs} args - Arguments to update or create a Dependency.
     * @example
     * // Update or create a Dependency
     * const dependency = await prisma.dependency.upsert({
     *   create: {
     *     // ... data to create a Dependency
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dependency we want to update
     *   }
     * })
     */
    upsert<T extends DependencyUpsertArgs>(args: SelectSubset<T, DependencyUpsertArgs<ExtArgs>>): Prisma__DependencyClient<$Result.GetResult<Prisma.$DependencyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Dependencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DependencyCountArgs} args - Arguments to filter Dependencies to count.
     * @example
     * // Count the number of Dependencies
     * const count = await prisma.dependency.count({
     *   where: {
     *     // ... the filter for the Dependencies we want to count
     *   }
     * })
    **/
    count<T extends DependencyCountArgs>(
      args?: Subset<T, DependencyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DependencyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dependency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DependencyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DependencyAggregateArgs>(args: Subset<T, DependencyAggregateArgs>): Prisma.PrismaPromise<GetDependencyAggregateType<T>>

    /**
     * Group by Dependency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DependencyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DependencyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DependencyGroupByArgs['orderBy'] }
        : { orderBy?: DependencyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DependencyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDependencyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Dependency model
   */
  readonly fields: DependencyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Dependency.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DependencyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sourceItem<T extends WorkItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkItemDefaultArgs<ExtArgs>>): Prisma__WorkItemClient<$Result.GetResult<Prisma.$WorkItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    targetItem<T extends WorkItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkItemDefaultArgs<ExtArgs>>): Prisma__WorkItemClient<$Result.GetResult<Prisma.$WorkItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Dependency model
   */
  interface DependencyFieldRefs {
    readonly id: FieldRef<"Dependency", 'String'>
    readonly dependencyType: FieldRef<"Dependency", 'String'>
    readonly description: FieldRef<"Dependency", 'String'>
    readonly createdAt: FieldRef<"Dependency", 'DateTime'>
    readonly sourceItemId: FieldRef<"Dependency", 'String'>
    readonly targetItemId: FieldRef<"Dependency", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Dependency findUnique
   */
  export type DependencyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dependency
     */
    select?: DependencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dependency
     */
    omit?: DependencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependencyInclude<ExtArgs> | null
    /**
     * Filter, which Dependency to fetch.
     */
    where: DependencyWhereUniqueInput
  }

  /**
   * Dependency findUniqueOrThrow
   */
  export type DependencyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dependency
     */
    select?: DependencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dependency
     */
    omit?: DependencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependencyInclude<ExtArgs> | null
    /**
     * Filter, which Dependency to fetch.
     */
    where: DependencyWhereUniqueInput
  }

  /**
   * Dependency findFirst
   */
  export type DependencyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dependency
     */
    select?: DependencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dependency
     */
    omit?: DependencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependencyInclude<ExtArgs> | null
    /**
     * Filter, which Dependency to fetch.
     */
    where?: DependencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dependencies to fetch.
     */
    orderBy?: DependencyOrderByWithRelationInput | DependencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dependencies.
     */
    cursor?: DependencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dependencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dependencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dependencies.
     */
    distinct?: DependencyScalarFieldEnum | DependencyScalarFieldEnum[]
  }

  /**
   * Dependency findFirstOrThrow
   */
  export type DependencyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dependency
     */
    select?: DependencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dependency
     */
    omit?: DependencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependencyInclude<ExtArgs> | null
    /**
     * Filter, which Dependency to fetch.
     */
    where?: DependencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dependencies to fetch.
     */
    orderBy?: DependencyOrderByWithRelationInput | DependencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dependencies.
     */
    cursor?: DependencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dependencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dependencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dependencies.
     */
    distinct?: DependencyScalarFieldEnum | DependencyScalarFieldEnum[]
  }

  /**
   * Dependency findMany
   */
  export type DependencyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dependency
     */
    select?: DependencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dependency
     */
    omit?: DependencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependencyInclude<ExtArgs> | null
    /**
     * Filter, which Dependencies to fetch.
     */
    where?: DependencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dependencies to fetch.
     */
    orderBy?: DependencyOrderByWithRelationInput | DependencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Dependencies.
     */
    cursor?: DependencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dependencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dependencies.
     */
    skip?: number
    distinct?: DependencyScalarFieldEnum | DependencyScalarFieldEnum[]
  }

  /**
   * Dependency create
   */
  export type DependencyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dependency
     */
    select?: DependencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dependency
     */
    omit?: DependencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependencyInclude<ExtArgs> | null
    /**
     * The data needed to create a Dependency.
     */
    data: XOR<DependencyCreateInput, DependencyUncheckedCreateInput>
  }

  /**
   * Dependency createMany
   */
  export type DependencyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Dependencies.
     */
    data: DependencyCreateManyInput | DependencyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Dependency createManyAndReturn
   */
  export type DependencyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dependency
     */
    select?: DependencySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Dependency
     */
    omit?: DependencyOmit<ExtArgs> | null
    /**
     * The data used to create many Dependencies.
     */
    data: DependencyCreateManyInput | DependencyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependencyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Dependency update
   */
  export type DependencyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dependency
     */
    select?: DependencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dependency
     */
    omit?: DependencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependencyInclude<ExtArgs> | null
    /**
     * The data needed to update a Dependency.
     */
    data: XOR<DependencyUpdateInput, DependencyUncheckedUpdateInput>
    /**
     * Choose, which Dependency to update.
     */
    where: DependencyWhereUniqueInput
  }

  /**
   * Dependency updateMany
   */
  export type DependencyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Dependencies.
     */
    data: XOR<DependencyUpdateManyMutationInput, DependencyUncheckedUpdateManyInput>
    /**
     * Filter which Dependencies to update
     */
    where?: DependencyWhereInput
    /**
     * Limit how many Dependencies to update.
     */
    limit?: number
  }

  /**
   * Dependency updateManyAndReturn
   */
  export type DependencyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dependency
     */
    select?: DependencySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Dependency
     */
    omit?: DependencyOmit<ExtArgs> | null
    /**
     * The data used to update Dependencies.
     */
    data: XOR<DependencyUpdateManyMutationInput, DependencyUncheckedUpdateManyInput>
    /**
     * Filter which Dependencies to update
     */
    where?: DependencyWhereInput
    /**
     * Limit how many Dependencies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependencyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Dependency upsert
   */
  export type DependencyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dependency
     */
    select?: DependencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dependency
     */
    omit?: DependencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependencyInclude<ExtArgs> | null
    /**
     * The filter to search for the Dependency to update in case it exists.
     */
    where: DependencyWhereUniqueInput
    /**
     * In case the Dependency found by the `where` argument doesn't exist, create a new Dependency with this data.
     */
    create: XOR<DependencyCreateInput, DependencyUncheckedCreateInput>
    /**
     * In case the Dependency was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DependencyUpdateInput, DependencyUncheckedUpdateInput>
  }

  /**
   * Dependency delete
   */
  export type DependencyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dependency
     */
    select?: DependencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dependency
     */
    omit?: DependencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependencyInclude<ExtArgs> | null
    /**
     * Filter which Dependency to delete.
     */
    where: DependencyWhereUniqueInput
  }

  /**
   * Dependency deleteMany
   */
  export type DependencyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dependencies to delete
     */
    where?: DependencyWhereInput
    /**
     * Limit how many Dependencies to delete.
     */
    limit?: number
  }

  /**
   * Dependency without action
   */
  export type DependencyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dependency
     */
    select?: DependencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dependency
     */
    omit?: DependencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DependencyInclude<ExtArgs> | null
  }


  /**
   * Model TimeLog
   */

  export type AggregateTimeLog = {
    _count: TimeLogCountAggregateOutputType | null
    _avg: TimeLogAvgAggregateOutputType | null
    _sum: TimeLogSumAggregateOutputType | null
    _min: TimeLogMinAggregateOutputType | null
    _max: TimeLogMaxAggregateOutputType | null
  }

  export type TimeLogAvgAggregateOutputType = {
    duration: number | null
  }

  export type TimeLogSumAggregateOutputType = {
    duration: number | null
  }

  export type TimeLogMinAggregateOutputType = {
    id: string | null
    duration: number | null
    description: string | null
    billable: boolean | null
    logDate: Date | null
    startedAt: Date | null
    endedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    workItemId: string | null
    userId: string | null
    sprintId: string | null
  }

  export type TimeLogMaxAggregateOutputType = {
    id: string | null
    duration: number | null
    description: string | null
    billable: boolean | null
    logDate: Date | null
    startedAt: Date | null
    endedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    workItemId: string | null
    userId: string | null
    sprintId: string | null
  }

  export type TimeLogCountAggregateOutputType = {
    id: number
    duration: number
    description: number
    billable: number
    logDate: number
    startedAt: number
    endedAt: number
    createdAt: number
    updatedAt: number
    workItemId: number
    userId: number
    sprintId: number
    _all: number
  }


  export type TimeLogAvgAggregateInputType = {
    duration?: true
  }

  export type TimeLogSumAggregateInputType = {
    duration?: true
  }

  export type TimeLogMinAggregateInputType = {
    id?: true
    duration?: true
    description?: true
    billable?: true
    logDate?: true
    startedAt?: true
    endedAt?: true
    createdAt?: true
    updatedAt?: true
    workItemId?: true
    userId?: true
    sprintId?: true
  }

  export type TimeLogMaxAggregateInputType = {
    id?: true
    duration?: true
    description?: true
    billable?: true
    logDate?: true
    startedAt?: true
    endedAt?: true
    createdAt?: true
    updatedAt?: true
    workItemId?: true
    userId?: true
    sprintId?: true
  }

  export type TimeLogCountAggregateInputType = {
    id?: true
    duration?: true
    description?: true
    billable?: true
    logDate?: true
    startedAt?: true
    endedAt?: true
    createdAt?: true
    updatedAt?: true
    workItemId?: true
    userId?: true
    sprintId?: true
    _all?: true
  }

  export type TimeLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimeLog to aggregate.
     */
    where?: TimeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeLogs to fetch.
     */
    orderBy?: TimeLogOrderByWithRelationInput | TimeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TimeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TimeLogs
    **/
    _count?: true | TimeLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TimeLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TimeLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TimeLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TimeLogMaxAggregateInputType
  }

  export type GetTimeLogAggregateType<T extends TimeLogAggregateArgs> = {
        [P in keyof T & keyof AggregateTimeLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTimeLog[P]>
      : GetScalarType<T[P], AggregateTimeLog[P]>
  }




  export type TimeLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeLogWhereInput
    orderBy?: TimeLogOrderByWithAggregationInput | TimeLogOrderByWithAggregationInput[]
    by: TimeLogScalarFieldEnum[] | TimeLogScalarFieldEnum
    having?: TimeLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TimeLogCountAggregateInputType | true
    _avg?: TimeLogAvgAggregateInputType
    _sum?: TimeLogSumAggregateInputType
    _min?: TimeLogMinAggregateInputType
    _max?: TimeLogMaxAggregateInputType
  }

  export type TimeLogGroupByOutputType = {
    id: string
    duration: number
    description: string | null
    billable: boolean
    logDate: Date
    startedAt: Date | null
    endedAt: Date | null
    createdAt: Date
    updatedAt: Date
    workItemId: string
    userId: string
    sprintId: string | null
    _count: TimeLogCountAggregateOutputType | null
    _avg: TimeLogAvgAggregateOutputType | null
    _sum: TimeLogSumAggregateOutputType | null
    _min: TimeLogMinAggregateOutputType | null
    _max: TimeLogMaxAggregateOutputType | null
  }

  type GetTimeLogGroupByPayload<T extends TimeLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TimeLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TimeLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TimeLogGroupByOutputType[P]>
            : GetScalarType<T[P], TimeLogGroupByOutputType[P]>
        }
      >
    >


  export type TimeLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    duration?: boolean
    description?: boolean
    billable?: boolean
    logDate?: boolean
    startedAt?: boolean
    endedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workItemId?: boolean
    userId?: boolean
    sprintId?: boolean
    workItem?: boolean | WorkItemDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    sprint?: boolean | TimeLog$sprintArgs<ExtArgs>
  }, ExtArgs["result"]["timeLog"]>

  export type TimeLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    duration?: boolean
    description?: boolean
    billable?: boolean
    logDate?: boolean
    startedAt?: boolean
    endedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workItemId?: boolean
    userId?: boolean
    sprintId?: boolean
    workItem?: boolean | WorkItemDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    sprint?: boolean | TimeLog$sprintArgs<ExtArgs>
  }, ExtArgs["result"]["timeLog"]>

  export type TimeLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    duration?: boolean
    description?: boolean
    billable?: boolean
    logDate?: boolean
    startedAt?: boolean
    endedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workItemId?: boolean
    userId?: boolean
    sprintId?: boolean
    workItem?: boolean | WorkItemDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    sprint?: boolean | TimeLog$sprintArgs<ExtArgs>
  }, ExtArgs["result"]["timeLog"]>

  export type TimeLogSelectScalar = {
    id?: boolean
    duration?: boolean
    description?: boolean
    billable?: boolean
    logDate?: boolean
    startedAt?: boolean
    endedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workItemId?: boolean
    userId?: boolean
    sprintId?: boolean
  }

  export type TimeLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "duration" | "description" | "billable" | "logDate" | "startedAt" | "endedAt" | "createdAt" | "updatedAt" | "workItemId" | "userId" | "sprintId", ExtArgs["result"]["timeLog"]>
  export type TimeLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workItem?: boolean | WorkItemDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    sprint?: boolean | TimeLog$sprintArgs<ExtArgs>
  }
  export type TimeLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workItem?: boolean | WorkItemDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    sprint?: boolean | TimeLog$sprintArgs<ExtArgs>
  }
  export type TimeLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workItem?: boolean | WorkItemDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    sprint?: boolean | TimeLog$sprintArgs<ExtArgs>
  }

  export type $TimeLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TimeLog"
    objects: {
      workItem: Prisma.$WorkItemPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      sprint: Prisma.$SprintPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      duration: number
      description: string | null
      billable: boolean
      logDate: Date
      startedAt: Date | null
      endedAt: Date | null
      createdAt: Date
      updatedAt: Date
      workItemId: string
      userId: string
      sprintId: string | null
    }, ExtArgs["result"]["timeLog"]>
    composites: {}
  }

  type TimeLogGetPayload<S extends boolean | null | undefined | TimeLogDefaultArgs> = $Result.GetResult<Prisma.$TimeLogPayload, S>

  type TimeLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TimeLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TimeLogCountAggregateInputType | true
    }

  export interface TimeLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TimeLog'], meta: { name: 'TimeLog' } }
    /**
     * Find zero or one TimeLog that matches the filter.
     * @param {TimeLogFindUniqueArgs} args - Arguments to find a TimeLog
     * @example
     * // Get one TimeLog
     * const timeLog = await prisma.timeLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TimeLogFindUniqueArgs>(args: SelectSubset<T, TimeLogFindUniqueArgs<ExtArgs>>): Prisma__TimeLogClient<$Result.GetResult<Prisma.$TimeLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TimeLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TimeLogFindUniqueOrThrowArgs} args - Arguments to find a TimeLog
     * @example
     * // Get one TimeLog
     * const timeLog = await prisma.timeLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TimeLogFindUniqueOrThrowArgs>(args: SelectSubset<T, TimeLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TimeLogClient<$Result.GetResult<Prisma.$TimeLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TimeLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeLogFindFirstArgs} args - Arguments to find a TimeLog
     * @example
     * // Get one TimeLog
     * const timeLog = await prisma.timeLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TimeLogFindFirstArgs>(args?: SelectSubset<T, TimeLogFindFirstArgs<ExtArgs>>): Prisma__TimeLogClient<$Result.GetResult<Prisma.$TimeLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TimeLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeLogFindFirstOrThrowArgs} args - Arguments to find a TimeLog
     * @example
     * // Get one TimeLog
     * const timeLog = await prisma.timeLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TimeLogFindFirstOrThrowArgs>(args?: SelectSubset<T, TimeLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__TimeLogClient<$Result.GetResult<Prisma.$TimeLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TimeLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TimeLogs
     * const timeLogs = await prisma.timeLog.findMany()
     * 
     * // Get first 10 TimeLogs
     * const timeLogs = await prisma.timeLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const timeLogWithIdOnly = await prisma.timeLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TimeLogFindManyArgs>(args?: SelectSubset<T, TimeLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TimeLog.
     * @param {TimeLogCreateArgs} args - Arguments to create a TimeLog.
     * @example
     * // Create one TimeLog
     * const TimeLog = await prisma.timeLog.create({
     *   data: {
     *     // ... data to create a TimeLog
     *   }
     * })
     * 
     */
    create<T extends TimeLogCreateArgs>(args: SelectSubset<T, TimeLogCreateArgs<ExtArgs>>): Prisma__TimeLogClient<$Result.GetResult<Prisma.$TimeLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TimeLogs.
     * @param {TimeLogCreateManyArgs} args - Arguments to create many TimeLogs.
     * @example
     * // Create many TimeLogs
     * const timeLog = await prisma.timeLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TimeLogCreateManyArgs>(args?: SelectSubset<T, TimeLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TimeLogs and returns the data saved in the database.
     * @param {TimeLogCreateManyAndReturnArgs} args - Arguments to create many TimeLogs.
     * @example
     * // Create many TimeLogs
     * const timeLog = await prisma.timeLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TimeLogs and only return the `id`
     * const timeLogWithIdOnly = await prisma.timeLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TimeLogCreateManyAndReturnArgs>(args?: SelectSubset<T, TimeLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TimeLog.
     * @param {TimeLogDeleteArgs} args - Arguments to delete one TimeLog.
     * @example
     * // Delete one TimeLog
     * const TimeLog = await prisma.timeLog.delete({
     *   where: {
     *     // ... filter to delete one TimeLog
     *   }
     * })
     * 
     */
    delete<T extends TimeLogDeleteArgs>(args: SelectSubset<T, TimeLogDeleteArgs<ExtArgs>>): Prisma__TimeLogClient<$Result.GetResult<Prisma.$TimeLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TimeLog.
     * @param {TimeLogUpdateArgs} args - Arguments to update one TimeLog.
     * @example
     * // Update one TimeLog
     * const timeLog = await prisma.timeLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TimeLogUpdateArgs>(args: SelectSubset<T, TimeLogUpdateArgs<ExtArgs>>): Prisma__TimeLogClient<$Result.GetResult<Prisma.$TimeLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TimeLogs.
     * @param {TimeLogDeleteManyArgs} args - Arguments to filter TimeLogs to delete.
     * @example
     * // Delete a few TimeLogs
     * const { count } = await prisma.timeLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TimeLogDeleteManyArgs>(args?: SelectSubset<T, TimeLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TimeLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TimeLogs
     * const timeLog = await prisma.timeLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TimeLogUpdateManyArgs>(args: SelectSubset<T, TimeLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TimeLogs and returns the data updated in the database.
     * @param {TimeLogUpdateManyAndReturnArgs} args - Arguments to update many TimeLogs.
     * @example
     * // Update many TimeLogs
     * const timeLog = await prisma.timeLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TimeLogs and only return the `id`
     * const timeLogWithIdOnly = await prisma.timeLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TimeLogUpdateManyAndReturnArgs>(args: SelectSubset<T, TimeLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TimeLog.
     * @param {TimeLogUpsertArgs} args - Arguments to update or create a TimeLog.
     * @example
     * // Update or create a TimeLog
     * const timeLog = await prisma.timeLog.upsert({
     *   create: {
     *     // ... data to create a TimeLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TimeLog we want to update
     *   }
     * })
     */
    upsert<T extends TimeLogUpsertArgs>(args: SelectSubset<T, TimeLogUpsertArgs<ExtArgs>>): Prisma__TimeLogClient<$Result.GetResult<Prisma.$TimeLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TimeLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeLogCountArgs} args - Arguments to filter TimeLogs to count.
     * @example
     * // Count the number of TimeLogs
     * const count = await prisma.timeLog.count({
     *   where: {
     *     // ... the filter for the TimeLogs we want to count
     *   }
     * })
    **/
    count<T extends TimeLogCountArgs>(
      args?: Subset<T, TimeLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TimeLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TimeLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TimeLogAggregateArgs>(args: Subset<T, TimeLogAggregateArgs>): Prisma.PrismaPromise<GetTimeLogAggregateType<T>>

    /**
     * Group by TimeLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TimeLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TimeLogGroupByArgs['orderBy'] }
        : { orderBy?: TimeLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TimeLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTimeLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TimeLog model
   */
  readonly fields: TimeLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TimeLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TimeLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workItem<T extends WorkItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkItemDefaultArgs<ExtArgs>>): Prisma__WorkItemClient<$Result.GetResult<Prisma.$WorkItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sprint<T extends TimeLog$sprintArgs<ExtArgs> = {}>(args?: Subset<T, TimeLog$sprintArgs<ExtArgs>>): Prisma__SprintClient<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TimeLog model
   */
  interface TimeLogFieldRefs {
    readonly id: FieldRef<"TimeLog", 'String'>
    readonly duration: FieldRef<"TimeLog", 'Int'>
    readonly description: FieldRef<"TimeLog", 'String'>
    readonly billable: FieldRef<"TimeLog", 'Boolean'>
    readonly logDate: FieldRef<"TimeLog", 'DateTime'>
    readonly startedAt: FieldRef<"TimeLog", 'DateTime'>
    readonly endedAt: FieldRef<"TimeLog", 'DateTime'>
    readonly createdAt: FieldRef<"TimeLog", 'DateTime'>
    readonly updatedAt: FieldRef<"TimeLog", 'DateTime'>
    readonly workItemId: FieldRef<"TimeLog", 'String'>
    readonly userId: FieldRef<"TimeLog", 'String'>
    readonly sprintId: FieldRef<"TimeLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TimeLog findUnique
   */
  export type TimeLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeLog
     */
    select?: TimeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeLog
     */
    omit?: TimeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeLogInclude<ExtArgs> | null
    /**
     * Filter, which TimeLog to fetch.
     */
    where: TimeLogWhereUniqueInput
  }

  /**
   * TimeLog findUniqueOrThrow
   */
  export type TimeLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeLog
     */
    select?: TimeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeLog
     */
    omit?: TimeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeLogInclude<ExtArgs> | null
    /**
     * Filter, which TimeLog to fetch.
     */
    where: TimeLogWhereUniqueInput
  }

  /**
   * TimeLog findFirst
   */
  export type TimeLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeLog
     */
    select?: TimeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeLog
     */
    omit?: TimeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeLogInclude<ExtArgs> | null
    /**
     * Filter, which TimeLog to fetch.
     */
    where?: TimeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeLogs to fetch.
     */
    orderBy?: TimeLogOrderByWithRelationInput | TimeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimeLogs.
     */
    cursor?: TimeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimeLogs.
     */
    distinct?: TimeLogScalarFieldEnum | TimeLogScalarFieldEnum[]
  }

  /**
   * TimeLog findFirstOrThrow
   */
  export type TimeLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeLog
     */
    select?: TimeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeLog
     */
    omit?: TimeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeLogInclude<ExtArgs> | null
    /**
     * Filter, which TimeLog to fetch.
     */
    where?: TimeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeLogs to fetch.
     */
    orderBy?: TimeLogOrderByWithRelationInput | TimeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimeLogs.
     */
    cursor?: TimeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimeLogs.
     */
    distinct?: TimeLogScalarFieldEnum | TimeLogScalarFieldEnum[]
  }

  /**
   * TimeLog findMany
   */
  export type TimeLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeLog
     */
    select?: TimeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeLog
     */
    omit?: TimeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeLogInclude<ExtArgs> | null
    /**
     * Filter, which TimeLogs to fetch.
     */
    where?: TimeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeLogs to fetch.
     */
    orderBy?: TimeLogOrderByWithRelationInput | TimeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TimeLogs.
     */
    cursor?: TimeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeLogs.
     */
    skip?: number
    distinct?: TimeLogScalarFieldEnum | TimeLogScalarFieldEnum[]
  }

  /**
   * TimeLog create
   */
  export type TimeLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeLog
     */
    select?: TimeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeLog
     */
    omit?: TimeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeLogInclude<ExtArgs> | null
    /**
     * The data needed to create a TimeLog.
     */
    data: XOR<TimeLogCreateInput, TimeLogUncheckedCreateInput>
  }

  /**
   * TimeLog createMany
   */
  export type TimeLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TimeLogs.
     */
    data: TimeLogCreateManyInput | TimeLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TimeLog createManyAndReturn
   */
  export type TimeLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeLog
     */
    select?: TimeLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TimeLog
     */
    omit?: TimeLogOmit<ExtArgs> | null
    /**
     * The data used to create many TimeLogs.
     */
    data: TimeLogCreateManyInput | TimeLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TimeLog update
   */
  export type TimeLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeLog
     */
    select?: TimeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeLog
     */
    omit?: TimeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeLogInclude<ExtArgs> | null
    /**
     * The data needed to update a TimeLog.
     */
    data: XOR<TimeLogUpdateInput, TimeLogUncheckedUpdateInput>
    /**
     * Choose, which TimeLog to update.
     */
    where: TimeLogWhereUniqueInput
  }

  /**
   * TimeLog updateMany
   */
  export type TimeLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TimeLogs.
     */
    data: XOR<TimeLogUpdateManyMutationInput, TimeLogUncheckedUpdateManyInput>
    /**
     * Filter which TimeLogs to update
     */
    where?: TimeLogWhereInput
    /**
     * Limit how many TimeLogs to update.
     */
    limit?: number
  }

  /**
   * TimeLog updateManyAndReturn
   */
  export type TimeLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeLog
     */
    select?: TimeLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TimeLog
     */
    omit?: TimeLogOmit<ExtArgs> | null
    /**
     * The data used to update TimeLogs.
     */
    data: XOR<TimeLogUpdateManyMutationInput, TimeLogUncheckedUpdateManyInput>
    /**
     * Filter which TimeLogs to update
     */
    where?: TimeLogWhereInput
    /**
     * Limit how many TimeLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TimeLog upsert
   */
  export type TimeLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeLog
     */
    select?: TimeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeLog
     */
    omit?: TimeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeLogInclude<ExtArgs> | null
    /**
     * The filter to search for the TimeLog to update in case it exists.
     */
    where: TimeLogWhereUniqueInput
    /**
     * In case the TimeLog found by the `where` argument doesn't exist, create a new TimeLog with this data.
     */
    create: XOR<TimeLogCreateInput, TimeLogUncheckedCreateInput>
    /**
     * In case the TimeLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TimeLogUpdateInput, TimeLogUncheckedUpdateInput>
  }

  /**
   * TimeLog delete
   */
  export type TimeLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeLog
     */
    select?: TimeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeLog
     */
    omit?: TimeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeLogInclude<ExtArgs> | null
    /**
     * Filter which TimeLog to delete.
     */
    where: TimeLogWhereUniqueInput
  }

  /**
   * TimeLog deleteMany
   */
  export type TimeLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimeLogs to delete
     */
    where?: TimeLogWhereInput
    /**
     * Limit how many TimeLogs to delete.
     */
    limit?: number
  }

  /**
   * TimeLog.sprint
   */
  export type TimeLog$sprintArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    where?: SprintWhereInput
  }

  /**
   * TimeLog without action
   */
  export type TimeLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeLog
     */
    select?: TimeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeLog
     */
    omit?: TimeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeLogInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentAvgAggregateOutputType = {
    sentimentScore: number | null
  }

  export type CommentSumAggregateOutputType = {
    sentimentScore: number | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    body: string | null
    sentimentScore: number | null
    sentimentLabel: string | null
    isInternal: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    workItemId: string | null
    userId: string | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    body: string | null
    sentimentScore: number | null
    sentimentLabel: string | null
    isInternal: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    workItemId: string | null
    userId: string | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    body: number
    sentimentScore: number
    sentimentLabel: number
    isInternal: number
    createdAt: number
    updatedAt: number
    workItemId: number
    userId: number
    _all: number
  }


  export type CommentAvgAggregateInputType = {
    sentimentScore?: true
  }

  export type CommentSumAggregateInputType = {
    sentimentScore?: true
  }

  export type CommentMinAggregateInputType = {
    id?: true
    body?: true
    sentimentScore?: true
    sentimentLabel?: true
    isInternal?: true
    createdAt?: true
    updatedAt?: true
    workItemId?: true
    userId?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    body?: true
    sentimentScore?: true
    sentimentLabel?: true
    isInternal?: true
    createdAt?: true
    updatedAt?: true
    workItemId?: true
    userId?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    body?: true
    sentimentScore?: true
    sentimentLabel?: true
    isInternal?: true
    createdAt?: true
    updatedAt?: true
    workItemId?: true
    userId?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _avg?: CommentAvgAggregateInputType
    _sum?: CommentSumAggregateInputType
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: string
    body: string
    sentimentScore: number | null
    sentimentLabel: string | null
    isInternal: boolean
    createdAt: Date
    updatedAt: Date
    workItemId: string
    userId: string
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    body?: boolean
    sentimentScore?: boolean
    sentimentLabel?: boolean
    isInternal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workItemId?: boolean
    userId?: boolean
    workItem?: boolean | WorkItemDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    body?: boolean
    sentimentScore?: boolean
    sentimentLabel?: boolean
    isInternal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workItemId?: boolean
    userId?: boolean
    workItem?: boolean | WorkItemDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    body?: boolean
    sentimentScore?: boolean
    sentimentLabel?: boolean
    isInternal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workItemId?: boolean
    userId?: boolean
    workItem?: boolean | WorkItemDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    body?: boolean
    sentimentScore?: boolean
    sentimentLabel?: boolean
    isInternal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workItemId?: boolean
    userId?: boolean
  }

  export type CommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "body" | "sentimentScore" | "sentimentLabel" | "isInternal" | "createdAt" | "updatedAt" | "workItemId" | "userId", ExtArgs["result"]["comment"]>
  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workItem?: boolean | WorkItemDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workItem?: boolean | WorkItemDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workItem?: boolean | WorkItemDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      workItem: Prisma.$WorkItemPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      body: string
      sentimentScore: number | null
      sentimentLabel: string | null
      isInternal: boolean
      createdAt: Date
      updatedAt: Date
      workItemId: string
      userId: string
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments and returns the data updated in the database.
     * @param {CommentUpdateManyAndReturnArgs} args - Arguments to update many Comments.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommentUpdateManyAndReturnArgs>(args: SelectSubset<T, CommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workItem<T extends WorkItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkItemDefaultArgs<ExtArgs>>): Prisma__WorkItemClient<$Result.GetResult<Prisma.$WorkItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'String'>
    readonly body: FieldRef<"Comment", 'String'>
    readonly sentimentScore: FieldRef<"Comment", 'Float'>
    readonly sentimentLabel: FieldRef<"Comment", 'String'>
    readonly isInternal: FieldRef<"Comment", 'Boolean'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
    readonly updatedAt: FieldRef<"Comment", 'DateTime'>
    readonly workItemId: FieldRef<"Comment", 'String'>
    readonly userId: FieldRef<"Comment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
  }

  /**
   * Comment updateManyAndReturn
   */
  export type CommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to delete.
     */
    limit?: number
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model Attachment
   */

  export type AggregateAttachment = {
    _count: AttachmentCountAggregateOutputType | null
    _avg: AttachmentAvgAggregateOutputType | null
    _sum: AttachmentSumAggregateOutputType | null
    _min: AttachmentMinAggregateOutputType | null
    _max: AttachmentMaxAggregateOutputType | null
  }

  export type AttachmentAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type AttachmentSumAggregateOutputType = {
    fileSize: number | null
  }

  export type AttachmentMinAggregateOutputType = {
    id: string | null
    fileName: string | null
    fileType: string | null
    fileSize: number | null
    storagePath: string | null
    fileUrl: string | null
    ocrContent: string | null
    createdAt: Date | null
    workItemId: string | null
    uploadedBy: string | null
  }

  export type AttachmentMaxAggregateOutputType = {
    id: string | null
    fileName: string | null
    fileType: string | null
    fileSize: number | null
    storagePath: string | null
    fileUrl: string | null
    ocrContent: string | null
    createdAt: Date | null
    workItemId: string | null
    uploadedBy: string | null
  }

  export type AttachmentCountAggregateOutputType = {
    id: number
    fileName: number
    fileType: number
    fileSize: number
    storagePath: number
    fileUrl: number
    ocrContent: number
    metadata: number
    createdAt: number
    workItemId: number
    uploadedBy: number
    _all: number
  }


  export type AttachmentAvgAggregateInputType = {
    fileSize?: true
  }

  export type AttachmentSumAggregateInputType = {
    fileSize?: true
  }

  export type AttachmentMinAggregateInputType = {
    id?: true
    fileName?: true
    fileType?: true
    fileSize?: true
    storagePath?: true
    fileUrl?: true
    ocrContent?: true
    createdAt?: true
    workItemId?: true
    uploadedBy?: true
  }

  export type AttachmentMaxAggregateInputType = {
    id?: true
    fileName?: true
    fileType?: true
    fileSize?: true
    storagePath?: true
    fileUrl?: true
    ocrContent?: true
    createdAt?: true
    workItemId?: true
    uploadedBy?: true
  }

  export type AttachmentCountAggregateInputType = {
    id?: true
    fileName?: true
    fileType?: true
    fileSize?: true
    storagePath?: true
    fileUrl?: true
    ocrContent?: true
    metadata?: true
    createdAt?: true
    workItemId?: true
    uploadedBy?: true
    _all?: true
  }

  export type AttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attachment to aggregate.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attachments
    **/
    _count?: true | AttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttachmentMaxAggregateInputType
  }

  export type GetAttachmentAggregateType<T extends AttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttachment[P]>
      : GetScalarType<T[P], AggregateAttachment[P]>
  }




  export type AttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttachmentWhereInput
    orderBy?: AttachmentOrderByWithAggregationInput | AttachmentOrderByWithAggregationInput[]
    by: AttachmentScalarFieldEnum[] | AttachmentScalarFieldEnum
    having?: AttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttachmentCountAggregateInputType | true
    _avg?: AttachmentAvgAggregateInputType
    _sum?: AttachmentSumAggregateInputType
    _min?: AttachmentMinAggregateInputType
    _max?: AttachmentMaxAggregateInputType
  }

  export type AttachmentGroupByOutputType = {
    id: string
    fileName: string
    fileType: string
    fileSize: number
    storagePath: string
    fileUrl: string
    ocrContent: string | null
    metadata: JsonValue
    createdAt: Date
    workItemId: string
    uploadedBy: string
    _count: AttachmentCountAggregateOutputType | null
    _avg: AttachmentAvgAggregateOutputType | null
    _sum: AttachmentSumAggregateOutputType | null
    _min: AttachmentMinAggregateOutputType | null
    _max: AttachmentMaxAggregateOutputType | null
  }

  type GetAttachmentGroupByPayload<T extends AttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], AttachmentGroupByOutputType[P]>
        }
      >
    >


  export type AttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fileName?: boolean
    fileType?: boolean
    fileSize?: boolean
    storagePath?: boolean
    fileUrl?: boolean
    ocrContent?: boolean
    metadata?: boolean
    createdAt?: boolean
    workItemId?: boolean
    uploadedBy?: boolean
    workItem?: boolean | WorkItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attachment"]>

  export type AttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fileName?: boolean
    fileType?: boolean
    fileSize?: boolean
    storagePath?: boolean
    fileUrl?: boolean
    ocrContent?: boolean
    metadata?: boolean
    createdAt?: boolean
    workItemId?: boolean
    uploadedBy?: boolean
    workItem?: boolean | WorkItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attachment"]>

  export type AttachmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fileName?: boolean
    fileType?: boolean
    fileSize?: boolean
    storagePath?: boolean
    fileUrl?: boolean
    ocrContent?: boolean
    metadata?: boolean
    createdAt?: boolean
    workItemId?: boolean
    uploadedBy?: boolean
    workItem?: boolean | WorkItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attachment"]>

  export type AttachmentSelectScalar = {
    id?: boolean
    fileName?: boolean
    fileType?: boolean
    fileSize?: boolean
    storagePath?: boolean
    fileUrl?: boolean
    ocrContent?: boolean
    metadata?: boolean
    createdAt?: boolean
    workItemId?: boolean
    uploadedBy?: boolean
  }

  export type AttachmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fileName" | "fileType" | "fileSize" | "storagePath" | "fileUrl" | "ocrContent" | "metadata" | "createdAt" | "workItemId" | "uploadedBy", ExtArgs["result"]["attachment"]>
  export type AttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workItem?: boolean | WorkItemDefaultArgs<ExtArgs>
  }
  export type AttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workItem?: boolean | WorkItemDefaultArgs<ExtArgs>
  }
  export type AttachmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workItem?: boolean | WorkItemDefaultArgs<ExtArgs>
  }

  export type $AttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Attachment"
    objects: {
      workItem: Prisma.$WorkItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fileName: string
      fileType: string
      fileSize: number
      storagePath: string
      fileUrl: string
      ocrContent: string | null
      metadata: Prisma.JsonValue
      createdAt: Date
      workItemId: string
      uploadedBy: string
    }, ExtArgs["result"]["attachment"]>
    composites: {}
  }

  type AttachmentGetPayload<S extends boolean | null | undefined | AttachmentDefaultArgs> = $Result.GetResult<Prisma.$AttachmentPayload, S>

  type AttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttachmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttachmentCountAggregateInputType | true
    }

  export interface AttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Attachment'], meta: { name: 'Attachment' } }
    /**
     * Find zero or one Attachment that matches the filter.
     * @param {AttachmentFindUniqueArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttachmentFindUniqueArgs>(args: SelectSubset<T, AttachmentFindUniqueArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Attachment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttachmentFindUniqueOrThrowArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentFindFirstArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttachmentFindFirstArgs>(args?: SelectSubset<T, AttachmentFindFirstArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentFindFirstOrThrowArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attachments
     * const attachments = await prisma.attachment.findMany()
     * 
     * // Get first 10 Attachments
     * const attachments = await prisma.attachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attachmentWithIdOnly = await prisma.attachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttachmentFindManyArgs>(args?: SelectSubset<T, AttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Attachment.
     * @param {AttachmentCreateArgs} args - Arguments to create a Attachment.
     * @example
     * // Create one Attachment
     * const Attachment = await prisma.attachment.create({
     *   data: {
     *     // ... data to create a Attachment
     *   }
     * })
     * 
     */
    create<T extends AttachmentCreateArgs>(args: SelectSubset<T, AttachmentCreateArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Attachments.
     * @param {AttachmentCreateManyArgs} args - Arguments to create many Attachments.
     * @example
     * // Create many Attachments
     * const attachment = await prisma.attachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttachmentCreateManyArgs>(args?: SelectSubset<T, AttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Attachments and returns the data saved in the database.
     * @param {AttachmentCreateManyAndReturnArgs} args - Arguments to create many Attachments.
     * @example
     * // Create many Attachments
     * const attachment = await prisma.attachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Attachments and only return the `id`
     * const attachmentWithIdOnly = await prisma.attachment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Attachment.
     * @param {AttachmentDeleteArgs} args - Arguments to delete one Attachment.
     * @example
     * // Delete one Attachment
     * const Attachment = await prisma.attachment.delete({
     *   where: {
     *     // ... filter to delete one Attachment
     *   }
     * })
     * 
     */
    delete<T extends AttachmentDeleteArgs>(args: SelectSubset<T, AttachmentDeleteArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Attachment.
     * @param {AttachmentUpdateArgs} args - Arguments to update one Attachment.
     * @example
     * // Update one Attachment
     * const attachment = await prisma.attachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttachmentUpdateArgs>(args: SelectSubset<T, AttachmentUpdateArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Attachments.
     * @param {AttachmentDeleteManyArgs} args - Arguments to filter Attachments to delete.
     * @example
     * // Delete a few Attachments
     * const { count } = await prisma.attachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttachmentDeleteManyArgs>(args?: SelectSubset<T, AttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attachments
     * const attachment = await prisma.attachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttachmentUpdateManyArgs>(args: SelectSubset<T, AttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attachments and returns the data updated in the database.
     * @param {AttachmentUpdateManyAndReturnArgs} args - Arguments to update many Attachments.
     * @example
     * // Update many Attachments
     * const attachment = await prisma.attachment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Attachments and only return the `id`
     * const attachmentWithIdOnly = await prisma.attachment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttachmentUpdateManyAndReturnArgs>(args: SelectSubset<T, AttachmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Attachment.
     * @param {AttachmentUpsertArgs} args - Arguments to update or create a Attachment.
     * @example
     * // Update or create a Attachment
     * const attachment = await prisma.attachment.upsert({
     *   create: {
     *     // ... data to create a Attachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attachment we want to update
     *   }
     * })
     */
    upsert<T extends AttachmentUpsertArgs>(args: SelectSubset<T, AttachmentUpsertArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentCountArgs} args - Arguments to filter Attachments to count.
     * @example
     * // Count the number of Attachments
     * const count = await prisma.attachment.count({
     *   where: {
     *     // ... the filter for the Attachments we want to count
     *   }
     * })
    **/
    count<T extends AttachmentCountArgs>(
      args?: Subset<T, AttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttachmentAggregateArgs>(args: Subset<T, AttachmentAggregateArgs>): Prisma.PrismaPromise<GetAttachmentAggregateType<T>>

    /**
     * Group by Attachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttachmentGroupByArgs['orderBy'] }
        : { orderBy?: AttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Attachment model
   */
  readonly fields: AttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workItem<T extends WorkItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkItemDefaultArgs<ExtArgs>>): Prisma__WorkItemClient<$Result.GetResult<Prisma.$WorkItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Attachment model
   */
  interface AttachmentFieldRefs {
    readonly id: FieldRef<"Attachment", 'String'>
    readonly fileName: FieldRef<"Attachment", 'String'>
    readonly fileType: FieldRef<"Attachment", 'String'>
    readonly fileSize: FieldRef<"Attachment", 'Int'>
    readonly storagePath: FieldRef<"Attachment", 'String'>
    readonly fileUrl: FieldRef<"Attachment", 'String'>
    readonly ocrContent: FieldRef<"Attachment", 'String'>
    readonly metadata: FieldRef<"Attachment", 'Json'>
    readonly createdAt: FieldRef<"Attachment", 'DateTime'>
    readonly workItemId: FieldRef<"Attachment", 'String'>
    readonly uploadedBy: FieldRef<"Attachment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Attachment findUnique
   */
  export type AttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment findUniqueOrThrow
   */
  export type AttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment findFirst
   */
  export type AttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attachments.
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attachments.
     */
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Attachment findFirstOrThrow
   */
  export type AttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attachments.
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attachments.
     */
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Attachment findMany
   */
  export type AttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachments to fetch.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attachments.
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Attachment create
   */
  export type AttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Attachment.
     */
    data: XOR<AttachmentCreateInput, AttachmentUncheckedCreateInput>
  }

  /**
   * Attachment createMany
   */
  export type AttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Attachments.
     */
    data: AttachmentCreateManyInput | AttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Attachment createManyAndReturn
   */
  export type AttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * The data used to create many Attachments.
     */
    data: AttachmentCreateManyInput | AttachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attachment update
   */
  export type AttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Attachment.
     */
    data: XOR<AttachmentUpdateInput, AttachmentUncheckedUpdateInput>
    /**
     * Choose, which Attachment to update.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment updateMany
   */
  export type AttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Attachments.
     */
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyInput>
    /**
     * Filter which Attachments to update
     */
    where?: AttachmentWhereInput
    /**
     * Limit how many Attachments to update.
     */
    limit?: number
  }

  /**
   * Attachment updateManyAndReturn
   */
  export type AttachmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * The data used to update Attachments.
     */
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyInput>
    /**
     * Filter which Attachments to update
     */
    where?: AttachmentWhereInput
    /**
     * Limit how many Attachments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attachment upsert
   */
  export type AttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Attachment to update in case it exists.
     */
    where: AttachmentWhereUniqueInput
    /**
     * In case the Attachment found by the `where` argument doesn't exist, create a new Attachment with this data.
     */
    create: XOR<AttachmentCreateInput, AttachmentUncheckedCreateInput>
    /**
     * In case the Attachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttachmentUpdateInput, AttachmentUncheckedUpdateInput>
  }

  /**
   * Attachment delete
   */
  export type AttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter which Attachment to delete.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment deleteMany
   */
  export type AttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attachments to delete
     */
    where?: AttachmentWhereInput
    /**
     * Limit how many Attachments to delete.
     */
    limit?: number
  }

  /**
   * Attachment without action
   */
  export type AttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
  }


  /**
   * Model WorkItemEmbedding
   */

  export type AggregateWorkItemEmbedding = {
    _count: WorkItemEmbeddingCountAggregateOutputType | null
    _avg: WorkItemEmbeddingAvgAggregateOutputType | null
    _sum: WorkItemEmbeddingSumAggregateOutputType | null
    _min: WorkItemEmbeddingMinAggregateOutputType | null
    _max: WorkItemEmbeddingMaxAggregateOutputType | null
  }

  export type WorkItemEmbeddingAvgAggregateOutputType = {
    version: number | null
  }

  export type WorkItemEmbeddingSumAggregateOutputType = {
    version: number | null
  }

  export type WorkItemEmbeddingMinAggregateOutputType = {
    workItemId: string | null
    version: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkItemEmbeddingMaxAggregateOutputType = {
    workItemId: string | null
    version: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkItemEmbeddingCountAggregateOutputType = {
    workItemId: number
    version: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorkItemEmbeddingAvgAggregateInputType = {
    version?: true
  }

  export type WorkItemEmbeddingSumAggregateInputType = {
    version?: true
  }

  export type WorkItemEmbeddingMinAggregateInputType = {
    workItemId?: true
    version?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkItemEmbeddingMaxAggregateInputType = {
    workItemId?: true
    version?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkItemEmbeddingCountAggregateInputType = {
    workItemId?: true
    version?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WorkItemEmbeddingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkItemEmbedding to aggregate.
     */
    where?: WorkItemEmbeddingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkItemEmbeddings to fetch.
     */
    orderBy?: WorkItemEmbeddingOrderByWithRelationInput | WorkItemEmbeddingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkItemEmbeddingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkItemEmbeddings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkItemEmbeddings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkItemEmbeddings
    **/
    _count?: true | WorkItemEmbeddingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkItemEmbeddingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkItemEmbeddingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkItemEmbeddingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkItemEmbeddingMaxAggregateInputType
  }

  export type GetWorkItemEmbeddingAggregateType<T extends WorkItemEmbeddingAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkItemEmbedding]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkItemEmbedding[P]>
      : GetScalarType<T[P], AggregateWorkItemEmbedding[P]>
  }




  export type WorkItemEmbeddingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkItemEmbeddingWhereInput
    orderBy?: WorkItemEmbeddingOrderByWithAggregationInput | WorkItemEmbeddingOrderByWithAggregationInput[]
    by: WorkItemEmbeddingScalarFieldEnum[] | WorkItemEmbeddingScalarFieldEnum
    having?: WorkItemEmbeddingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkItemEmbeddingCountAggregateInputType | true
    _avg?: WorkItemEmbeddingAvgAggregateInputType
    _sum?: WorkItemEmbeddingSumAggregateInputType
    _min?: WorkItemEmbeddingMinAggregateInputType
    _max?: WorkItemEmbeddingMaxAggregateInputType
  }

  export type WorkItemEmbeddingGroupByOutputType = {
    workItemId: string
    version: number
    createdAt: Date
    updatedAt: Date
    _count: WorkItemEmbeddingCountAggregateOutputType | null
    _avg: WorkItemEmbeddingAvgAggregateOutputType | null
    _sum: WorkItemEmbeddingSumAggregateOutputType | null
    _min: WorkItemEmbeddingMinAggregateOutputType | null
    _max: WorkItemEmbeddingMaxAggregateOutputType | null
  }

  type GetWorkItemEmbeddingGroupByPayload<T extends WorkItemEmbeddingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkItemEmbeddingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkItemEmbeddingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkItemEmbeddingGroupByOutputType[P]>
            : GetScalarType<T[P], WorkItemEmbeddingGroupByOutputType[P]>
        }
      >
    >


  export type WorkItemEmbeddingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workItemId?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workItem?: boolean | WorkItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workItemEmbedding"]>


  export type WorkItemEmbeddingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    workItemId?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workItem?: boolean | WorkItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workItemEmbedding"]>

  export type WorkItemEmbeddingSelectScalar = {
    workItemId?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WorkItemEmbeddingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"workItemId" | "version" | "createdAt" | "updatedAt", ExtArgs["result"]["workItemEmbedding"]>
  export type WorkItemEmbeddingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workItem?: boolean | WorkItemDefaultArgs<ExtArgs>
  }
  export type WorkItemEmbeddingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workItem?: boolean | WorkItemDefaultArgs<ExtArgs>
  }

  export type $WorkItemEmbeddingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkItemEmbedding"
    objects: {
      workItem: Prisma.$WorkItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      workItemId: string
      version: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["workItemEmbedding"]>
    composites: {}
  }

  type WorkItemEmbeddingGetPayload<S extends boolean | null | undefined | WorkItemEmbeddingDefaultArgs> = $Result.GetResult<Prisma.$WorkItemEmbeddingPayload, S>

  type WorkItemEmbeddingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkItemEmbeddingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkItemEmbeddingCountAggregateInputType | true
    }

  export interface WorkItemEmbeddingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkItemEmbedding'], meta: { name: 'WorkItemEmbedding' } }
    /**
     * Find zero or one WorkItemEmbedding that matches the filter.
     * @param {WorkItemEmbeddingFindUniqueArgs} args - Arguments to find a WorkItemEmbedding
     * @example
     * // Get one WorkItemEmbedding
     * const workItemEmbedding = await prisma.workItemEmbedding.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkItemEmbeddingFindUniqueArgs>(args: SelectSubset<T, WorkItemEmbeddingFindUniqueArgs<ExtArgs>>): Prisma__WorkItemEmbeddingClient<$Result.GetResult<Prisma.$WorkItemEmbeddingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkItemEmbedding that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkItemEmbeddingFindUniqueOrThrowArgs} args - Arguments to find a WorkItemEmbedding
     * @example
     * // Get one WorkItemEmbedding
     * const workItemEmbedding = await prisma.workItemEmbedding.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkItemEmbeddingFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkItemEmbeddingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkItemEmbeddingClient<$Result.GetResult<Prisma.$WorkItemEmbeddingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkItemEmbedding that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkItemEmbeddingFindFirstArgs} args - Arguments to find a WorkItemEmbedding
     * @example
     * // Get one WorkItemEmbedding
     * const workItemEmbedding = await prisma.workItemEmbedding.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkItemEmbeddingFindFirstArgs>(args?: SelectSubset<T, WorkItemEmbeddingFindFirstArgs<ExtArgs>>): Prisma__WorkItemEmbeddingClient<$Result.GetResult<Prisma.$WorkItemEmbeddingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkItemEmbedding that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkItemEmbeddingFindFirstOrThrowArgs} args - Arguments to find a WorkItemEmbedding
     * @example
     * // Get one WorkItemEmbedding
     * const workItemEmbedding = await prisma.workItemEmbedding.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkItemEmbeddingFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkItemEmbeddingFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkItemEmbeddingClient<$Result.GetResult<Prisma.$WorkItemEmbeddingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkItemEmbeddings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkItemEmbeddingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkItemEmbeddings
     * const workItemEmbeddings = await prisma.workItemEmbedding.findMany()
     * 
     * // Get first 10 WorkItemEmbeddings
     * const workItemEmbeddings = await prisma.workItemEmbedding.findMany({ take: 10 })
     * 
     * // Only select the `workItemId`
     * const workItemEmbeddingWithWorkItemIdOnly = await prisma.workItemEmbedding.findMany({ select: { workItemId: true } })
     * 
     */
    findMany<T extends WorkItemEmbeddingFindManyArgs>(args?: SelectSubset<T, WorkItemEmbeddingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkItemEmbeddingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Delete a WorkItemEmbedding.
     * @param {WorkItemEmbeddingDeleteArgs} args - Arguments to delete one WorkItemEmbedding.
     * @example
     * // Delete one WorkItemEmbedding
     * const WorkItemEmbedding = await prisma.workItemEmbedding.delete({
     *   where: {
     *     // ... filter to delete one WorkItemEmbedding
     *   }
     * })
     * 
     */
    delete<T extends WorkItemEmbeddingDeleteArgs>(args: SelectSubset<T, WorkItemEmbeddingDeleteArgs<ExtArgs>>): Prisma__WorkItemEmbeddingClient<$Result.GetResult<Prisma.$WorkItemEmbeddingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkItemEmbedding.
     * @param {WorkItemEmbeddingUpdateArgs} args - Arguments to update one WorkItemEmbedding.
     * @example
     * // Update one WorkItemEmbedding
     * const workItemEmbedding = await prisma.workItemEmbedding.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkItemEmbeddingUpdateArgs>(args: SelectSubset<T, WorkItemEmbeddingUpdateArgs<ExtArgs>>): Prisma__WorkItemEmbeddingClient<$Result.GetResult<Prisma.$WorkItemEmbeddingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkItemEmbeddings.
     * @param {WorkItemEmbeddingDeleteManyArgs} args - Arguments to filter WorkItemEmbeddings to delete.
     * @example
     * // Delete a few WorkItemEmbeddings
     * const { count } = await prisma.workItemEmbedding.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkItemEmbeddingDeleteManyArgs>(args?: SelectSubset<T, WorkItemEmbeddingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkItemEmbeddings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkItemEmbeddingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkItemEmbeddings
     * const workItemEmbedding = await prisma.workItemEmbedding.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkItemEmbeddingUpdateManyArgs>(args: SelectSubset<T, WorkItemEmbeddingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkItemEmbeddings and returns the data updated in the database.
     * @param {WorkItemEmbeddingUpdateManyAndReturnArgs} args - Arguments to update many WorkItemEmbeddings.
     * @example
     * // Update many WorkItemEmbeddings
     * const workItemEmbedding = await prisma.workItemEmbedding.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkItemEmbeddings and only return the `workItemId`
     * const workItemEmbeddingWithWorkItemIdOnly = await prisma.workItemEmbedding.updateManyAndReturn({
     *   select: { workItemId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkItemEmbeddingUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkItemEmbeddingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkItemEmbeddingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>


    /**
     * Count the number of WorkItemEmbeddings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkItemEmbeddingCountArgs} args - Arguments to filter WorkItemEmbeddings to count.
     * @example
     * // Count the number of WorkItemEmbeddings
     * const count = await prisma.workItemEmbedding.count({
     *   where: {
     *     // ... the filter for the WorkItemEmbeddings we want to count
     *   }
     * })
    **/
    count<T extends WorkItemEmbeddingCountArgs>(
      args?: Subset<T, WorkItemEmbeddingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkItemEmbeddingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkItemEmbedding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkItemEmbeddingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkItemEmbeddingAggregateArgs>(args: Subset<T, WorkItemEmbeddingAggregateArgs>): Prisma.PrismaPromise<GetWorkItemEmbeddingAggregateType<T>>

    /**
     * Group by WorkItemEmbedding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkItemEmbeddingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkItemEmbeddingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkItemEmbeddingGroupByArgs['orderBy'] }
        : { orderBy?: WorkItemEmbeddingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkItemEmbeddingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkItemEmbeddingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkItemEmbedding model
   */
  readonly fields: WorkItemEmbeddingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkItemEmbedding.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkItemEmbeddingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workItem<T extends WorkItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkItemDefaultArgs<ExtArgs>>): Prisma__WorkItemClient<$Result.GetResult<Prisma.$WorkItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkItemEmbedding model
   */
  interface WorkItemEmbeddingFieldRefs {
    readonly workItemId: FieldRef<"WorkItemEmbedding", 'String'>
    readonly version: FieldRef<"WorkItemEmbedding", 'Int'>
    readonly createdAt: FieldRef<"WorkItemEmbedding", 'DateTime'>
    readonly updatedAt: FieldRef<"WorkItemEmbedding", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkItemEmbedding findUnique
   */
  export type WorkItemEmbeddingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItemEmbedding
     */
    select?: WorkItemEmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItemEmbedding
     */
    omit?: WorkItemEmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemEmbeddingInclude<ExtArgs> | null
    /**
     * Filter, which WorkItemEmbedding to fetch.
     */
    where: WorkItemEmbeddingWhereUniqueInput
  }

  /**
   * WorkItemEmbedding findUniqueOrThrow
   */
  export type WorkItemEmbeddingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItemEmbedding
     */
    select?: WorkItemEmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItemEmbedding
     */
    omit?: WorkItemEmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemEmbeddingInclude<ExtArgs> | null
    /**
     * Filter, which WorkItemEmbedding to fetch.
     */
    where: WorkItemEmbeddingWhereUniqueInput
  }

  /**
   * WorkItemEmbedding findFirst
   */
  export type WorkItemEmbeddingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItemEmbedding
     */
    select?: WorkItemEmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItemEmbedding
     */
    omit?: WorkItemEmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemEmbeddingInclude<ExtArgs> | null
    /**
     * Filter, which WorkItemEmbedding to fetch.
     */
    where?: WorkItemEmbeddingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkItemEmbeddings to fetch.
     */
    orderBy?: WorkItemEmbeddingOrderByWithRelationInput | WorkItemEmbeddingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkItemEmbeddings.
     */
    cursor?: WorkItemEmbeddingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkItemEmbeddings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkItemEmbeddings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkItemEmbeddings.
     */
    distinct?: WorkItemEmbeddingScalarFieldEnum | WorkItemEmbeddingScalarFieldEnum[]
  }

  /**
   * WorkItemEmbedding findFirstOrThrow
   */
  export type WorkItemEmbeddingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItemEmbedding
     */
    select?: WorkItemEmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItemEmbedding
     */
    omit?: WorkItemEmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemEmbeddingInclude<ExtArgs> | null
    /**
     * Filter, which WorkItemEmbedding to fetch.
     */
    where?: WorkItemEmbeddingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkItemEmbeddings to fetch.
     */
    orderBy?: WorkItemEmbeddingOrderByWithRelationInput | WorkItemEmbeddingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkItemEmbeddings.
     */
    cursor?: WorkItemEmbeddingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkItemEmbeddings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkItemEmbeddings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkItemEmbeddings.
     */
    distinct?: WorkItemEmbeddingScalarFieldEnum | WorkItemEmbeddingScalarFieldEnum[]
  }

  /**
   * WorkItemEmbedding findMany
   */
  export type WorkItemEmbeddingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItemEmbedding
     */
    select?: WorkItemEmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItemEmbedding
     */
    omit?: WorkItemEmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemEmbeddingInclude<ExtArgs> | null
    /**
     * Filter, which WorkItemEmbeddings to fetch.
     */
    where?: WorkItemEmbeddingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkItemEmbeddings to fetch.
     */
    orderBy?: WorkItemEmbeddingOrderByWithRelationInput | WorkItemEmbeddingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkItemEmbeddings.
     */
    cursor?: WorkItemEmbeddingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkItemEmbeddings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkItemEmbeddings.
     */
    skip?: number
    distinct?: WorkItemEmbeddingScalarFieldEnum | WorkItemEmbeddingScalarFieldEnum[]
  }

  /**
   * WorkItemEmbedding update
   */
  export type WorkItemEmbeddingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItemEmbedding
     */
    select?: WorkItemEmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItemEmbedding
     */
    omit?: WorkItemEmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemEmbeddingInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkItemEmbedding.
     */
    data: XOR<WorkItemEmbeddingUpdateInput, WorkItemEmbeddingUncheckedUpdateInput>
    /**
     * Choose, which WorkItemEmbedding to update.
     */
    where: WorkItemEmbeddingWhereUniqueInput
  }

  /**
   * WorkItemEmbedding updateMany
   */
  export type WorkItemEmbeddingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkItemEmbeddings.
     */
    data: XOR<WorkItemEmbeddingUpdateManyMutationInput, WorkItemEmbeddingUncheckedUpdateManyInput>
    /**
     * Filter which WorkItemEmbeddings to update
     */
    where?: WorkItemEmbeddingWhereInput
    /**
     * Limit how many WorkItemEmbeddings to update.
     */
    limit?: number
  }

  /**
   * WorkItemEmbedding updateManyAndReturn
   */
  export type WorkItemEmbeddingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItemEmbedding
     */
    select?: WorkItemEmbeddingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItemEmbedding
     */
    omit?: WorkItemEmbeddingOmit<ExtArgs> | null
    /**
     * The data used to update WorkItemEmbeddings.
     */
    data: XOR<WorkItemEmbeddingUpdateManyMutationInput, WorkItemEmbeddingUncheckedUpdateManyInput>
    /**
     * Filter which WorkItemEmbeddings to update
     */
    where?: WorkItemEmbeddingWhereInput
    /**
     * Limit how many WorkItemEmbeddings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemEmbeddingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkItemEmbedding delete
   */
  export type WorkItemEmbeddingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItemEmbedding
     */
    select?: WorkItemEmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItemEmbedding
     */
    omit?: WorkItemEmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemEmbeddingInclude<ExtArgs> | null
    /**
     * Filter which WorkItemEmbedding to delete.
     */
    where: WorkItemEmbeddingWhereUniqueInput
  }

  /**
   * WorkItemEmbedding deleteMany
   */
  export type WorkItemEmbeddingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkItemEmbeddings to delete
     */
    where?: WorkItemEmbeddingWhereInput
    /**
     * Limit how many WorkItemEmbeddings to delete.
     */
    limit?: number
  }

  /**
   * WorkItemEmbedding without action
   */
  export type WorkItemEmbeddingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItemEmbedding
     */
    select?: WorkItemEmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItemEmbedding
     */
    omit?: WorkItemEmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemEmbeddingInclude<ExtArgs> | null
  }


  /**
   * Model WorkItemSnapshot
   */

  export type AggregateWorkItemSnapshot = {
    _count: WorkItemSnapshotCountAggregateOutputType | null
    _avg: WorkItemSnapshotAvgAggregateOutputType | null
    _sum: WorkItemSnapshotSumAggregateOutputType | null
    _min: WorkItemSnapshotMinAggregateOutputType | null
    _max: WorkItemSnapshotMaxAggregateOutputType | null
  }

  export type WorkItemSnapshotAvgAggregateOutputType = {
    pointsRemaining: number | null
    hoursRemaining: number | null
    hoursSpent: number | null
    daysInCurrentState: number | null
  }

  export type WorkItemSnapshotSumAggregateOutputType = {
    pointsRemaining: number | null
    hoursRemaining: number | null
    hoursSpent: number | null
    daysInCurrentState: number | null
  }

  export type WorkItemSnapshotMinAggregateOutputType = {
    id: string | null
    stateId: string | null
    pointsRemaining: number | null
    hoursRemaining: number | null
    hoursSpent: number | null
    daysInCurrentState: number | null
    snapshotDate: Date | null
    workItemId: string | null
    sprintId: string | null
  }

  export type WorkItemSnapshotMaxAggregateOutputType = {
    id: string | null
    stateId: string | null
    pointsRemaining: number | null
    hoursRemaining: number | null
    hoursSpent: number | null
    daysInCurrentState: number | null
    snapshotDate: Date | null
    workItemId: string | null
    sprintId: string | null
  }

  export type WorkItemSnapshotCountAggregateOutputType = {
    id: number
    stateId: number
    pointsRemaining: number
    hoursRemaining: number
    hoursSpent: number
    daysInCurrentState: number
    blockerIds: number
    snapshotDate: number
    workItemId: number
    sprintId: number
    _all: number
  }


  export type WorkItemSnapshotAvgAggregateInputType = {
    pointsRemaining?: true
    hoursRemaining?: true
    hoursSpent?: true
    daysInCurrentState?: true
  }

  export type WorkItemSnapshotSumAggregateInputType = {
    pointsRemaining?: true
    hoursRemaining?: true
    hoursSpent?: true
    daysInCurrentState?: true
  }

  export type WorkItemSnapshotMinAggregateInputType = {
    id?: true
    stateId?: true
    pointsRemaining?: true
    hoursRemaining?: true
    hoursSpent?: true
    daysInCurrentState?: true
    snapshotDate?: true
    workItemId?: true
    sprintId?: true
  }

  export type WorkItemSnapshotMaxAggregateInputType = {
    id?: true
    stateId?: true
    pointsRemaining?: true
    hoursRemaining?: true
    hoursSpent?: true
    daysInCurrentState?: true
    snapshotDate?: true
    workItemId?: true
    sprintId?: true
  }

  export type WorkItemSnapshotCountAggregateInputType = {
    id?: true
    stateId?: true
    pointsRemaining?: true
    hoursRemaining?: true
    hoursSpent?: true
    daysInCurrentState?: true
    blockerIds?: true
    snapshotDate?: true
    workItemId?: true
    sprintId?: true
    _all?: true
  }

  export type WorkItemSnapshotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkItemSnapshot to aggregate.
     */
    where?: WorkItemSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkItemSnapshots to fetch.
     */
    orderBy?: WorkItemSnapshotOrderByWithRelationInput | WorkItemSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkItemSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkItemSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkItemSnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkItemSnapshots
    **/
    _count?: true | WorkItemSnapshotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkItemSnapshotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkItemSnapshotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkItemSnapshotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkItemSnapshotMaxAggregateInputType
  }

  export type GetWorkItemSnapshotAggregateType<T extends WorkItemSnapshotAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkItemSnapshot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkItemSnapshot[P]>
      : GetScalarType<T[P], AggregateWorkItemSnapshot[P]>
  }




  export type WorkItemSnapshotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkItemSnapshotWhereInput
    orderBy?: WorkItemSnapshotOrderByWithAggregationInput | WorkItemSnapshotOrderByWithAggregationInput[]
    by: WorkItemSnapshotScalarFieldEnum[] | WorkItemSnapshotScalarFieldEnum
    having?: WorkItemSnapshotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkItemSnapshotCountAggregateInputType | true
    _avg?: WorkItemSnapshotAvgAggregateInputType
    _sum?: WorkItemSnapshotSumAggregateInputType
    _min?: WorkItemSnapshotMinAggregateInputType
    _max?: WorkItemSnapshotMaxAggregateInputType
  }

  export type WorkItemSnapshotGroupByOutputType = {
    id: string
    stateId: string | null
    pointsRemaining: number | null
    hoursRemaining: number | null
    hoursSpent: number | null
    daysInCurrentState: number
    blockerIds: string[]
    snapshotDate: Date
    workItemId: string
    sprintId: string | null
    _count: WorkItemSnapshotCountAggregateOutputType | null
    _avg: WorkItemSnapshotAvgAggregateOutputType | null
    _sum: WorkItemSnapshotSumAggregateOutputType | null
    _min: WorkItemSnapshotMinAggregateOutputType | null
    _max: WorkItemSnapshotMaxAggregateOutputType | null
  }

  type GetWorkItemSnapshotGroupByPayload<T extends WorkItemSnapshotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkItemSnapshotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkItemSnapshotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkItemSnapshotGroupByOutputType[P]>
            : GetScalarType<T[P], WorkItemSnapshotGroupByOutputType[P]>
        }
      >
    >


  export type WorkItemSnapshotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stateId?: boolean
    pointsRemaining?: boolean
    hoursRemaining?: boolean
    hoursSpent?: boolean
    daysInCurrentState?: boolean
    blockerIds?: boolean
    snapshotDate?: boolean
    workItemId?: boolean
    sprintId?: boolean
    workItem?: boolean | WorkItemDefaultArgs<ExtArgs>
    sprint?: boolean | WorkItemSnapshot$sprintArgs<ExtArgs>
  }, ExtArgs["result"]["workItemSnapshot"]>

  export type WorkItemSnapshotSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stateId?: boolean
    pointsRemaining?: boolean
    hoursRemaining?: boolean
    hoursSpent?: boolean
    daysInCurrentState?: boolean
    blockerIds?: boolean
    snapshotDate?: boolean
    workItemId?: boolean
    sprintId?: boolean
    workItem?: boolean | WorkItemDefaultArgs<ExtArgs>
    sprint?: boolean | WorkItemSnapshot$sprintArgs<ExtArgs>
  }, ExtArgs["result"]["workItemSnapshot"]>

  export type WorkItemSnapshotSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stateId?: boolean
    pointsRemaining?: boolean
    hoursRemaining?: boolean
    hoursSpent?: boolean
    daysInCurrentState?: boolean
    blockerIds?: boolean
    snapshotDate?: boolean
    workItemId?: boolean
    sprintId?: boolean
    workItem?: boolean | WorkItemDefaultArgs<ExtArgs>
    sprint?: boolean | WorkItemSnapshot$sprintArgs<ExtArgs>
  }, ExtArgs["result"]["workItemSnapshot"]>

  export type WorkItemSnapshotSelectScalar = {
    id?: boolean
    stateId?: boolean
    pointsRemaining?: boolean
    hoursRemaining?: boolean
    hoursSpent?: boolean
    daysInCurrentState?: boolean
    blockerIds?: boolean
    snapshotDate?: boolean
    workItemId?: boolean
    sprintId?: boolean
  }

  export type WorkItemSnapshotOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "stateId" | "pointsRemaining" | "hoursRemaining" | "hoursSpent" | "daysInCurrentState" | "blockerIds" | "snapshotDate" | "workItemId" | "sprintId", ExtArgs["result"]["workItemSnapshot"]>
  export type WorkItemSnapshotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workItem?: boolean | WorkItemDefaultArgs<ExtArgs>
    sprint?: boolean | WorkItemSnapshot$sprintArgs<ExtArgs>
  }
  export type WorkItemSnapshotIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workItem?: boolean | WorkItemDefaultArgs<ExtArgs>
    sprint?: boolean | WorkItemSnapshot$sprintArgs<ExtArgs>
  }
  export type WorkItemSnapshotIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workItem?: boolean | WorkItemDefaultArgs<ExtArgs>
    sprint?: boolean | WorkItemSnapshot$sprintArgs<ExtArgs>
  }

  export type $WorkItemSnapshotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkItemSnapshot"
    objects: {
      workItem: Prisma.$WorkItemPayload<ExtArgs>
      sprint: Prisma.$SprintPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      stateId: string | null
      pointsRemaining: number | null
      hoursRemaining: number | null
      hoursSpent: number | null
      daysInCurrentState: number
      blockerIds: string[]
      snapshotDate: Date
      workItemId: string
      sprintId: string | null
    }, ExtArgs["result"]["workItemSnapshot"]>
    composites: {}
  }

  type WorkItemSnapshotGetPayload<S extends boolean | null | undefined | WorkItemSnapshotDefaultArgs> = $Result.GetResult<Prisma.$WorkItemSnapshotPayload, S>

  type WorkItemSnapshotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkItemSnapshotFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkItemSnapshotCountAggregateInputType | true
    }

  export interface WorkItemSnapshotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkItemSnapshot'], meta: { name: 'WorkItemSnapshot' } }
    /**
     * Find zero or one WorkItemSnapshot that matches the filter.
     * @param {WorkItemSnapshotFindUniqueArgs} args - Arguments to find a WorkItemSnapshot
     * @example
     * // Get one WorkItemSnapshot
     * const workItemSnapshot = await prisma.workItemSnapshot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkItemSnapshotFindUniqueArgs>(args: SelectSubset<T, WorkItemSnapshotFindUniqueArgs<ExtArgs>>): Prisma__WorkItemSnapshotClient<$Result.GetResult<Prisma.$WorkItemSnapshotPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkItemSnapshot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkItemSnapshotFindUniqueOrThrowArgs} args - Arguments to find a WorkItemSnapshot
     * @example
     * // Get one WorkItemSnapshot
     * const workItemSnapshot = await prisma.workItemSnapshot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkItemSnapshotFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkItemSnapshotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkItemSnapshotClient<$Result.GetResult<Prisma.$WorkItemSnapshotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkItemSnapshot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkItemSnapshotFindFirstArgs} args - Arguments to find a WorkItemSnapshot
     * @example
     * // Get one WorkItemSnapshot
     * const workItemSnapshot = await prisma.workItemSnapshot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkItemSnapshotFindFirstArgs>(args?: SelectSubset<T, WorkItemSnapshotFindFirstArgs<ExtArgs>>): Prisma__WorkItemSnapshotClient<$Result.GetResult<Prisma.$WorkItemSnapshotPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkItemSnapshot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkItemSnapshotFindFirstOrThrowArgs} args - Arguments to find a WorkItemSnapshot
     * @example
     * // Get one WorkItemSnapshot
     * const workItemSnapshot = await prisma.workItemSnapshot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkItemSnapshotFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkItemSnapshotFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkItemSnapshotClient<$Result.GetResult<Prisma.$WorkItemSnapshotPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkItemSnapshots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkItemSnapshotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkItemSnapshots
     * const workItemSnapshots = await prisma.workItemSnapshot.findMany()
     * 
     * // Get first 10 WorkItemSnapshots
     * const workItemSnapshots = await prisma.workItemSnapshot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workItemSnapshotWithIdOnly = await prisma.workItemSnapshot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkItemSnapshotFindManyArgs>(args?: SelectSubset<T, WorkItemSnapshotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkItemSnapshotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkItemSnapshot.
     * @param {WorkItemSnapshotCreateArgs} args - Arguments to create a WorkItemSnapshot.
     * @example
     * // Create one WorkItemSnapshot
     * const WorkItemSnapshot = await prisma.workItemSnapshot.create({
     *   data: {
     *     // ... data to create a WorkItemSnapshot
     *   }
     * })
     * 
     */
    create<T extends WorkItemSnapshotCreateArgs>(args: SelectSubset<T, WorkItemSnapshotCreateArgs<ExtArgs>>): Prisma__WorkItemSnapshotClient<$Result.GetResult<Prisma.$WorkItemSnapshotPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkItemSnapshots.
     * @param {WorkItemSnapshotCreateManyArgs} args - Arguments to create many WorkItemSnapshots.
     * @example
     * // Create many WorkItemSnapshots
     * const workItemSnapshot = await prisma.workItemSnapshot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkItemSnapshotCreateManyArgs>(args?: SelectSubset<T, WorkItemSnapshotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkItemSnapshots and returns the data saved in the database.
     * @param {WorkItemSnapshotCreateManyAndReturnArgs} args - Arguments to create many WorkItemSnapshots.
     * @example
     * // Create many WorkItemSnapshots
     * const workItemSnapshot = await prisma.workItemSnapshot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkItemSnapshots and only return the `id`
     * const workItemSnapshotWithIdOnly = await prisma.workItemSnapshot.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkItemSnapshotCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkItemSnapshotCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkItemSnapshotPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkItemSnapshot.
     * @param {WorkItemSnapshotDeleteArgs} args - Arguments to delete one WorkItemSnapshot.
     * @example
     * // Delete one WorkItemSnapshot
     * const WorkItemSnapshot = await prisma.workItemSnapshot.delete({
     *   where: {
     *     // ... filter to delete one WorkItemSnapshot
     *   }
     * })
     * 
     */
    delete<T extends WorkItemSnapshotDeleteArgs>(args: SelectSubset<T, WorkItemSnapshotDeleteArgs<ExtArgs>>): Prisma__WorkItemSnapshotClient<$Result.GetResult<Prisma.$WorkItemSnapshotPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkItemSnapshot.
     * @param {WorkItemSnapshotUpdateArgs} args - Arguments to update one WorkItemSnapshot.
     * @example
     * // Update one WorkItemSnapshot
     * const workItemSnapshot = await prisma.workItemSnapshot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkItemSnapshotUpdateArgs>(args: SelectSubset<T, WorkItemSnapshotUpdateArgs<ExtArgs>>): Prisma__WorkItemSnapshotClient<$Result.GetResult<Prisma.$WorkItemSnapshotPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkItemSnapshots.
     * @param {WorkItemSnapshotDeleteManyArgs} args - Arguments to filter WorkItemSnapshots to delete.
     * @example
     * // Delete a few WorkItemSnapshots
     * const { count } = await prisma.workItemSnapshot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkItemSnapshotDeleteManyArgs>(args?: SelectSubset<T, WorkItemSnapshotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkItemSnapshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkItemSnapshotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkItemSnapshots
     * const workItemSnapshot = await prisma.workItemSnapshot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkItemSnapshotUpdateManyArgs>(args: SelectSubset<T, WorkItemSnapshotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkItemSnapshots and returns the data updated in the database.
     * @param {WorkItemSnapshotUpdateManyAndReturnArgs} args - Arguments to update many WorkItemSnapshots.
     * @example
     * // Update many WorkItemSnapshots
     * const workItemSnapshot = await prisma.workItemSnapshot.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkItemSnapshots and only return the `id`
     * const workItemSnapshotWithIdOnly = await prisma.workItemSnapshot.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkItemSnapshotUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkItemSnapshotUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkItemSnapshotPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkItemSnapshot.
     * @param {WorkItemSnapshotUpsertArgs} args - Arguments to update or create a WorkItemSnapshot.
     * @example
     * // Update or create a WorkItemSnapshot
     * const workItemSnapshot = await prisma.workItemSnapshot.upsert({
     *   create: {
     *     // ... data to create a WorkItemSnapshot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkItemSnapshot we want to update
     *   }
     * })
     */
    upsert<T extends WorkItemSnapshotUpsertArgs>(args: SelectSubset<T, WorkItemSnapshotUpsertArgs<ExtArgs>>): Prisma__WorkItemSnapshotClient<$Result.GetResult<Prisma.$WorkItemSnapshotPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkItemSnapshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkItemSnapshotCountArgs} args - Arguments to filter WorkItemSnapshots to count.
     * @example
     * // Count the number of WorkItemSnapshots
     * const count = await prisma.workItemSnapshot.count({
     *   where: {
     *     // ... the filter for the WorkItemSnapshots we want to count
     *   }
     * })
    **/
    count<T extends WorkItemSnapshotCountArgs>(
      args?: Subset<T, WorkItemSnapshotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkItemSnapshotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkItemSnapshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkItemSnapshotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkItemSnapshotAggregateArgs>(args: Subset<T, WorkItemSnapshotAggregateArgs>): Prisma.PrismaPromise<GetWorkItemSnapshotAggregateType<T>>

    /**
     * Group by WorkItemSnapshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkItemSnapshotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkItemSnapshotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkItemSnapshotGroupByArgs['orderBy'] }
        : { orderBy?: WorkItemSnapshotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkItemSnapshotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkItemSnapshotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkItemSnapshot model
   */
  readonly fields: WorkItemSnapshotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkItemSnapshot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkItemSnapshotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workItem<T extends WorkItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkItemDefaultArgs<ExtArgs>>): Prisma__WorkItemClient<$Result.GetResult<Prisma.$WorkItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sprint<T extends WorkItemSnapshot$sprintArgs<ExtArgs> = {}>(args?: Subset<T, WorkItemSnapshot$sprintArgs<ExtArgs>>): Prisma__SprintClient<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkItemSnapshot model
   */
  interface WorkItemSnapshotFieldRefs {
    readonly id: FieldRef<"WorkItemSnapshot", 'String'>
    readonly stateId: FieldRef<"WorkItemSnapshot", 'String'>
    readonly pointsRemaining: FieldRef<"WorkItemSnapshot", 'Float'>
    readonly hoursRemaining: FieldRef<"WorkItemSnapshot", 'Float'>
    readonly hoursSpent: FieldRef<"WorkItemSnapshot", 'Float'>
    readonly daysInCurrentState: FieldRef<"WorkItemSnapshot", 'Int'>
    readonly blockerIds: FieldRef<"WorkItemSnapshot", 'String[]'>
    readonly snapshotDate: FieldRef<"WorkItemSnapshot", 'DateTime'>
    readonly workItemId: FieldRef<"WorkItemSnapshot", 'String'>
    readonly sprintId: FieldRef<"WorkItemSnapshot", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WorkItemSnapshot findUnique
   */
  export type WorkItemSnapshotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItemSnapshot
     */
    select?: WorkItemSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItemSnapshot
     */
    omit?: WorkItemSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemSnapshotInclude<ExtArgs> | null
    /**
     * Filter, which WorkItemSnapshot to fetch.
     */
    where: WorkItemSnapshotWhereUniqueInput
  }

  /**
   * WorkItemSnapshot findUniqueOrThrow
   */
  export type WorkItemSnapshotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItemSnapshot
     */
    select?: WorkItemSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItemSnapshot
     */
    omit?: WorkItemSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemSnapshotInclude<ExtArgs> | null
    /**
     * Filter, which WorkItemSnapshot to fetch.
     */
    where: WorkItemSnapshotWhereUniqueInput
  }

  /**
   * WorkItemSnapshot findFirst
   */
  export type WorkItemSnapshotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItemSnapshot
     */
    select?: WorkItemSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItemSnapshot
     */
    omit?: WorkItemSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemSnapshotInclude<ExtArgs> | null
    /**
     * Filter, which WorkItemSnapshot to fetch.
     */
    where?: WorkItemSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkItemSnapshots to fetch.
     */
    orderBy?: WorkItemSnapshotOrderByWithRelationInput | WorkItemSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkItemSnapshots.
     */
    cursor?: WorkItemSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkItemSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkItemSnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkItemSnapshots.
     */
    distinct?: WorkItemSnapshotScalarFieldEnum | WorkItemSnapshotScalarFieldEnum[]
  }

  /**
   * WorkItemSnapshot findFirstOrThrow
   */
  export type WorkItemSnapshotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItemSnapshot
     */
    select?: WorkItemSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItemSnapshot
     */
    omit?: WorkItemSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemSnapshotInclude<ExtArgs> | null
    /**
     * Filter, which WorkItemSnapshot to fetch.
     */
    where?: WorkItemSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkItemSnapshots to fetch.
     */
    orderBy?: WorkItemSnapshotOrderByWithRelationInput | WorkItemSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkItemSnapshots.
     */
    cursor?: WorkItemSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkItemSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkItemSnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkItemSnapshots.
     */
    distinct?: WorkItemSnapshotScalarFieldEnum | WorkItemSnapshotScalarFieldEnum[]
  }

  /**
   * WorkItemSnapshot findMany
   */
  export type WorkItemSnapshotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItemSnapshot
     */
    select?: WorkItemSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItemSnapshot
     */
    omit?: WorkItemSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemSnapshotInclude<ExtArgs> | null
    /**
     * Filter, which WorkItemSnapshots to fetch.
     */
    where?: WorkItemSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkItemSnapshots to fetch.
     */
    orderBy?: WorkItemSnapshotOrderByWithRelationInput | WorkItemSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkItemSnapshots.
     */
    cursor?: WorkItemSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkItemSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkItemSnapshots.
     */
    skip?: number
    distinct?: WorkItemSnapshotScalarFieldEnum | WorkItemSnapshotScalarFieldEnum[]
  }

  /**
   * WorkItemSnapshot create
   */
  export type WorkItemSnapshotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItemSnapshot
     */
    select?: WorkItemSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItemSnapshot
     */
    omit?: WorkItemSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemSnapshotInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkItemSnapshot.
     */
    data: XOR<WorkItemSnapshotCreateInput, WorkItemSnapshotUncheckedCreateInput>
  }

  /**
   * WorkItemSnapshot createMany
   */
  export type WorkItemSnapshotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkItemSnapshots.
     */
    data: WorkItemSnapshotCreateManyInput | WorkItemSnapshotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkItemSnapshot createManyAndReturn
   */
  export type WorkItemSnapshotCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItemSnapshot
     */
    select?: WorkItemSnapshotSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItemSnapshot
     */
    omit?: WorkItemSnapshotOmit<ExtArgs> | null
    /**
     * The data used to create many WorkItemSnapshots.
     */
    data: WorkItemSnapshotCreateManyInput | WorkItemSnapshotCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemSnapshotIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkItemSnapshot update
   */
  export type WorkItemSnapshotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItemSnapshot
     */
    select?: WorkItemSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItemSnapshot
     */
    omit?: WorkItemSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemSnapshotInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkItemSnapshot.
     */
    data: XOR<WorkItemSnapshotUpdateInput, WorkItemSnapshotUncheckedUpdateInput>
    /**
     * Choose, which WorkItemSnapshot to update.
     */
    where: WorkItemSnapshotWhereUniqueInput
  }

  /**
   * WorkItemSnapshot updateMany
   */
  export type WorkItemSnapshotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkItemSnapshots.
     */
    data: XOR<WorkItemSnapshotUpdateManyMutationInput, WorkItemSnapshotUncheckedUpdateManyInput>
    /**
     * Filter which WorkItemSnapshots to update
     */
    where?: WorkItemSnapshotWhereInput
    /**
     * Limit how many WorkItemSnapshots to update.
     */
    limit?: number
  }

  /**
   * WorkItemSnapshot updateManyAndReturn
   */
  export type WorkItemSnapshotUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItemSnapshot
     */
    select?: WorkItemSnapshotSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItemSnapshot
     */
    omit?: WorkItemSnapshotOmit<ExtArgs> | null
    /**
     * The data used to update WorkItemSnapshots.
     */
    data: XOR<WorkItemSnapshotUpdateManyMutationInput, WorkItemSnapshotUncheckedUpdateManyInput>
    /**
     * Filter which WorkItemSnapshots to update
     */
    where?: WorkItemSnapshotWhereInput
    /**
     * Limit how many WorkItemSnapshots to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemSnapshotIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkItemSnapshot upsert
   */
  export type WorkItemSnapshotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItemSnapshot
     */
    select?: WorkItemSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItemSnapshot
     */
    omit?: WorkItemSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemSnapshotInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkItemSnapshot to update in case it exists.
     */
    where: WorkItemSnapshotWhereUniqueInput
    /**
     * In case the WorkItemSnapshot found by the `where` argument doesn't exist, create a new WorkItemSnapshot with this data.
     */
    create: XOR<WorkItemSnapshotCreateInput, WorkItemSnapshotUncheckedCreateInput>
    /**
     * In case the WorkItemSnapshot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkItemSnapshotUpdateInput, WorkItemSnapshotUncheckedUpdateInput>
  }

  /**
   * WorkItemSnapshot delete
   */
  export type WorkItemSnapshotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItemSnapshot
     */
    select?: WorkItemSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItemSnapshot
     */
    omit?: WorkItemSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemSnapshotInclude<ExtArgs> | null
    /**
     * Filter which WorkItemSnapshot to delete.
     */
    where: WorkItemSnapshotWhereUniqueInput
  }

  /**
   * WorkItemSnapshot deleteMany
   */
  export type WorkItemSnapshotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkItemSnapshots to delete
     */
    where?: WorkItemSnapshotWhereInput
    /**
     * Limit how many WorkItemSnapshots to delete.
     */
    limit?: number
  }

  /**
   * WorkItemSnapshot.sprint
   */
  export type WorkItemSnapshot$sprintArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    where?: SprintWhereInput
  }

  /**
   * WorkItemSnapshot without action
   */
  export type WorkItemSnapshotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkItemSnapshot
     */
    select?: WorkItemSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkItemSnapshot
     */
    omit?: WorkItemSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkItemSnapshotInclude<ExtArgs> | null
  }


  /**
   * Model UserSkillProfile
   */

  export type AggregateUserSkillProfile = {
    _count: UserSkillProfileCountAggregateOutputType | null
    _avg: UserSkillProfileAvgAggregateOutputType | null
    _sum: UserSkillProfileSumAggregateOutputType | null
    _min: UserSkillProfileMinAggregateOutputType | null
    _max: UserSkillProfileMaxAggregateOutputType | null
  }

  export type UserSkillProfileAvgAggregateOutputType = {
    overallProficiency: number | null
  }

  export type UserSkillProfileSumAggregateOutputType = {
    overallProficiency: number | null
  }

  export type UserSkillProfileMinAggregateOutputType = {
    id: string | null
    overallProficiency: number | null
    lastUpdated: Date | null
    userId: string | null
    teamId: string | null
  }

  export type UserSkillProfileMaxAggregateOutputType = {
    id: string | null
    overallProficiency: number | null
    lastUpdated: Date | null
    userId: string | null
    teamId: string | null
  }

  export type UserSkillProfileCountAggregateOutputType = {
    id: number
    skills: number
    proficiencyScores: number
    certifiedSkills: number
    overallProficiency: number
    lastUpdated: number
    userId: number
    teamId: number
    _all: number
  }


  export type UserSkillProfileAvgAggregateInputType = {
    overallProficiency?: true
  }

  export type UserSkillProfileSumAggregateInputType = {
    overallProficiency?: true
  }

  export type UserSkillProfileMinAggregateInputType = {
    id?: true
    overallProficiency?: true
    lastUpdated?: true
    userId?: true
    teamId?: true
  }

  export type UserSkillProfileMaxAggregateInputType = {
    id?: true
    overallProficiency?: true
    lastUpdated?: true
    userId?: true
    teamId?: true
  }

  export type UserSkillProfileCountAggregateInputType = {
    id?: true
    skills?: true
    proficiencyScores?: true
    certifiedSkills?: true
    overallProficiency?: true
    lastUpdated?: true
    userId?: true
    teamId?: true
    _all?: true
  }

  export type UserSkillProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSkillProfile to aggregate.
     */
    where?: UserSkillProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSkillProfiles to fetch.
     */
    orderBy?: UserSkillProfileOrderByWithRelationInput | UserSkillProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSkillProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSkillProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSkillProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSkillProfiles
    **/
    _count?: true | UserSkillProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserSkillProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSkillProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSkillProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSkillProfileMaxAggregateInputType
  }

  export type GetUserSkillProfileAggregateType<T extends UserSkillProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSkillProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSkillProfile[P]>
      : GetScalarType<T[P], AggregateUserSkillProfile[P]>
  }




  export type UserSkillProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSkillProfileWhereInput
    orderBy?: UserSkillProfileOrderByWithAggregationInput | UserSkillProfileOrderByWithAggregationInput[]
    by: UserSkillProfileScalarFieldEnum[] | UserSkillProfileScalarFieldEnum
    having?: UserSkillProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSkillProfileCountAggregateInputType | true
    _avg?: UserSkillProfileAvgAggregateInputType
    _sum?: UserSkillProfileSumAggregateInputType
    _min?: UserSkillProfileMinAggregateInputType
    _max?: UserSkillProfileMaxAggregateInputType
  }

  export type UserSkillProfileGroupByOutputType = {
    id: string
    skills: string[]
    proficiencyScores: JsonValue
    certifiedSkills: string[]
    overallProficiency: number
    lastUpdated: Date
    userId: string
    teamId: string | null
    _count: UserSkillProfileCountAggregateOutputType | null
    _avg: UserSkillProfileAvgAggregateOutputType | null
    _sum: UserSkillProfileSumAggregateOutputType | null
    _min: UserSkillProfileMinAggregateOutputType | null
    _max: UserSkillProfileMaxAggregateOutputType | null
  }

  type GetUserSkillProfileGroupByPayload<T extends UserSkillProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSkillProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSkillProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSkillProfileGroupByOutputType[P]>
            : GetScalarType<T[P], UserSkillProfileGroupByOutputType[P]>
        }
      >
    >


  export type UserSkillProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    skills?: boolean
    proficiencyScores?: boolean
    certifiedSkills?: boolean
    overallProficiency?: boolean
    lastUpdated?: boolean
    userId?: boolean
    teamId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    team?: boolean | UserSkillProfile$teamArgs<ExtArgs>
  }, ExtArgs["result"]["userSkillProfile"]>

  export type UserSkillProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    skills?: boolean
    proficiencyScores?: boolean
    certifiedSkills?: boolean
    overallProficiency?: boolean
    lastUpdated?: boolean
    userId?: boolean
    teamId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    team?: boolean | UserSkillProfile$teamArgs<ExtArgs>
  }, ExtArgs["result"]["userSkillProfile"]>

  export type UserSkillProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    skills?: boolean
    proficiencyScores?: boolean
    certifiedSkills?: boolean
    overallProficiency?: boolean
    lastUpdated?: boolean
    userId?: boolean
    teamId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    team?: boolean | UserSkillProfile$teamArgs<ExtArgs>
  }, ExtArgs["result"]["userSkillProfile"]>

  export type UserSkillProfileSelectScalar = {
    id?: boolean
    skills?: boolean
    proficiencyScores?: boolean
    certifiedSkills?: boolean
    overallProficiency?: boolean
    lastUpdated?: boolean
    userId?: boolean
    teamId?: boolean
  }

  export type UserSkillProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "skills" | "proficiencyScores" | "certifiedSkills" | "overallProficiency" | "lastUpdated" | "userId" | "teamId", ExtArgs["result"]["userSkillProfile"]>
  export type UserSkillProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    team?: boolean | UserSkillProfile$teamArgs<ExtArgs>
  }
  export type UserSkillProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    team?: boolean | UserSkillProfile$teamArgs<ExtArgs>
  }
  export type UserSkillProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    team?: boolean | UserSkillProfile$teamArgs<ExtArgs>
  }

  export type $UserSkillProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSkillProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      team: Prisma.$TeamPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      skills: string[]
      proficiencyScores: Prisma.JsonValue
      certifiedSkills: string[]
      overallProficiency: number
      lastUpdated: Date
      userId: string
      teamId: string | null
    }, ExtArgs["result"]["userSkillProfile"]>
    composites: {}
  }

  type UserSkillProfileGetPayload<S extends boolean | null | undefined | UserSkillProfileDefaultArgs> = $Result.GetResult<Prisma.$UserSkillProfilePayload, S>

  type UserSkillProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSkillProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSkillProfileCountAggregateInputType | true
    }

  export interface UserSkillProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSkillProfile'], meta: { name: 'UserSkillProfile' } }
    /**
     * Find zero or one UserSkillProfile that matches the filter.
     * @param {UserSkillProfileFindUniqueArgs} args - Arguments to find a UserSkillProfile
     * @example
     * // Get one UserSkillProfile
     * const userSkillProfile = await prisma.userSkillProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSkillProfileFindUniqueArgs>(args: SelectSubset<T, UserSkillProfileFindUniqueArgs<ExtArgs>>): Prisma__UserSkillProfileClient<$Result.GetResult<Prisma.$UserSkillProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSkillProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSkillProfileFindUniqueOrThrowArgs} args - Arguments to find a UserSkillProfile
     * @example
     * // Get one UserSkillProfile
     * const userSkillProfile = await prisma.userSkillProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSkillProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSkillProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSkillProfileClient<$Result.GetResult<Prisma.$UserSkillProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSkillProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSkillProfileFindFirstArgs} args - Arguments to find a UserSkillProfile
     * @example
     * // Get one UserSkillProfile
     * const userSkillProfile = await prisma.userSkillProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSkillProfileFindFirstArgs>(args?: SelectSubset<T, UserSkillProfileFindFirstArgs<ExtArgs>>): Prisma__UserSkillProfileClient<$Result.GetResult<Prisma.$UserSkillProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSkillProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSkillProfileFindFirstOrThrowArgs} args - Arguments to find a UserSkillProfile
     * @example
     * // Get one UserSkillProfile
     * const userSkillProfile = await prisma.userSkillProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSkillProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSkillProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSkillProfileClient<$Result.GetResult<Prisma.$UserSkillProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSkillProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSkillProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSkillProfiles
     * const userSkillProfiles = await prisma.userSkillProfile.findMany()
     * 
     * // Get first 10 UserSkillProfiles
     * const userSkillProfiles = await prisma.userSkillProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSkillProfileWithIdOnly = await prisma.userSkillProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSkillProfileFindManyArgs>(args?: SelectSubset<T, UserSkillProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSkillProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSkillProfile.
     * @param {UserSkillProfileCreateArgs} args - Arguments to create a UserSkillProfile.
     * @example
     * // Create one UserSkillProfile
     * const UserSkillProfile = await prisma.userSkillProfile.create({
     *   data: {
     *     // ... data to create a UserSkillProfile
     *   }
     * })
     * 
     */
    create<T extends UserSkillProfileCreateArgs>(args: SelectSubset<T, UserSkillProfileCreateArgs<ExtArgs>>): Prisma__UserSkillProfileClient<$Result.GetResult<Prisma.$UserSkillProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSkillProfiles.
     * @param {UserSkillProfileCreateManyArgs} args - Arguments to create many UserSkillProfiles.
     * @example
     * // Create many UserSkillProfiles
     * const userSkillProfile = await prisma.userSkillProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSkillProfileCreateManyArgs>(args?: SelectSubset<T, UserSkillProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSkillProfiles and returns the data saved in the database.
     * @param {UserSkillProfileCreateManyAndReturnArgs} args - Arguments to create many UserSkillProfiles.
     * @example
     * // Create many UserSkillProfiles
     * const userSkillProfile = await prisma.userSkillProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSkillProfiles and only return the `id`
     * const userSkillProfileWithIdOnly = await prisma.userSkillProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSkillProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSkillProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSkillProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserSkillProfile.
     * @param {UserSkillProfileDeleteArgs} args - Arguments to delete one UserSkillProfile.
     * @example
     * // Delete one UserSkillProfile
     * const UserSkillProfile = await prisma.userSkillProfile.delete({
     *   where: {
     *     // ... filter to delete one UserSkillProfile
     *   }
     * })
     * 
     */
    delete<T extends UserSkillProfileDeleteArgs>(args: SelectSubset<T, UserSkillProfileDeleteArgs<ExtArgs>>): Prisma__UserSkillProfileClient<$Result.GetResult<Prisma.$UserSkillProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSkillProfile.
     * @param {UserSkillProfileUpdateArgs} args - Arguments to update one UserSkillProfile.
     * @example
     * // Update one UserSkillProfile
     * const userSkillProfile = await prisma.userSkillProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSkillProfileUpdateArgs>(args: SelectSubset<T, UserSkillProfileUpdateArgs<ExtArgs>>): Prisma__UserSkillProfileClient<$Result.GetResult<Prisma.$UserSkillProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSkillProfiles.
     * @param {UserSkillProfileDeleteManyArgs} args - Arguments to filter UserSkillProfiles to delete.
     * @example
     * // Delete a few UserSkillProfiles
     * const { count } = await prisma.userSkillProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSkillProfileDeleteManyArgs>(args?: SelectSubset<T, UserSkillProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSkillProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSkillProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSkillProfiles
     * const userSkillProfile = await prisma.userSkillProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSkillProfileUpdateManyArgs>(args: SelectSubset<T, UserSkillProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSkillProfiles and returns the data updated in the database.
     * @param {UserSkillProfileUpdateManyAndReturnArgs} args - Arguments to update many UserSkillProfiles.
     * @example
     * // Update many UserSkillProfiles
     * const userSkillProfile = await prisma.userSkillProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserSkillProfiles and only return the `id`
     * const userSkillProfileWithIdOnly = await prisma.userSkillProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserSkillProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, UserSkillProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSkillProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserSkillProfile.
     * @param {UserSkillProfileUpsertArgs} args - Arguments to update or create a UserSkillProfile.
     * @example
     * // Update or create a UserSkillProfile
     * const userSkillProfile = await prisma.userSkillProfile.upsert({
     *   create: {
     *     // ... data to create a UserSkillProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSkillProfile we want to update
     *   }
     * })
     */
    upsert<T extends UserSkillProfileUpsertArgs>(args: SelectSubset<T, UserSkillProfileUpsertArgs<ExtArgs>>): Prisma__UserSkillProfileClient<$Result.GetResult<Prisma.$UserSkillProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserSkillProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSkillProfileCountArgs} args - Arguments to filter UserSkillProfiles to count.
     * @example
     * // Count the number of UserSkillProfiles
     * const count = await prisma.userSkillProfile.count({
     *   where: {
     *     // ... the filter for the UserSkillProfiles we want to count
     *   }
     * })
    **/
    count<T extends UserSkillProfileCountArgs>(
      args?: Subset<T, UserSkillProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSkillProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSkillProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSkillProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSkillProfileAggregateArgs>(args: Subset<T, UserSkillProfileAggregateArgs>): Prisma.PrismaPromise<GetUserSkillProfileAggregateType<T>>

    /**
     * Group by UserSkillProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSkillProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSkillProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSkillProfileGroupByArgs['orderBy'] }
        : { orderBy?: UserSkillProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSkillProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSkillProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSkillProfile model
   */
  readonly fields: UserSkillProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSkillProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSkillProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    team<T extends UserSkillProfile$teamArgs<ExtArgs> = {}>(args?: Subset<T, UserSkillProfile$teamArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSkillProfile model
   */
  interface UserSkillProfileFieldRefs {
    readonly id: FieldRef<"UserSkillProfile", 'String'>
    readonly skills: FieldRef<"UserSkillProfile", 'String[]'>
    readonly proficiencyScores: FieldRef<"UserSkillProfile", 'Json'>
    readonly certifiedSkills: FieldRef<"UserSkillProfile", 'String[]'>
    readonly overallProficiency: FieldRef<"UserSkillProfile", 'Float'>
    readonly lastUpdated: FieldRef<"UserSkillProfile", 'DateTime'>
    readonly userId: FieldRef<"UserSkillProfile", 'String'>
    readonly teamId: FieldRef<"UserSkillProfile", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserSkillProfile findUnique
   */
  export type UserSkillProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkillProfile
     */
    select?: UserSkillProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkillProfile
     */
    omit?: UserSkillProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserSkillProfile to fetch.
     */
    where: UserSkillProfileWhereUniqueInput
  }

  /**
   * UserSkillProfile findUniqueOrThrow
   */
  export type UserSkillProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkillProfile
     */
    select?: UserSkillProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkillProfile
     */
    omit?: UserSkillProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserSkillProfile to fetch.
     */
    where: UserSkillProfileWhereUniqueInput
  }

  /**
   * UserSkillProfile findFirst
   */
  export type UserSkillProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkillProfile
     */
    select?: UserSkillProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkillProfile
     */
    omit?: UserSkillProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserSkillProfile to fetch.
     */
    where?: UserSkillProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSkillProfiles to fetch.
     */
    orderBy?: UserSkillProfileOrderByWithRelationInput | UserSkillProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSkillProfiles.
     */
    cursor?: UserSkillProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSkillProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSkillProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSkillProfiles.
     */
    distinct?: UserSkillProfileScalarFieldEnum | UserSkillProfileScalarFieldEnum[]
  }

  /**
   * UserSkillProfile findFirstOrThrow
   */
  export type UserSkillProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkillProfile
     */
    select?: UserSkillProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkillProfile
     */
    omit?: UserSkillProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserSkillProfile to fetch.
     */
    where?: UserSkillProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSkillProfiles to fetch.
     */
    orderBy?: UserSkillProfileOrderByWithRelationInput | UserSkillProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSkillProfiles.
     */
    cursor?: UserSkillProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSkillProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSkillProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSkillProfiles.
     */
    distinct?: UserSkillProfileScalarFieldEnum | UserSkillProfileScalarFieldEnum[]
  }

  /**
   * UserSkillProfile findMany
   */
  export type UserSkillProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkillProfile
     */
    select?: UserSkillProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkillProfile
     */
    omit?: UserSkillProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserSkillProfiles to fetch.
     */
    where?: UserSkillProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSkillProfiles to fetch.
     */
    orderBy?: UserSkillProfileOrderByWithRelationInput | UserSkillProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSkillProfiles.
     */
    cursor?: UserSkillProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSkillProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSkillProfiles.
     */
    skip?: number
    distinct?: UserSkillProfileScalarFieldEnum | UserSkillProfileScalarFieldEnum[]
  }

  /**
   * UserSkillProfile create
   */
  export type UserSkillProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkillProfile
     */
    select?: UserSkillProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkillProfile
     */
    omit?: UserSkillProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSkillProfile.
     */
    data: XOR<UserSkillProfileCreateInput, UserSkillProfileUncheckedCreateInput>
  }

  /**
   * UserSkillProfile createMany
   */
  export type UserSkillProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSkillProfiles.
     */
    data: UserSkillProfileCreateManyInput | UserSkillProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSkillProfile createManyAndReturn
   */
  export type UserSkillProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkillProfile
     */
    select?: UserSkillProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkillProfile
     */
    omit?: UserSkillProfileOmit<ExtArgs> | null
    /**
     * The data used to create many UserSkillProfiles.
     */
    data: UserSkillProfileCreateManyInput | UserSkillProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSkillProfile update
   */
  export type UserSkillProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkillProfile
     */
    select?: UserSkillProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkillProfile
     */
    omit?: UserSkillProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSkillProfile.
     */
    data: XOR<UserSkillProfileUpdateInput, UserSkillProfileUncheckedUpdateInput>
    /**
     * Choose, which UserSkillProfile to update.
     */
    where: UserSkillProfileWhereUniqueInput
  }

  /**
   * UserSkillProfile updateMany
   */
  export type UserSkillProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSkillProfiles.
     */
    data: XOR<UserSkillProfileUpdateManyMutationInput, UserSkillProfileUncheckedUpdateManyInput>
    /**
     * Filter which UserSkillProfiles to update
     */
    where?: UserSkillProfileWhereInput
    /**
     * Limit how many UserSkillProfiles to update.
     */
    limit?: number
  }

  /**
   * UserSkillProfile updateManyAndReturn
   */
  export type UserSkillProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkillProfile
     */
    select?: UserSkillProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkillProfile
     */
    omit?: UserSkillProfileOmit<ExtArgs> | null
    /**
     * The data used to update UserSkillProfiles.
     */
    data: XOR<UserSkillProfileUpdateManyMutationInput, UserSkillProfileUncheckedUpdateManyInput>
    /**
     * Filter which UserSkillProfiles to update
     */
    where?: UserSkillProfileWhereInput
    /**
     * Limit how many UserSkillProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSkillProfile upsert
   */
  export type UserSkillProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkillProfile
     */
    select?: UserSkillProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkillProfile
     */
    omit?: UserSkillProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSkillProfile to update in case it exists.
     */
    where: UserSkillProfileWhereUniqueInput
    /**
     * In case the UserSkillProfile found by the `where` argument doesn't exist, create a new UserSkillProfile with this data.
     */
    create: XOR<UserSkillProfileCreateInput, UserSkillProfileUncheckedCreateInput>
    /**
     * In case the UserSkillProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSkillProfileUpdateInput, UserSkillProfileUncheckedUpdateInput>
  }

  /**
   * UserSkillProfile delete
   */
  export type UserSkillProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkillProfile
     */
    select?: UserSkillProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkillProfile
     */
    omit?: UserSkillProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillProfileInclude<ExtArgs> | null
    /**
     * Filter which UserSkillProfile to delete.
     */
    where: UserSkillProfileWhereUniqueInput
  }

  /**
   * UserSkillProfile deleteMany
   */
  export type UserSkillProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSkillProfiles to delete
     */
    where?: UserSkillProfileWhereInput
    /**
     * Limit how many UserSkillProfiles to delete.
     */
    limit?: number
  }

  /**
   * UserSkillProfile.team
   */
  export type UserSkillProfile$teamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
  }

  /**
   * UserSkillProfile without action
   */
  export type UserSkillProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSkillProfile
     */
    select?: UserSkillProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSkillProfile
     */
    omit?: UserSkillProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSkillProfileInclude<ExtArgs> | null
  }


  /**
   * Model WorkflowRule
   */

  export type AggregateWorkflowRule = {
    _count: WorkflowRuleCountAggregateOutputType | null
    _avg: WorkflowRuleAvgAggregateOutputType | null
    _sum: WorkflowRuleSumAggregateOutputType | null
    _min: WorkflowRuleMinAggregateOutputType | null
    _max: WorkflowRuleMaxAggregateOutputType | null
  }

  export type WorkflowRuleAvgAggregateOutputType = {
    priority: number | null
  }

  export type WorkflowRuleSumAggregateOutputType = {
    priority: number | null
  }

  export type WorkflowRuleMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    trigger: string | null
    isActive: boolean | null
    priority: number | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
  }

  export type WorkflowRuleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    trigger: string | null
    isActive: boolean | null
    priority: number | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
  }

  export type WorkflowRuleCountAggregateOutputType = {
    id: number
    name: number
    description: number
    trigger: number
    action: number
    conditions: number
    isActive: number
    priority: number
    createdAt: number
    updatedAt: number
    projectId: number
    _all: number
  }


  export type WorkflowRuleAvgAggregateInputType = {
    priority?: true
  }

  export type WorkflowRuleSumAggregateInputType = {
    priority?: true
  }

  export type WorkflowRuleMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    trigger?: true
    isActive?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type WorkflowRuleMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    trigger?: true
    isActive?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type WorkflowRuleCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    trigger?: true
    action?: true
    conditions?: true
    isActive?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    _all?: true
  }

  export type WorkflowRuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkflowRule to aggregate.
     */
    where?: WorkflowRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowRules to fetch.
     */
    orderBy?: WorkflowRuleOrderByWithRelationInput | WorkflowRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkflowRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkflowRules
    **/
    _count?: true | WorkflowRuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkflowRuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkflowRuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkflowRuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkflowRuleMaxAggregateInputType
  }

  export type GetWorkflowRuleAggregateType<T extends WorkflowRuleAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkflowRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkflowRule[P]>
      : GetScalarType<T[P], AggregateWorkflowRule[P]>
  }




  export type WorkflowRuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowRuleWhereInput
    orderBy?: WorkflowRuleOrderByWithAggregationInput | WorkflowRuleOrderByWithAggregationInput[]
    by: WorkflowRuleScalarFieldEnum[] | WorkflowRuleScalarFieldEnum
    having?: WorkflowRuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkflowRuleCountAggregateInputType | true
    _avg?: WorkflowRuleAvgAggregateInputType
    _sum?: WorkflowRuleSumAggregateInputType
    _min?: WorkflowRuleMinAggregateInputType
    _max?: WorkflowRuleMaxAggregateInputType
  }

  export type WorkflowRuleGroupByOutputType = {
    id: string
    name: string
    description: string | null
    trigger: string
    action: JsonValue
    conditions: JsonValue
    isActive: boolean
    priority: number
    createdAt: Date
    updatedAt: Date
    projectId: string
    _count: WorkflowRuleCountAggregateOutputType | null
    _avg: WorkflowRuleAvgAggregateOutputType | null
    _sum: WorkflowRuleSumAggregateOutputType | null
    _min: WorkflowRuleMinAggregateOutputType | null
    _max: WorkflowRuleMaxAggregateOutputType | null
  }

  type GetWorkflowRuleGroupByPayload<T extends WorkflowRuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkflowRuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkflowRuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkflowRuleGroupByOutputType[P]>
            : GetScalarType<T[P], WorkflowRuleGroupByOutputType[P]>
        }
      >
    >


  export type WorkflowRuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    trigger?: boolean
    action?: boolean
    conditions?: boolean
    isActive?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workflowRule"]>

  export type WorkflowRuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    trigger?: boolean
    action?: boolean
    conditions?: boolean
    isActive?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workflowRule"]>

  export type WorkflowRuleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    trigger?: boolean
    action?: boolean
    conditions?: boolean
    isActive?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workflowRule"]>

  export type WorkflowRuleSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    trigger?: boolean
    action?: boolean
    conditions?: boolean
    isActive?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
  }

  export type WorkflowRuleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "trigger" | "action" | "conditions" | "isActive" | "priority" | "createdAt" | "updatedAt" | "projectId", ExtArgs["result"]["workflowRule"]>
  export type WorkflowRuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type WorkflowRuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type WorkflowRuleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $WorkflowRulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkflowRule"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      trigger: string
      action: Prisma.JsonValue
      conditions: Prisma.JsonValue
      isActive: boolean
      priority: number
      createdAt: Date
      updatedAt: Date
      projectId: string
    }, ExtArgs["result"]["workflowRule"]>
    composites: {}
  }

  type WorkflowRuleGetPayload<S extends boolean | null | undefined | WorkflowRuleDefaultArgs> = $Result.GetResult<Prisma.$WorkflowRulePayload, S>

  type WorkflowRuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkflowRuleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkflowRuleCountAggregateInputType | true
    }

  export interface WorkflowRuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkflowRule'], meta: { name: 'WorkflowRule' } }
    /**
     * Find zero or one WorkflowRule that matches the filter.
     * @param {WorkflowRuleFindUniqueArgs} args - Arguments to find a WorkflowRule
     * @example
     * // Get one WorkflowRule
     * const workflowRule = await prisma.workflowRule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkflowRuleFindUniqueArgs>(args: SelectSubset<T, WorkflowRuleFindUniqueArgs<ExtArgs>>): Prisma__WorkflowRuleClient<$Result.GetResult<Prisma.$WorkflowRulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkflowRule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkflowRuleFindUniqueOrThrowArgs} args - Arguments to find a WorkflowRule
     * @example
     * // Get one WorkflowRule
     * const workflowRule = await prisma.workflowRule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkflowRuleFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkflowRuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkflowRuleClient<$Result.GetResult<Prisma.$WorkflowRulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkflowRule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowRuleFindFirstArgs} args - Arguments to find a WorkflowRule
     * @example
     * // Get one WorkflowRule
     * const workflowRule = await prisma.workflowRule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkflowRuleFindFirstArgs>(args?: SelectSubset<T, WorkflowRuleFindFirstArgs<ExtArgs>>): Prisma__WorkflowRuleClient<$Result.GetResult<Prisma.$WorkflowRulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkflowRule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowRuleFindFirstOrThrowArgs} args - Arguments to find a WorkflowRule
     * @example
     * // Get one WorkflowRule
     * const workflowRule = await prisma.workflowRule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkflowRuleFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkflowRuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkflowRuleClient<$Result.GetResult<Prisma.$WorkflowRulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkflowRules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowRuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkflowRules
     * const workflowRules = await prisma.workflowRule.findMany()
     * 
     * // Get first 10 WorkflowRules
     * const workflowRules = await prisma.workflowRule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workflowRuleWithIdOnly = await prisma.workflowRule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkflowRuleFindManyArgs>(args?: SelectSubset<T, WorkflowRuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkflowRule.
     * @param {WorkflowRuleCreateArgs} args - Arguments to create a WorkflowRule.
     * @example
     * // Create one WorkflowRule
     * const WorkflowRule = await prisma.workflowRule.create({
     *   data: {
     *     // ... data to create a WorkflowRule
     *   }
     * })
     * 
     */
    create<T extends WorkflowRuleCreateArgs>(args: SelectSubset<T, WorkflowRuleCreateArgs<ExtArgs>>): Prisma__WorkflowRuleClient<$Result.GetResult<Prisma.$WorkflowRulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkflowRules.
     * @param {WorkflowRuleCreateManyArgs} args - Arguments to create many WorkflowRules.
     * @example
     * // Create many WorkflowRules
     * const workflowRule = await prisma.workflowRule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkflowRuleCreateManyArgs>(args?: SelectSubset<T, WorkflowRuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkflowRules and returns the data saved in the database.
     * @param {WorkflowRuleCreateManyAndReturnArgs} args - Arguments to create many WorkflowRules.
     * @example
     * // Create many WorkflowRules
     * const workflowRule = await prisma.workflowRule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkflowRules and only return the `id`
     * const workflowRuleWithIdOnly = await prisma.workflowRule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkflowRuleCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkflowRuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowRulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkflowRule.
     * @param {WorkflowRuleDeleteArgs} args - Arguments to delete one WorkflowRule.
     * @example
     * // Delete one WorkflowRule
     * const WorkflowRule = await prisma.workflowRule.delete({
     *   where: {
     *     // ... filter to delete one WorkflowRule
     *   }
     * })
     * 
     */
    delete<T extends WorkflowRuleDeleteArgs>(args: SelectSubset<T, WorkflowRuleDeleteArgs<ExtArgs>>): Prisma__WorkflowRuleClient<$Result.GetResult<Prisma.$WorkflowRulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkflowRule.
     * @param {WorkflowRuleUpdateArgs} args - Arguments to update one WorkflowRule.
     * @example
     * // Update one WorkflowRule
     * const workflowRule = await prisma.workflowRule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkflowRuleUpdateArgs>(args: SelectSubset<T, WorkflowRuleUpdateArgs<ExtArgs>>): Prisma__WorkflowRuleClient<$Result.GetResult<Prisma.$WorkflowRulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkflowRules.
     * @param {WorkflowRuleDeleteManyArgs} args - Arguments to filter WorkflowRules to delete.
     * @example
     * // Delete a few WorkflowRules
     * const { count } = await prisma.workflowRule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkflowRuleDeleteManyArgs>(args?: SelectSubset<T, WorkflowRuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkflowRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowRuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkflowRules
     * const workflowRule = await prisma.workflowRule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkflowRuleUpdateManyArgs>(args: SelectSubset<T, WorkflowRuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkflowRules and returns the data updated in the database.
     * @param {WorkflowRuleUpdateManyAndReturnArgs} args - Arguments to update many WorkflowRules.
     * @example
     * // Update many WorkflowRules
     * const workflowRule = await prisma.workflowRule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkflowRules and only return the `id`
     * const workflowRuleWithIdOnly = await prisma.workflowRule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkflowRuleUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkflowRuleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowRulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkflowRule.
     * @param {WorkflowRuleUpsertArgs} args - Arguments to update or create a WorkflowRule.
     * @example
     * // Update or create a WorkflowRule
     * const workflowRule = await prisma.workflowRule.upsert({
     *   create: {
     *     // ... data to create a WorkflowRule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkflowRule we want to update
     *   }
     * })
     */
    upsert<T extends WorkflowRuleUpsertArgs>(args: SelectSubset<T, WorkflowRuleUpsertArgs<ExtArgs>>): Prisma__WorkflowRuleClient<$Result.GetResult<Prisma.$WorkflowRulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkflowRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowRuleCountArgs} args - Arguments to filter WorkflowRules to count.
     * @example
     * // Count the number of WorkflowRules
     * const count = await prisma.workflowRule.count({
     *   where: {
     *     // ... the filter for the WorkflowRules we want to count
     *   }
     * })
    **/
    count<T extends WorkflowRuleCountArgs>(
      args?: Subset<T, WorkflowRuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkflowRuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkflowRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowRuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkflowRuleAggregateArgs>(args: Subset<T, WorkflowRuleAggregateArgs>): Prisma.PrismaPromise<GetWorkflowRuleAggregateType<T>>

    /**
     * Group by WorkflowRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowRuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkflowRuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkflowRuleGroupByArgs['orderBy'] }
        : { orderBy?: WorkflowRuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkflowRuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkflowRuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkflowRule model
   */
  readonly fields: WorkflowRuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkflowRule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkflowRuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkflowRule model
   */
  interface WorkflowRuleFieldRefs {
    readonly id: FieldRef<"WorkflowRule", 'String'>
    readonly name: FieldRef<"WorkflowRule", 'String'>
    readonly description: FieldRef<"WorkflowRule", 'String'>
    readonly trigger: FieldRef<"WorkflowRule", 'String'>
    readonly action: FieldRef<"WorkflowRule", 'Json'>
    readonly conditions: FieldRef<"WorkflowRule", 'Json'>
    readonly isActive: FieldRef<"WorkflowRule", 'Boolean'>
    readonly priority: FieldRef<"WorkflowRule", 'Int'>
    readonly createdAt: FieldRef<"WorkflowRule", 'DateTime'>
    readonly updatedAt: FieldRef<"WorkflowRule", 'DateTime'>
    readonly projectId: FieldRef<"WorkflowRule", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WorkflowRule findUnique
   */
  export type WorkflowRuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowRule
     */
    select?: WorkflowRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowRule
     */
    omit?: WorkflowRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowRuleInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowRule to fetch.
     */
    where: WorkflowRuleWhereUniqueInput
  }

  /**
   * WorkflowRule findUniqueOrThrow
   */
  export type WorkflowRuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowRule
     */
    select?: WorkflowRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowRule
     */
    omit?: WorkflowRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowRuleInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowRule to fetch.
     */
    where: WorkflowRuleWhereUniqueInput
  }

  /**
   * WorkflowRule findFirst
   */
  export type WorkflowRuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowRule
     */
    select?: WorkflowRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowRule
     */
    omit?: WorkflowRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowRuleInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowRule to fetch.
     */
    where?: WorkflowRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowRules to fetch.
     */
    orderBy?: WorkflowRuleOrderByWithRelationInput | WorkflowRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkflowRules.
     */
    cursor?: WorkflowRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkflowRules.
     */
    distinct?: WorkflowRuleScalarFieldEnum | WorkflowRuleScalarFieldEnum[]
  }

  /**
   * WorkflowRule findFirstOrThrow
   */
  export type WorkflowRuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowRule
     */
    select?: WorkflowRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowRule
     */
    omit?: WorkflowRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowRuleInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowRule to fetch.
     */
    where?: WorkflowRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowRules to fetch.
     */
    orderBy?: WorkflowRuleOrderByWithRelationInput | WorkflowRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkflowRules.
     */
    cursor?: WorkflowRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkflowRules.
     */
    distinct?: WorkflowRuleScalarFieldEnum | WorkflowRuleScalarFieldEnum[]
  }

  /**
   * WorkflowRule findMany
   */
  export type WorkflowRuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowRule
     */
    select?: WorkflowRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowRule
     */
    omit?: WorkflowRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowRuleInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowRules to fetch.
     */
    where?: WorkflowRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowRules to fetch.
     */
    orderBy?: WorkflowRuleOrderByWithRelationInput | WorkflowRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkflowRules.
     */
    cursor?: WorkflowRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowRules.
     */
    skip?: number
    distinct?: WorkflowRuleScalarFieldEnum | WorkflowRuleScalarFieldEnum[]
  }

  /**
   * WorkflowRule create
   */
  export type WorkflowRuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowRule
     */
    select?: WorkflowRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowRule
     */
    omit?: WorkflowRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowRuleInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkflowRule.
     */
    data: XOR<WorkflowRuleCreateInput, WorkflowRuleUncheckedCreateInput>
  }

  /**
   * WorkflowRule createMany
   */
  export type WorkflowRuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkflowRules.
     */
    data: WorkflowRuleCreateManyInput | WorkflowRuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkflowRule createManyAndReturn
   */
  export type WorkflowRuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowRule
     */
    select?: WorkflowRuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowRule
     */
    omit?: WorkflowRuleOmit<ExtArgs> | null
    /**
     * The data used to create many WorkflowRules.
     */
    data: WorkflowRuleCreateManyInput | WorkflowRuleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowRuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkflowRule update
   */
  export type WorkflowRuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowRule
     */
    select?: WorkflowRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowRule
     */
    omit?: WorkflowRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowRuleInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkflowRule.
     */
    data: XOR<WorkflowRuleUpdateInput, WorkflowRuleUncheckedUpdateInput>
    /**
     * Choose, which WorkflowRule to update.
     */
    where: WorkflowRuleWhereUniqueInput
  }

  /**
   * WorkflowRule updateMany
   */
  export type WorkflowRuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkflowRules.
     */
    data: XOR<WorkflowRuleUpdateManyMutationInput, WorkflowRuleUncheckedUpdateManyInput>
    /**
     * Filter which WorkflowRules to update
     */
    where?: WorkflowRuleWhereInput
    /**
     * Limit how many WorkflowRules to update.
     */
    limit?: number
  }

  /**
   * WorkflowRule updateManyAndReturn
   */
  export type WorkflowRuleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowRule
     */
    select?: WorkflowRuleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowRule
     */
    omit?: WorkflowRuleOmit<ExtArgs> | null
    /**
     * The data used to update WorkflowRules.
     */
    data: XOR<WorkflowRuleUpdateManyMutationInput, WorkflowRuleUncheckedUpdateManyInput>
    /**
     * Filter which WorkflowRules to update
     */
    where?: WorkflowRuleWhereInput
    /**
     * Limit how many WorkflowRules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowRuleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkflowRule upsert
   */
  export type WorkflowRuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowRule
     */
    select?: WorkflowRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowRule
     */
    omit?: WorkflowRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowRuleInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkflowRule to update in case it exists.
     */
    where: WorkflowRuleWhereUniqueInput
    /**
     * In case the WorkflowRule found by the `where` argument doesn't exist, create a new WorkflowRule with this data.
     */
    create: XOR<WorkflowRuleCreateInput, WorkflowRuleUncheckedCreateInput>
    /**
     * In case the WorkflowRule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkflowRuleUpdateInput, WorkflowRuleUncheckedUpdateInput>
  }

  /**
   * WorkflowRule delete
   */
  export type WorkflowRuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowRule
     */
    select?: WorkflowRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowRule
     */
    omit?: WorkflowRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowRuleInclude<ExtArgs> | null
    /**
     * Filter which WorkflowRule to delete.
     */
    where: WorkflowRuleWhereUniqueInput
  }

  /**
   * WorkflowRule deleteMany
   */
  export type WorkflowRuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkflowRules to delete
     */
    where?: WorkflowRuleWhereInput
    /**
     * Limit how many WorkflowRules to delete.
     */
    limit?: number
  }

  /**
   * WorkflowRule without action
   */
  export type WorkflowRuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowRule
     */
    select?: WorkflowRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowRule
     */
    omit?: WorkflowRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowRuleInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationAvgAggregateOutputType = {
    priorityScore: number | null
  }

  export type NotificationSumAggregateOutputType = {
    priorityScore: number | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    type: string | null
    title: string | null
    body: string | null
    targetUrl: string | null
    priorityScore: number | null
    isRead: boolean | null
    createdAt: Date | null
    readAt: Date | null
    userId: string | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    type: string | null
    title: string | null
    body: string | null
    targetUrl: string | null
    priorityScore: number | null
    isRead: boolean | null
    createdAt: Date | null
    readAt: Date | null
    userId: string | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    type: number
    title: number
    body: number
    targetUrl: number
    priorityScore: number
    isRead: number
    metadata: number
    createdAt: number
    readAt: number
    userId: number
    _all: number
  }


  export type NotificationAvgAggregateInputType = {
    priorityScore?: true
  }

  export type NotificationSumAggregateInputType = {
    priorityScore?: true
  }

  export type NotificationMinAggregateInputType = {
    id?: true
    type?: true
    title?: true
    body?: true
    targetUrl?: true
    priorityScore?: true
    isRead?: true
    createdAt?: true
    readAt?: true
    userId?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    type?: true
    title?: true
    body?: true
    targetUrl?: true
    priorityScore?: true
    isRead?: true
    createdAt?: true
    readAt?: true
    userId?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    type?: true
    title?: true
    body?: true
    targetUrl?: true
    priorityScore?: true
    isRead?: true
    metadata?: true
    createdAt?: true
    readAt?: true
    userId?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _avg?: NotificationAvgAggregateInputType
    _sum?: NotificationSumAggregateInputType
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    type: string
    title: string
    body: string | null
    targetUrl: string | null
    priorityScore: number
    isRead: boolean
    metadata: JsonValue
    createdAt: Date
    readAt: Date | null
    userId: string
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    body?: boolean
    targetUrl?: boolean
    priorityScore?: boolean
    isRead?: boolean
    metadata?: boolean
    createdAt?: boolean
    readAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    body?: boolean
    targetUrl?: boolean
    priorityScore?: boolean
    isRead?: boolean
    metadata?: boolean
    createdAt?: boolean
    readAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    body?: boolean
    targetUrl?: boolean
    priorityScore?: boolean
    isRead?: boolean
    metadata?: boolean
    createdAt?: boolean
    readAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    type?: boolean
    title?: boolean
    body?: boolean
    targetUrl?: boolean
    priorityScore?: boolean
    isRead?: boolean
    metadata?: boolean
    createdAt?: boolean
    readAt?: boolean
    userId?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "title" | "body" | "targetUrl" | "priorityScore" | "isRead" | "metadata" | "createdAt" | "readAt" | "userId", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      title: string
      body: string | null
      targetUrl: string | null
      priorityScore: number
      isRead: boolean
      metadata: Prisma.JsonValue
      createdAt: Date
      readAt: Date | null
      userId: string
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly body: FieldRef<"Notification", 'String'>
    readonly targetUrl: FieldRef<"Notification", 'String'>
    readonly priorityScore: FieldRef<"Notification", 'Float'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly metadata: FieldRef<"Notification", 'Json'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly readAt: FieldRef<"Notification", 'DateTime'>
    readonly userId: FieldRef<"Notification", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model ActivityLog
   */

  export type AggregateActivityLog = {
    _count: ActivityLogCountAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  export type ActivityLogMinAggregateOutputType = {
    id: string | null
    entityType: string | null
    entityId: string | null
    action: string | null
    actorId: string | null
    createdAt: Date | null
  }

  export type ActivityLogMaxAggregateOutputType = {
    id: string | null
    entityType: string | null
    entityId: string | null
    action: string | null
    actorId: string | null
    createdAt: Date | null
  }

  export type ActivityLogCountAggregateOutputType = {
    id: number
    entityType: number
    entityId: number
    action: number
    actorId: number
    changeDiff: number
    context: number
    createdAt: number
    _all: number
  }


  export type ActivityLogMinAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    action?: true
    actorId?: true
    createdAt?: true
  }

  export type ActivityLogMaxAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    action?: true
    actorId?: true
    createdAt?: true
  }

  export type ActivityLogCountAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    action?: true
    actorId?: true
    changeDiff?: true
    context?: true
    createdAt?: true
    _all?: true
  }

  export type ActivityLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLog to aggregate.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActivityLogs
    **/
    _count?: true | ActivityLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityLogMaxAggregateInputType
  }

  export type GetActivityLogAggregateType<T extends ActivityLogAggregateArgs> = {
        [P in keyof T & keyof AggregateActivityLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivityLog[P]>
      : GetScalarType<T[P], AggregateActivityLog[P]>
  }




  export type ActivityLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithAggregationInput | ActivityLogOrderByWithAggregationInput[]
    by: ActivityLogScalarFieldEnum[] | ActivityLogScalarFieldEnum
    having?: ActivityLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityLogCountAggregateInputType | true
    _min?: ActivityLogMinAggregateInputType
    _max?: ActivityLogMaxAggregateInputType
  }

  export type ActivityLogGroupByOutputType = {
    id: string
    entityType: string
    entityId: string
    action: string
    actorId: string | null
    changeDiff: JsonValue
    context: JsonValue
    createdAt: Date
    _count: ActivityLogCountAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  type GetActivityLogGroupByPayload<T extends ActivityLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
        }
      >
    >


  export type ActivityLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    action?: boolean
    actorId?: boolean
    changeDiff?: boolean
    context?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    action?: boolean
    actorId?: boolean
    changeDiff?: boolean
    context?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    action?: boolean
    actorId?: boolean
    changeDiff?: boolean
    context?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectScalar = {
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    action?: boolean
    actorId?: boolean
    changeDiff?: boolean
    context?: boolean
    createdAt?: boolean
  }

  export type ActivityLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "entityType" | "entityId" | "action" | "actorId" | "changeDiff" | "context" | "createdAt", ExtArgs["result"]["activityLog"]>

  export type $ActivityLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActivityLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      entityType: string
      entityId: string
      action: string
      actorId: string | null
      changeDiff: Prisma.JsonValue
      context: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["activityLog"]>
    composites: {}
  }

  type ActivityLogGetPayload<S extends boolean | null | undefined | ActivityLogDefaultArgs> = $Result.GetResult<Prisma.$ActivityLogPayload, S>

  type ActivityLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActivityLogCountAggregateInputType | true
    }

  export interface ActivityLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActivityLog'], meta: { name: 'ActivityLog' } }
    /**
     * Find zero or one ActivityLog that matches the filter.
     * @param {ActivityLogFindUniqueArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityLogFindUniqueArgs>(args: SelectSubset<T, ActivityLogFindUniqueArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ActivityLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityLogFindUniqueOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityLogFindFirstArgs>(args?: SelectSubset<T, ActivityLogFindFirstArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ActivityLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany()
     * 
     * // Get first 10 ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityLogFindManyArgs>(args?: SelectSubset<T, ActivityLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ActivityLog.
     * @param {ActivityLogCreateArgs} args - Arguments to create a ActivityLog.
     * @example
     * // Create one ActivityLog
     * const ActivityLog = await prisma.activityLog.create({
     *   data: {
     *     // ... data to create a ActivityLog
     *   }
     * })
     * 
     */
    create<T extends ActivityLogCreateArgs>(args: SelectSubset<T, ActivityLogCreateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ActivityLogs.
     * @param {ActivityLogCreateManyArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityLogCreateManyArgs>(args?: SelectSubset<T, ActivityLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActivityLogs and returns the data saved in the database.
     * @param {ActivityLogCreateManyAndReturnArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActivityLogs and only return the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ActivityLog.
     * @param {ActivityLogDeleteArgs} args - Arguments to delete one ActivityLog.
     * @example
     * // Delete one ActivityLog
     * const ActivityLog = await prisma.activityLog.delete({
     *   where: {
     *     // ... filter to delete one ActivityLog
     *   }
     * })
     * 
     */
    delete<T extends ActivityLogDeleteArgs>(args: SelectSubset<T, ActivityLogDeleteArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ActivityLog.
     * @param {ActivityLogUpdateArgs} args - Arguments to update one ActivityLog.
     * @example
     * // Update one ActivityLog
     * const activityLog = await prisma.activityLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityLogUpdateArgs>(args: SelectSubset<T, ActivityLogUpdateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ActivityLogs.
     * @param {ActivityLogDeleteManyArgs} args - Arguments to filter ActivityLogs to delete.
     * @example
     * // Delete a few ActivityLogs
     * const { count } = await prisma.activityLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityLogDeleteManyArgs>(args?: SelectSubset<T, ActivityLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivityLogs
     * const activityLog = await prisma.activityLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityLogUpdateManyArgs>(args: SelectSubset<T, ActivityLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityLogs and returns the data updated in the database.
     * @param {ActivityLogUpdateManyAndReturnArgs} args - Arguments to update many ActivityLogs.
     * @example
     * // Update many ActivityLogs
     * const activityLog = await prisma.activityLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ActivityLogs and only return the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActivityLogUpdateManyAndReturnArgs>(args: SelectSubset<T, ActivityLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ActivityLog.
     * @param {ActivityLogUpsertArgs} args - Arguments to update or create a ActivityLog.
     * @example
     * // Update or create a ActivityLog
     * const activityLog = await prisma.activityLog.upsert({
     *   create: {
     *     // ... data to create a ActivityLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivityLog we want to update
     *   }
     * })
     */
    upsert<T extends ActivityLogUpsertArgs>(args: SelectSubset<T, ActivityLogUpsertArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogCountArgs} args - Arguments to filter ActivityLogs to count.
     * @example
     * // Count the number of ActivityLogs
     * const count = await prisma.activityLog.count({
     *   where: {
     *     // ... the filter for the ActivityLogs we want to count
     *   }
     * })
    **/
    count<T extends ActivityLogCountArgs>(
      args?: Subset<T, ActivityLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityLogAggregateArgs>(args: Subset<T, ActivityLogAggregateArgs>): Prisma.PrismaPromise<GetActivityLogAggregateType<T>>

    /**
     * Group by ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityLogGroupByArgs['orderBy'] }
        : { orderBy?: ActivityLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActivityLog model
   */
  readonly fields: ActivityLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActivityLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActivityLog model
   */
  interface ActivityLogFieldRefs {
    readonly id: FieldRef<"ActivityLog", 'String'>
    readonly entityType: FieldRef<"ActivityLog", 'String'>
    readonly entityId: FieldRef<"ActivityLog", 'String'>
    readonly action: FieldRef<"ActivityLog", 'String'>
    readonly actorId: FieldRef<"ActivityLog", 'String'>
    readonly changeDiff: FieldRef<"ActivityLog", 'Json'>
    readonly context: FieldRef<"ActivityLog", 'Json'>
    readonly createdAt: FieldRef<"ActivityLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ActivityLog findUnique
   */
  export type ActivityLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findUniqueOrThrow
   */
  export type ActivityLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findFirst
   */
  export type ActivityLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findFirstOrThrow
   */
  export type ActivityLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findMany
   */
  export type ActivityLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Filter, which ActivityLogs to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog create
   */
  export type ActivityLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * The data needed to create a ActivityLog.
     */
    data: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
  }

  /**
   * ActivityLog createMany
   */
  export type ActivityLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogCreateManyInput | ActivityLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActivityLog createManyAndReturn
   */
  export type ActivityLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogCreateManyInput | ActivityLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActivityLog update
   */
  export type ActivityLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * The data needed to update a ActivityLog.
     */
    data: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
    /**
     * Choose, which ActivityLog to update.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog updateMany
   */
  export type ActivityLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActivityLogs.
     */
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which ActivityLogs to update
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to update.
     */
    limit?: number
  }

  /**
   * ActivityLog updateManyAndReturn
   */
  export type ActivityLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * The data used to update ActivityLogs.
     */
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which ActivityLogs to update
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to update.
     */
    limit?: number
  }

  /**
   * ActivityLog upsert
   */
  export type ActivityLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * The filter to search for the ActivityLog to update in case it exists.
     */
    where: ActivityLogWhereUniqueInput
    /**
     * In case the ActivityLog found by the `where` argument doesn't exist, create a new ActivityLog with this data.
     */
    create: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
    /**
     * In case the ActivityLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
  }

  /**
   * ActivityLog delete
   */
  export type ActivityLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Filter which ActivityLog to delete.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog deleteMany
   */
  export type ActivityLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLogs to delete
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to delete.
     */
    limit?: number
  }

  /**
   * ActivityLog without action
   */
  export type ActivityLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    image: 'image',
    passwordHash: 'passwordHash',
    firstName: 'firstName',
    lastName: 'lastName',
    avatarUrl: 'avatarUrl',
    timezone: 'timezone',
    availabilityHours: 'availabilityHours',
    isActive: 'isActive',
    preferences: 'preferences',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    expiresAt: 'expiresAt',
    token: 'token',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    userId: 'userId'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    providerId: 'providerId',
    userId: 'userId',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    idToken: 'idToken',
    accessTokenExpiresAt: 'accessTokenExpiresAt',
    refreshTokenExpiresAt: 'refreshTokenExpiresAt',
    scope: 'scope',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const VerificationScalarFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    value: 'value',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VerificationScalarFieldEnum = (typeof VerificationScalarFieldEnum)[keyof typeof VerificationScalarFieldEnum]


  export const OrganizationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    planTier: 'planTier',
    settings: 'settings',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrganizationScalarFieldEnum = (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum]


  export const TeamScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    velocityHistory: 'velocityHistory',
    settings: 'settings',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    organizationId: 'organizationId'
  };

  export type TeamScalarFieldEnum = (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    permissions: 'permissions',
    createdAt: 'createdAt'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const OrganizationMembershipScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    organizationId: 'organizationId',
    role: 'role',
    joinedAt: 'joinedAt'
  };

  export type OrganizationMembershipScalarFieldEnum = (typeof OrganizationMembershipScalarFieldEnum)[keyof typeof OrganizationMembershipScalarFieldEnum]


  export const TeamMembershipScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    teamId: 'teamId',
    roleId: 'roleId',
    joinedAt: 'joinedAt',
    leftAt: 'leftAt'
  };

  export type TeamMembershipScalarFieldEnum = (typeof TeamMembershipScalarFieldEnum)[keyof typeof TeamMembershipScalarFieldEnum]


  export const PortfolioScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    strategicGoal: 'strategicGoal',
    startDate: 'startDate',
    endDate: 'endDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    organizationId: 'organizationId'
  };

  export type PortfolioScalarFieldEnum = (typeof PortfolioScalarFieldEnum)[keyof typeof PortfolioScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    key: 'key',
    name: 'name',
    description: 'description',
    projectType: 'projectType',
    riskScore: 'riskScore',
    startDate: 'startDate',
    endDate: 'endDate',
    settings: 'settings',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    portfolioId: 'portfolioId',
    organizationId: 'organizationId',
    leadUserId: 'leadUserId'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const SprintScalarFieldEnum: {
    id: 'id',
    name: 'name',
    goal: 'goal',
    startDate: 'startDate',
    endDate: 'endDate',
    state: 'state',
    committedPoints: 'committedPoints',
    completedPoints: 'completedPoints',
    velocity: 'velocity',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId'
  };

  export type SprintScalarFieldEnum = (typeof SprintScalarFieldEnum)[keyof typeof SprintScalarFieldEnum]


  export const MilestoneScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    dueDate: 'dueDate',
    completed: 'completed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId'
  };

  export type MilestoneScalarFieldEnum = (typeof MilestoneScalarFieldEnum)[keyof typeof MilestoneScalarFieldEnum]


  export const RetrospectiveScalarFieldEnum: {
    id: 'id',
    content: 'content',
    sentimentSummary: 'sentimentSummary',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    sprintId: 'sprintId'
  };

  export type RetrospectiveScalarFieldEnum = (typeof RetrospectiveScalarFieldEnum)[keyof typeof RetrospectiveScalarFieldEnum]


  export const WorkItemScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    type: 'type',
    priority: 'priority',
    storyPoints: 'storyPoints',
    estimatedHours: 'estimatedHours',
    remainingHours: 'remainingHours',
    order: 'order',
    dueDate: 'dueDate',
    completedAt: 'completedAt',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    parentId: 'parentId',
    epicId: 'epicId',
    projectId: 'projectId',
    stateId: 'stateId',
    assigneeId: 'assigneeId',
    creatorId: 'creatorId',
    sprintId: 'sprintId'
  };

  export type WorkItemScalarFieldEnum = (typeof WorkItemScalarFieldEnum)[keyof typeof WorkItemScalarFieldEnum]


  export const WorkItemDetailScalarFieldEnum: {
    id: 'id',
    acceptanceCriteria: 'acceptanceCriteria',
    technicalNotes: 'technicalNotes',
    reproSteps: 'reproSteps',
    businessValue: 'businessValue',
    userPersona: 'userPersona',
    customFields: 'customFields',
    externalReferences: 'externalReferences',
    workItemId: 'workItemId'
  };

  export type WorkItemDetailScalarFieldEnum = (typeof WorkItemDetailScalarFieldEnum)[keyof typeof WorkItemDetailScalarFieldEnum]


  export const WorkItemStateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    category: 'category',
    position: 'position',
    wipLimit: 'wipLimit',
    color: 'color',
    icon: 'icon',
    isInitial: 'isInitial',
    isFinal: 'isFinal',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId'
  };

  export type WorkItemStateScalarFieldEnum = (typeof WorkItemStateScalarFieldEnum)[keyof typeof WorkItemStateScalarFieldEnum]


  export const BoardScalarFieldEnum: {
    id: 'id',
    name: 'name',
    boardType: 'boardType',
    filterQuery: 'filterQuery',
    settings: 'settings',
    isDefault: 'isDefault',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId',
    sprintId: 'sprintId'
  };

  export type BoardScalarFieldEnum = (typeof BoardScalarFieldEnum)[keyof typeof BoardScalarFieldEnum]


  export const BoardLaneScalarFieldEnum: {
    id: 'id',
    name: 'name',
    position: 'position',
    wipLimit: 'wipLimit',
    colorConfig: 'colorConfig',
    mappedStates: 'mappedStates',
    isCollapsed: 'isCollapsed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    boardId: 'boardId'
  };

  export type BoardLaneScalarFieldEnum = (typeof BoardLaneScalarFieldEnum)[keyof typeof BoardLaneScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    color: 'color',
    description: 'description',
    createdAt: 'createdAt'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const TagOnWorkItemScalarFieldEnum: {
    workItemId: 'workItemId',
    tagId: 'tagId'
  };

  export type TagOnWorkItemScalarFieldEnum = (typeof TagOnWorkItemScalarFieldEnum)[keyof typeof TagOnWorkItemScalarFieldEnum]


  export const ComponentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    color: 'color',
    position: 'position',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId'
  };

  export type ComponentScalarFieldEnum = (typeof ComponentScalarFieldEnum)[keyof typeof ComponentScalarFieldEnum]


  export const ComponentOnWorkItemScalarFieldEnum: {
    workItemId: 'workItemId',
    componentId: 'componentId',
    assignedAt: 'assignedAt'
  };

  export type ComponentOnWorkItemScalarFieldEnum = (typeof ComponentOnWorkItemScalarFieldEnum)[keyof typeof ComponentOnWorkItemScalarFieldEnum]


  export const DependencyScalarFieldEnum: {
    id: 'id',
    dependencyType: 'dependencyType',
    description: 'description',
    createdAt: 'createdAt',
    sourceItemId: 'sourceItemId',
    targetItemId: 'targetItemId'
  };

  export type DependencyScalarFieldEnum = (typeof DependencyScalarFieldEnum)[keyof typeof DependencyScalarFieldEnum]


  export const TimeLogScalarFieldEnum: {
    id: 'id',
    duration: 'duration',
    description: 'description',
    billable: 'billable',
    logDate: 'logDate',
    startedAt: 'startedAt',
    endedAt: 'endedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    workItemId: 'workItemId',
    userId: 'userId',
    sprintId: 'sprintId'
  };

  export type TimeLogScalarFieldEnum = (typeof TimeLogScalarFieldEnum)[keyof typeof TimeLogScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    body: 'body',
    sentimentScore: 'sentimentScore',
    sentimentLabel: 'sentimentLabel',
    isInternal: 'isInternal',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    workItemId: 'workItemId',
    userId: 'userId'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const AttachmentScalarFieldEnum: {
    id: 'id',
    fileName: 'fileName',
    fileType: 'fileType',
    fileSize: 'fileSize',
    storagePath: 'storagePath',
    fileUrl: 'fileUrl',
    ocrContent: 'ocrContent',
    metadata: 'metadata',
    createdAt: 'createdAt',
    workItemId: 'workItemId',
    uploadedBy: 'uploadedBy'
  };

  export type AttachmentScalarFieldEnum = (typeof AttachmentScalarFieldEnum)[keyof typeof AttachmentScalarFieldEnum]


  export const WorkItemEmbeddingScalarFieldEnum: {
    workItemId: 'workItemId',
    version: 'version',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorkItemEmbeddingScalarFieldEnum = (typeof WorkItemEmbeddingScalarFieldEnum)[keyof typeof WorkItemEmbeddingScalarFieldEnum]


  export const WorkItemSnapshotScalarFieldEnum: {
    id: 'id',
    stateId: 'stateId',
    pointsRemaining: 'pointsRemaining',
    hoursRemaining: 'hoursRemaining',
    hoursSpent: 'hoursSpent',
    daysInCurrentState: 'daysInCurrentState',
    blockerIds: 'blockerIds',
    snapshotDate: 'snapshotDate',
    workItemId: 'workItemId',
    sprintId: 'sprintId'
  };

  export type WorkItemSnapshotScalarFieldEnum = (typeof WorkItemSnapshotScalarFieldEnum)[keyof typeof WorkItemSnapshotScalarFieldEnum]


  export const UserSkillProfileScalarFieldEnum: {
    id: 'id',
    skills: 'skills',
    proficiencyScores: 'proficiencyScores',
    certifiedSkills: 'certifiedSkills',
    overallProficiency: 'overallProficiency',
    lastUpdated: 'lastUpdated',
    userId: 'userId',
    teamId: 'teamId'
  };

  export type UserSkillProfileScalarFieldEnum = (typeof UserSkillProfileScalarFieldEnum)[keyof typeof UserSkillProfileScalarFieldEnum]


  export const WorkflowRuleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    trigger: 'trigger',
    action: 'action',
    conditions: 'conditions',
    isActive: 'isActive',
    priority: 'priority',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId'
  };

  export type WorkflowRuleScalarFieldEnum = (typeof WorkflowRuleScalarFieldEnum)[keyof typeof WorkflowRuleScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    type: 'type',
    title: 'title',
    body: 'body',
    targetUrl: 'targetUrl',
    priorityScore: 'priorityScore',
    isRead: 'isRead',
    metadata: 'metadata',
    createdAt: 'createdAt',
    readAt: 'readAt',
    userId: 'userId'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const ActivityLogScalarFieldEnum: {
    id: 'id',
    entityType: 'entityType',
    entityId: 'entityId',
    action: 'action',
    actorId: 'actorId',
    changeDiff: 'changeDiff',
    context: 'context',
    createdAt: 'createdAt'
  };

  export type ActivityLogScalarFieldEnum = (typeof ActivityLogScalarFieldEnum)[keyof typeof ActivityLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'WorkItemType'
   */
  export type EnumWorkItemTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkItemType'>
    


  /**
   * Reference to a field of type 'WorkItemType[]'
   */
  export type ListEnumWorkItemTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkItemType[]'>
    


  /**
   * Reference to a field of type 'Priority'
   */
  export type EnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority'>
    


  /**
   * Reference to a field of type 'Priority[]'
   */
  export type ListEnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority[]'>
    


  /**
   * Reference to a field of type 'WorkItemStateCategory'
   */
  export type EnumWorkItemStateCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkItemStateCategory'>
    


  /**
   * Reference to a field of type 'WorkItemStateCategory[]'
   */
  export type ListEnumWorkItemStateCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkItemStateCategory[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    image?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringNullableFilter<"User"> | string | null
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    avatarUrl?: StringNullableFilter<"User"> | string | null
    timezone?: StringFilter<"User"> | string
    availabilityHours?: IntFilter<"User"> | number
    isActive?: BoolFilter<"User"> | boolean
    preferences?: JsonFilter<"User">
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
    organizationMemberships?: OrganizationMembershipListRelationFilter
    teamMemberships?: TeamMembershipListRelationFilter
    ownedProjects?: ProjectListRelationFilter
    assignedWorkItems?: WorkItemListRelationFilter
    createdWorkItems?: WorkItemListRelationFilter
    comments?: CommentListRelationFilter
    timeLogs?: TimeLogListRelationFilter
    notifications?: NotificationListRelationFilter
    skillProfile?: XOR<UserSkillProfileNullableScalarRelationFilter, UserSkillProfileWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrderInput | SortOrder
    passwordHash?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    timezone?: SortOrder
    availabilityHours?: SortOrder
    isActive?: SortOrder
    preferences?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sessions?: SessionOrderByRelationAggregateInput
    accounts?: AccountOrderByRelationAggregateInput
    organizationMemberships?: OrganizationMembershipOrderByRelationAggregateInput
    teamMemberships?: TeamMembershipOrderByRelationAggregateInput
    ownedProjects?: ProjectOrderByRelationAggregateInput
    assignedWorkItems?: WorkItemOrderByRelationAggregateInput
    createdWorkItems?: WorkItemOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    timeLogs?: TimeLogOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    skillProfile?: UserSkillProfileOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    emailVerified?: BoolFilter<"User"> | boolean
    image?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringNullableFilter<"User"> | string | null
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    avatarUrl?: StringNullableFilter<"User"> | string | null
    timezone?: StringFilter<"User"> | string
    availabilityHours?: IntFilter<"User"> | number
    isActive?: BoolFilter<"User"> | boolean
    preferences?: JsonFilter<"User">
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
    organizationMemberships?: OrganizationMembershipListRelationFilter
    teamMemberships?: TeamMembershipListRelationFilter
    ownedProjects?: ProjectListRelationFilter
    assignedWorkItems?: WorkItemListRelationFilter
    createdWorkItems?: WorkItemListRelationFilter
    comments?: CommentListRelationFilter
    timeLogs?: TimeLogListRelationFilter
    notifications?: NotificationListRelationFilter
    skillProfile?: XOR<UserSkillProfileNullableScalarRelationFilter, UserSkillProfileWhereInput> | null
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrderInput | SortOrder
    passwordHash?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    timezone?: SortOrder
    availabilityHours?: SortOrder
    isActive?: SortOrder
    preferences?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    passwordHash?: StringNullableWithAggregatesFilter<"User"> | string | null
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    timezone?: StringWithAggregatesFilter<"User"> | string
    availabilityHours?: IntWithAggregatesFilter<"User"> | number
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    preferences?: JsonWithAggregatesFilter<"User">
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    token?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    userId?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    token?: StringWithAggregatesFilter<"Session"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userId?: StringWithAggregatesFilter<"Session"> | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    accountId?: StringWithAggregatesFilter<"Account"> | string
    providerId?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    accessToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    idToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    password?: StringNullableWithAggregatesFilter<"Account"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type VerificationWhereInput = {
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    id?: StringFilter<"Verification"> | string
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeFilter<"Verification"> | Date | string
    updatedAt?: DateTimeFilter<"Verification"> | Date | string
  }

  export type VerificationOrderByWithRelationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeFilter<"Verification"> | Date | string
    updatedAt?: DateTimeFilter<"Verification"> | Date | string
  }, "id">

  export type VerificationOrderByWithAggregationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VerificationCountOrderByAggregateInput
    _max?: VerificationMaxOrderByAggregateInput
    _min?: VerificationMinOrderByAggregateInput
  }

  export type VerificationScalarWhereWithAggregatesInput = {
    AND?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    OR?: VerificationScalarWhereWithAggregatesInput[]
    NOT?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Verification"> | string
    identifier?: StringWithAggregatesFilter<"Verification"> | string
    value?: StringWithAggregatesFilter<"Verification"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
  }

  export type OrganizationWhereInput = {
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    id?: StringFilter<"Organization"> | string
    name?: StringFilter<"Organization"> | string
    slug?: StringFilter<"Organization"> | string
    description?: StringNullableFilter<"Organization"> | string | null
    planTier?: StringFilter<"Organization"> | string
    settings?: JsonFilter<"Organization">
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    updatedAt?: DateTimeFilter<"Organization"> | Date | string
    users?: OrganizationMembershipListRelationFilter
    portfolios?: PortfolioListRelationFilter
    teams?: TeamListRelationFilter
    projects?: ProjectListRelationFilter
  }

  export type OrganizationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    planTier?: SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: OrganizationMembershipOrderByRelationAggregateInput
    portfolios?: PortfolioOrderByRelationAggregateInput
    teams?: TeamOrderByRelationAggregateInput
    projects?: ProjectOrderByRelationAggregateInput
  }

  export type OrganizationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    name?: StringFilter<"Organization"> | string
    description?: StringNullableFilter<"Organization"> | string | null
    planTier?: StringFilter<"Organization"> | string
    settings?: JsonFilter<"Organization">
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    updatedAt?: DateTimeFilter<"Organization"> | Date | string
    users?: OrganizationMembershipListRelationFilter
    portfolios?: PortfolioListRelationFilter
    teams?: TeamListRelationFilter
    projects?: ProjectListRelationFilter
  }, "id" | "slug">

  export type OrganizationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    planTier?: SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrganizationCountOrderByAggregateInput
    _max?: OrganizationMaxOrderByAggregateInput
    _min?: OrganizationMinOrderByAggregateInput
  }

  export type OrganizationScalarWhereWithAggregatesInput = {
    AND?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    OR?: OrganizationScalarWhereWithAggregatesInput[]
    NOT?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Organization"> | string
    name?: StringWithAggregatesFilter<"Organization"> | string
    slug?: StringWithAggregatesFilter<"Organization"> | string
    description?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    planTier?: StringWithAggregatesFilter<"Organization"> | string
    settings?: JsonWithAggregatesFilter<"Organization">
    createdAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
  }

  export type TeamWhereInput = {
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    id?: StringFilter<"Team"> | string
    name?: StringFilter<"Team"> | string
    description?: StringNullableFilter<"Team"> | string | null
    velocityHistory?: JsonFilter<"Team">
    settings?: JsonFilter<"Team">
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    organizationId?: StringFilter<"Team"> | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    members?: TeamMembershipListRelationFilter
    projects?: ProjectListRelationFilter
    skillProfiles?: UserSkillProfileListRelationFilter
  }

  export type TeamOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    velocityHistory?: SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organizationId?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    members?: TeamMembershipOrderByRelationAggregateInput
    projects?: ProjectOrderByRelationAggregateInput
    skillProfiles?: UserSkillProfileOrderByRelationAggregateInput
  }

  export type TeamWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    name?: StringFilter<"Team"> | string
    description?: StringNullableFilter<"Team"> | string | null
    velocityHistory?: JsonFilter<"Team">
    settings?: JsonFilter<"Team">
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    organizationId?: StringFilter<"Team"> | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    members?: TeamMembershipListRelationFilter
    projects?: ProjectListRelationFilter
    skillProfiles?: UserSkillProfileListRelationFilter
  }, "id">

  export type TeamOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    velocityHistory?: SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organizationId?: SortOrder
    _count?: TeamCountOrderByAggregateInput
    _max?: TeamMaxOrderByAggregateInput
    _min?: TeamMinOrderByAggregateInput
  }

  export type TeamScalarWhereWithAggregatesInput = {
    AND?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    OR?: TeamScalarWhereWithAggregatesInput[]
    NOT?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Team"> | string
    name?: StringWithAggregatesFilter<"Team"> | string
    description?: StringNullableWithAggregatesFilter<"Team"> | string | null
    velocityHistory?: JsonWithAggregatesFilter<"Team">
    settings?: JsonWithAggregatesFilter<"Team">
    createdAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
    organizationId?: StringWithAggregatesFilter<"Team"> | string
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: StringFilter<"Role"> | string
    name?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    permissions?: JsonFilter<"Role">
    createdAt?: DateTimeFilter<"Role"> | Date | string
    teamMemberships?: TeamMembershipListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    permissions?: SortOrder
    createdAt?: SortOrder
    teamMemberships?: TeamMembershipOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    description?: StringNullableFilter<"Role"> | string | null
    permissions?: JsonFilter<"Role">
    createdAt?: DateTimeFilter<"Role"> | Date | string
    teamMemberships?: TeamMembershipListRelationFilter
  }, "id" | "name">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    permissions?: SortOrder
    createdAt?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Role"> | string
    name?: StringWithAggregatesFilter<"Role"> | string
    description?: StringNullableWithAggregatesFilter<"Role"> | string | null
    permissions?: JsonWithAggregatesFilter<"Role">
    createdAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
  }

  export type OrganizationMembershipWhereInput = {
    AND?: OrganizationMembershipWhereInput | OrganizationMembershipWhereInput[]
    OR?: OrganizationMembershipWhereInput[]
    NOT?: OrganizationMembershipWhereInput | OrganizationMembershipWhereInput[]
    id?: StringFilter<"OrganizationMembership"> | string
    userId?: StringFilter<"OrganizationMembership"> | string
    organizationId?: StringFilter<"OrganizationMembership"> | string
    role?: StringFilter<"OrganizationMembership"> | string
    joinedAt?: DateTimeFilter<"OrganizationMembership"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }

  export type OrganizationMembershipOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    organizationId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    organization?: OrganizationOrderByWithRelationInput
  }

  export type OrganizationMembershipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_organizationId?: OrganizationMembershipUserIdOrganizationIdCompoundUniqueInput
    AND?: OrganizationMembershipWhereInput | OrganizationMembershipWhereInput[]
    OR?: OrganizationMembershipWhereInput[]
    NOT?: OrganizationMembershipWhereInput | OrganizationMembershipWhereInput[]
    userId?: StringFilter<"OrganizationMembership"> | string
    organizationId?: StringFilter<"OrganizationMembership"> | string
    role?: StringFilter<"OrganizationMembership"> | string
    joinedAt?: DateTimeFilter<"OrganizationMembership"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }, "id" | "userId_organizationId">

  export type OrganizationMembershipOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    organizationId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    _count?: OrganizationMembershipCountOrderByAggregateInput
    _max?: OrganizationMembershipMaxOrderByAggregateInput
    _min?: OrganizationMembershipMinOrderByAggregateInput
  }

  export type OrganizationMembershipScalarWhereWithAggregatesInput = {
    AND?: OrganizationMembershipScalarWhereWithAggregatesInput | OrganizationMembershipScalarWhereWithAggregatesInput[]
    OR?: OrganizationMembershipScalarWhereWithAggregatesInput[]
    NOT?: OrganizationMembershipScalarWhereWithAggregatesInput | OrganizationMembershipScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrganizationMembership"> | string
    userId?: StringWithAggregatesFilter<"OrganizationMembership"> | string
    organizationId?: StringWithAggregatesFilter<"OrganizationMembership"> | string
    role?: StringWithAggregatesFilter<"OrganizationMembership"> | string
    joinedAt?: DateTimeWithAggregatesFilter<"OrganizationMembership"> | Date | string
  }

  export type TeamMembershipWhereInput = {
    AND?: TeamMembershipWhereInput | TeamMembershipWhereInput[]
    OR?: TeamMembershipWhereInput[]
    NOT?: TeamMembershipWhereInput | TeamMembershipWhereInput[]
    id?: StringFilter<"TeamMembership"> | string
    userId?: StringFilter<"TeamMembership"> | string
    teamId?: StringFilter<"TeamMembership"> | string
    roleId?: StringNullableFilter<"TeamMembership"> | string | null
    joinedAt?: DateTimeFilter<"TeamMembership"> | Date | string
    leftAt?: DateTimeNullableFilter<"TeamMembership"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    role?: XOR<RoleNullableScalarRelationFilter, RoleWhereInput> | null
  }

  export type TeamMembershipOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
    roleId?: SortOrderInput | SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    team?: TeamOrderByWithRelationInput
    role?: RoleOrderByWithRelationInput
  }

  export type TeamMembershipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TeamMembershipWhereInput | TeamMembershipWhereInput[]
    OR?: TeamMembershipWhereInput[]
    NOT?: TeamMembershipWhereInput | TeamMembershipWhereInput[]
    userId?: StringFilter<"TeamMembership"> | string
    teamId?: StringFilter<"TeamMembership"> | string
    roleId?: StringNullableFilter<"TeamMembership"> | string | null
    joinedAt?: DateTimeFilter<"TeamMembership"> | Date | string
    leftAt?: DateTimeNullableFilter<"TeamMembership"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    role?: XOR<RoleNullableScalarRelationFilter, RoleWhereInput> | null
  }, "id">

  export type TeamMembershipOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
    roleId?: SortOrderInput | SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrderInput | SortOrder
    _count?: TeamMembershipCountOrderByAggregateInput
    _max?: TeamMembershipMaxOrderByAggregateInput
    _min?: TeamMembershipMinOrderByAggregateInput
  }

  export type TeamMembershipScalarWhereWithAggregatesInput = {
    AND?: TeamMembershipScalarWhereWithAggregatesInput | TeamMembershipScalarWhereWithAggregatesInput[]
    OR?: TeamMembershipScalarWhereWithAggregatesInput[]
    NOT?: TeamMembershipScalarWhereWithAggregatesInput | TeamMembershipScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TeamMembership"> | string
    userId?: StringWithAggregatesFilter<"TeamMembership"> | string
    teamId?: StringWithAggregatesFilter<"TeamMembership"> | string
    roleId?: StringNullableWithAggregatesFilter<"TeamMembership"> | string | null
    joinedAt?: DateTimeWithAggregatesFilter<"TeamMembership"> | Date | string
    leftAt?: DateTimeNullableWithAggregatesFilter<"TeamMembership"> | Date | string | null
  }

  export type PortfolioWhereInput = {
    AND?: PortfolioWhereInput | PortfolioWhereInput[]
    OR?: PortfolioWhereInput[]
    NOT?: PortfolioWhereInput | PortfolioWhereInput[]
    id?: StringFilter<"Portfolio"> | string
    name?: StringFilter<"Portfolio"> | string
    description?: StringNullableFilter<"Portfolio"> | string | null
    strategicGoal?: StringNullableFilter<"Portfolio"> | string | null
    startDate?: DateTimeNullableFilter<"Portfolio"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Portfolio"> | Date | string | null
    createdAt?: DateTimeFilter<"Portfolio"> | Date | string
    updatedAt?: DateTimeFilter<"Portfolio"> | Date | string
    organizationId?: StringFilter<"Portfolio"> | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    projects?: ProjectListRelationFilter
  }

  export type PortfolioOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    strategicGoal?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organizationId?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    projects?: ProjectOrderByRelationAggregateInput
  }

  export type PortfolioWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PortfolioWhereInput | PortfolioWhereInput[]
    OR?: PortfolioWhereInput[]
    NOT?: PortfolioWhereInput | PortfolioWhereInput[]
    name?: StringFilter<"Portfolio"> | string
    description?: StringNullableFilter<"Portfolio"> | string | null
    strategicGoal?: StringNullableFilter<"Portfolio"> | string | null
    startDate?: DateTimeNullableFilter<"Portfolio"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Portfolio"> | Date | string | null
    createdAt?: DateTimeFilter<"Portfolio"> | Date | string
    updatedAt?: DateTimeFilter<"Portfolio"> | Date | string
    organizationId?: StringFilter<"Portfolio"> | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    projects?: ProjectListRelationFilter
  }, "id">

  export type PortfolioOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    strategicGoal?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organizationId?: SortOrder
    _count?: PortfolioCountOrderByAggregateInput
    _max?: PortfolioMaxOrderByAggregateInput
    _min?: PortfolioMinOrderByAggregateInput
  }

  export type PortfolioScalarWhereWithAggregatesInput = {
    AND?: PortfolioScalarWhereWithAggregatesInput | PortfolioScalarWhereWithAggregatesInput[]
    OR?: PortfolioScalarWhereWithAggregatesInput[]
    NOT?: PortfolioScalarWhereWithAggregatesInput | PortfolioScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Portfolio"> | string
    name?: StringWithAggregatesFilter<"Portfolio"> | string
    description?: StringNullableWithAggregatesFilter<"Portfolio"> | string | null
    strategicGoal?: StringNullableWithAggregatesFilter<"Portfolio"> | string | null
    startDate?: DateTimeNullableWithAggregatesFilter<"Portfolio"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"Portfolio"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Portfolio"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Portfolio"> | Date | string
    organizationId?: StringWithAggregatesFilter<"Portfolio"> | string
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: StringFilter<"Project"> | string
    key?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    projectType?: StringFilter<"Project"> | string
    riskScore?: FloatFilter<"Project"> | number
    startDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    settings?: JsonFilter<"Project">
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    portfolioId?: StringNullableFilter<"Project"> | string | null
    organizationId?: StringFilter<"Project"> | string
    leadUserId?: StringNullableFilter<"Project"> | string | null
    portfolio?: XOR<PortfolioNullableScalarRelationFilter, PortfolioWhereInput> | null
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    leadUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    workItems?: WorkItemListRelationFilter
    sprints?: SprintListRelationFilter
    milestones?: MilestoneListRelationFilter
    boards?: BoardListRelationFilter
    workflowRules?: WorkflowRuleListRelationFilter
    workItemStates?: WorkItemStateListRelationFilter
    components?: ComponentListRelationFilter
    teams?: TeamListRelationFilter
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    projectType?: SortOrder
    riskScore?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    portfolioId?: SortOrderInput | SortOrder
    organizationId?: SortOrder
    leadUserId?: SortOrderInput | SortOrder
    portfolio?: PortfolioOrderByWithRelationInput
    organization?: OrganizationOrderByWithRelationInput
    leadUser?: UserOrderByWithRelationInput
    workItems?: WorkItemOrderByRelationAggregateInput
    sprints?: SprintOrderByRelationAggregateInput
    milestones?: MilestoneOrderByRelationAggregateInput
    boards?: BoardOrderByRelationAggregateInput
    workflowRules?: WorkflowRuleOrderByRelationAggregateInput
    workItemStates?: WorkItemStateOrderByRelationAggregateInput
    components?: ComponentOrderByRelationAggregateInput
    teams?: TeamOrderByRelationAggregateInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    organizationId_key?: ProjectOrganizationIdKeyCompoundUniqueInput
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    key?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    projectType?: StringFilter<"Project"> | string
    riskScore?: FloatFilter<"Project"> | number
    startDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    settings?: JsonFilter<"Project">
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    portfolioId?: StringNullableFilter<"Project"> | string | null
    organizationId?: StringFilter<"Project"> | string
    leadUserId?: StringNullableFilter<"Project"> | string | null
    portfolio?: XOR<PortfolioNullableScalarRelationFilter, PortfolioWhereInput> | null
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    leadUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    workItems?: WorkItemListRelationFilter
    sprints?: SprintListRelationFilter
    milestones?: MilestoneListRelationFilter
    boards?: BoardListRelationFilter
    workflowRules?: WorkflowRuleListRelationFilter
    workItemStates?: WorkItemStateListRelationFilter
    components?: ComponentListRelationFilter
    teams?: TeamListRelationFilter
  }, "id" | "organizationId_key">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    projectType?: SortOrder
    riskScore?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    portfolioId?: SortOrderInput | SortOrder
    organizationId?: SortOrder
    leadUserId?: SortOrderInput | SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _avg?: ProjectAvgOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
    _sum?: ProjectSumOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Project"> | string
    key?: StringWithAggregatesFilter<"Project"> | string
    name?: StringWithAggregatesFilter<"Project"> | string
    description?: StringNullableWithAggregatesFilter<"Project"> | string | null
    projectType?: StringWithAggregatesFilter<"Project"> | string
    riskScore?: FloatWithAggregatesFilter<"Project"> | number
    startDate?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    settings?: JsonWithAggregatesFilter<"Project">
    createdAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    portfolioId?: StringNullableWithAggregatesFilter<"Project"> | string | null
    organizationId?: StringWithAggregatesFilter<"Project"> | string
    leadUserId?: StringNullableWithAggregatesFilter<"Project"> | string | null
  }

  export type SprintWhereInput = {
    AND?: SprintWhereInput | SprintWhereInput[]
    OR?: SprintWhereInput[]
    NOT?: SprintWhereInput | SprintWhereInput[]
    id?: StringFilter<"Sprint"> | string
    name?: StringFilter<"Sprint"> | string
    goal?: StringNullableFilter<"Sprint"> | string | null
    startDate?: DateTimeFilter<"Sprint"> | Date | string
    endDate?: DateTimeFilter<"Sprint"> | Date | string
    state?: StringFilter<"Sprint"> | string
    committedPoints?: FloatFilter<"Sprint"> | number
    completedPoints?: FloatFilter<"Sprint"> | number
    velocity?: FloatNullableFilter<"Sprint"> | number | null
    createdAt?: DateTimeFilter<"Sprint"> | Date | string
    updatedAt?: DateTimeFilter<"Sprint"> | Date | string
    projectId?: StringFilter<"Sprint"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    workItems?: WorkItemListRelationFilter
    snapshots?: WorkItemSnapshotListRelationFilter
    retrospective?: XOR<RetrospectiveNullableScalarRelationFilter, RetrospectiveWhereInput> | null
    timeLogs?: TimeLogListRelationFilter
    boards?: BoardListRelationFilter
  }

  export type SprintOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    goal?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    state?: SortOrder
    committedPoints?: SortOrder
    completedPoints?: SortOrder
    velocity?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    project?: ProjectOrderByWithRelationInput
    workItems?: WorkItemOrderByRelationAggregateInput
    snapshots?: WorkItemSnapshotOrderByRelationAggregateInput
    retrospective?: RetrospectiveOrderByWithRelationInput
    timeLogs?: TimeLogOrderByRelationAggregateInput
    boards?: BoardOrderByRelationAggregateInput
  }

  export type SprintWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SprintWhereInput | SprintWhereInput[]
    OR?: SprintWhereInput[]
    NOT?: SprintWhereInput | SprintWhereInput[]
    name?: StringFilter<"Sprint"> | string
    goal?: StringNullableFilter<"Sprint"> | string | null
    startDate?: DateTimeFilter<"Sprint"> | Date | string
    endDate?: DateTimeFilter<"Sprint"> | Date | string
    state?: StringFilter<"Sprint"> | string
    committedPoints?: FloatFilter<"Sprint"> | number
    completedPoints?: FloatFilter<"Sprint"> | number
    velocity?: FloatNullableFilter<"Sprint"> | number | null
    createdAt?: DateTimeFilter<"Sprint"> | Date | string
    updatedAt?: DateTimeFilter<"Sprint"> | Date | string
    projectId?: StringFilter<"Sprint"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    workItems?: WorkItemListRelationFilter
    snapshots?: WorkItemSnapshotListRelationFilter
    retrospective?: XOR<RetrospectiveNullableScalarRelationFilter, RetrospectiveWhereInput> | null
    timeLogs?: TimeLogListRelationFilter
    boards?: BoardListRelationFilter
  }, "id">

  export type SprintOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    goal?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    state?: SortOrder
    committedPoints?: SortOrder
    completedPoints?: SortOrder
    velocity?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    _count?: SprintCountOrderByAggregateInput
    _avg?: SprintAvgOrderByAggregateInput
    _max?: SprintMaxOrderByAggregateInput
    _min?: SprintMinOrderByAggregateInput
    _sum?: SprintSumOrderByAggregateInput
  }

  export type SprintScalarWhereWithAggregatesInput = {
    AND?: SprintScalarWhereWithAggregatesInput | SprintScalarWhereWithAggregatesInput[]
    OR?: SprintScalarWhereWithAggregatesInput[]
    NOT?: SprintScalarWhereWithAggregatesInput | SprintScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Sprint"> | string
    name?: StringWithAggregatesFilter<"Sprint"> | string
    goal?: StringNullableWithAggregatesFilter<"Sprint"> | string | null
    startDate?: DateTimeWithAggregatesFilter<"Sprint"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Sprint"> | Date | string
    state?: StringWithAggregatesFilter<"Sprint"> | string
    committedPoints?: FloatWithAggregatesFilter<"Sprint"> | number
    completedPoints?: FloatWithAggregatesFilter<"Sprint"> | number
    velocity?: FloatNullableWithAggregatesFilter<"Sprint"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Sprint"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Sprint"> | Date | string
    projectId?: StringWithAggregatesFilter<"Sprint"> | string
  }

  export type MilestoneWhereInput = {
    AND?: MilestoneWhereInput | MilestoneWhereInput[]
    OR?: MilestoneWhereInput[]
    NOT?: MilestoneWhereInput | MilestoneWhereInput[]
    id?: StringFilter<"Milestone"> | string
    name?: StringFilter<"Milestone"> | string
    description?: StringNullableFilter<"Milestone"> | string | null
    dueDate?: DateTimeFilter<"Milestone"> | Date | string
    completed?: BoolFilter<"Milestone"> | boolean
    createdAt?: DateTimeFilter<"Milestone"> | Date | string
    updatedAt?: DateTimeFilter<"Milestone"> | Date | string
    projectId?: StringFilter<"Milestone"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type MilestoneOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    dueDate?: SortOrder
    completed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type MilestoneWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MilestoneWhereInput | MilestoneWhereInput[]
    OR?: MilestoneWhereInput[]
    NOT?: MilestoneWhereInput | MilestoneWhereInput[]
    name?: StringFilter<"Milestone"> | string
    description?: StringNullableFilter<"Milestone"> | string | null
    dueDate?: DateTimeFilter<"Milestone"> | Date | string
    completed?: BoolFilter<"Milestone"> | boolean
    createdAt?: DateTimeFilter<"Milestone"> | Date | string
    updatedAt?: DateTimeFilter<"Milestone"> | Date | string
    projectId?: StringFilter<"Milestone"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id">

  export type MilestoneOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    dueDate?: SortOrder
    completed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    _count?: MilestoneCountOrderByAggregateInput
    _max?: MilestoneMaxOrderByAggregateInput
    _min?: MilestoneMinOrderByAggregateInput
  }

  export type MilestoneScalarWhereWithAggregatesInput = {
    AND?: MilestoneScalarWhereWithAggregatesInput | MilestoneScalarWhereWithAggregatesInput[]
    OR?: MilestoneScalarWhereWithAggregatesInput[]
    NOT?: MilestoneScalarWhereWithAggregatesInput | MilestoneScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Milestone"> | string
    name?: StringWithAggregatesFilter<"Milestone"> | string
    description?: StringNullableWithAggregatesFilter<"Milestone"> | string | null
    dueDate?: DateTimeWithAggregatesFilter<"Milestone"> | Date | string
    completed?: BoolWithAggregatesFilter<"Milestone"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Milestone"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Milestone"> | Date | string
    projectId?: StringWithAggregatesFilter<"Milestone"> | string
  }

  export type RetrospectiveWhereInput = {
    AND?: RetrospectiveWhereInput | RetrospectiveWhereInput[]
    OR?: RetrospectiveWhereInput[]
    NOT?: RetrospectiveWhereInput | RetrospectiveWhereInput[]
    id?: StringFilter<"Retrospective"> | string
    content?: JsonFilter<"Retrospective">
    sentimentSummary?: StringNullableFilter<"Retrospective"> | string | null
    createdAt?: DateTimeFilter<"Retrospective"> | Date | string
    updatedAt?: DateTimeFilter<"Retrospective"> | Date | string
    sprintId?: StringFilter<"Retrospective"> | string
    sprint?: XOR<SprintScalarRelationFilter, SprintWhereInput>
  }

  export type RetrospectiveOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    sentimentSummary?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sprintId?: SortOrder
    sprint?: SprintOrderByWithRelationInput
  }

  export type RetrospectiveWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sprintId?: string
    AND?: RetrospectiveWhereInput | RetrospectiveWhereInput[]
    OR?: RetrospectiveWhereInput[]
    NOT?: RetrospectiveWhereInput | RetrospectiveWhereInput[]
    content?: JsonFilter<"Retrospective">
    sentimentSummary?: StringNullableFilter<"Retrospective"> | string | null
    createdAt?: DateTimeFilter<"Retrospective"> | Date | string
    updatedAt?: DateTimeFilter<"Retrospective"> | Date | string
    sprint?: XOR<SprintScalarRelationFilter, SprintWhereInput>
  }, "id" | "sprintId">

  export type RetrospectiveOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    sentimentSummary?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sprintId?: SortOrder
    _count?: RetrospectiveCountOrderByAggregateInput
    _max?: RetrospectiveMaxOrderByAggregateInput
    _min?: RetrospectiveMinOrderByAggregateInput
  }

  export type RetrospectiveScalarWhereWithAggregatesInput = {
    AND?: RetrospectiveScalarWhereWithAggregatesInput | RetrospectiveScalarWhereWithAggregatesInput[]
    OR?: RetrospectiveScalarWhereWithAggregatesInput[]
    NOT?: RetrospectiveScalarWhereWithAggregatesInput | RetrospectiveScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Retrospective"> | string
    content?: JsonWithAggregatesFilter<"Retrospective">
    sentimentSummary?: StringNullableWithAggregatesFilter<"Retrospective"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Retrospective"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Retrospective"> | Date | string
    sprintId?: StringWithAggregatesFilter<"Retrospective"> | string
  }

  export type WorkItemWhereInput = {
    AND?: WorkItemWhereInput | WorkItemWhereInput[]
    OR?: WorkItemWhereInput[]
    NOT?: WorkItemWhereInput | WorkItemWhereInput[]
    id?: StringFilter<"WorkItem"> | string
    title?: StringFilter<"WorkItem"> | string
    description?: StringNullableFilter<"WorkItem"> | string | null
    type?: EnumWorkItemTypeFilter<"WorkItem"> | $Enums.WorkItemType
    priority?: EnumPriorityFilter<"WorkItem"> | $Enums.Priority
    storyPoints?: FloatNullableFilter<"WorkItem"> | number | null
    estimatedHours?: FloatNullableFilter<"WorkItem"> | number | null
    remainingHours?: FloatNullableFilter<"WorkItem"> | number | null
    order?: IntFilter<"WorkItem"> | number
    dueDate?: DateTimeNullableFilter<"WorkItem"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"WorkItem"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"WorkItem"> | Date | string | null
    createdAt?: DateTimeFilter<"WorkItem"> | Date | string
    updatedAt?: DateTimeFilter<"WorkItem"> | Date | string
    parentId?: StringNullableFilter<"WorkItem"> | string | null
    epicId?: StringNullableFilter<"WorkItem"> | string | null
    projectId?: StringFilter<"WorkItem"> | string
    stateId?: StringNullableFilter<"WorkItem"> | string | null
    assigneeId?: StringNullableFilter<"WorkItem"> | string | null
    creatorId?: StringFilter<"WorkItem"> | string
    sprintId?: StringNullableFilter<"WorkItem"> | string | null
    parent?: XOR<WorkItemNullableScalarRelationFilter, WorkItemWhereInput> | null
    children?: WorkItemListRelationFilter
    epic?: XOR<WorkItemNullableScalarRelationFilter, WorkItemWhereInput> | null
    stories?: WorkItemListRelationFilter
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    state?: XOR<WorkItemStateNullableScalarRelationFilter, WorkItemStateWhereInput> | null
    assignee?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    sprint?: XOR<SprintNullableScalarRelationFilter, SprintWhereInput> | null
    details?: XOR<WorkItemDetailNullableScalarRelationFilter, WorkItemDetailWhereInput> | null
    dependenciesAsSource?: DependencyListRelationFilter
    dependenciesAsTarget?: DependencyListRelationFilter
    comments?: CommentListRelationFilter
    attachments?: AttachmentListRelationFilter
    timeLogs?: TimeLogListRelationFilter
    snapshots?: WorkItemSnapshotListRelationFilter
    tags?: TagOnWorkItemListRelationFilter
    components?: ComponentOnWorkItemListRelationFilter
    embedding?: XOR<WorkItemEmbeddingNullableScalarRelationFilter, WorkItemEmbeddingWhereInput> | null
  }

  export type WorkItemOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    priority?: SortOrder
    storyPoints?: SortOrderInput | SortOrder
    estimatedHours?: SortOrderInput | SortOrder
    remainingHours?: SortOrderInput | SortOrder
    order?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrderInput | SortOrder
    epicId?: SortOrderInput | SortOrder
    projectId?: SortOrder
    stateId?: SortOrderInput | SortOrder
    assigneeId?: SortOrderInput | SortOrder
    creatorId?: SortOrder
    sprintId?: SortOrderInput | SortOrder
    parent?: WorkItemOrderByWithRelationInput
    children?: WorkItemOrderByRelationAggregateInput
    epic?: WorkItemOrderByWithRelationInput
    stories?: WorkItemOrderByRelationAggregateInput
    project?: ProjectOrderByWithRelationInput
    state?: WorkItemStateOrderByWithRelationInput
    assignee?: UserOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    sprint?: SprintOrderByWithRelationInput
    details?: WorkItemDetailOrderByWithRelationInput
    dependenciesAsSource?: DependencyOrderByRelationAggregateInput
    dependenciesAsTarget?: DependencyOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    attachments?: AttachmentOrderByRelationAggregateInput
    timeLogs?: TimeLogOrderByRelationAggregateInput
    snapshots?: WorkItemSnapshotOrderByRelationAggregateInput
    tags?: TagOnWorkItemOrderByRelationAggregateInput
    components?: ComponentOnWorkItemOrderByRelationAggregateInput
    embedding?: WorkItemEmbeddingOrderByWithRelationInput
  }

  export type WorkItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkItemWhereInput | WorkItemWhereInput[]
    OR?: WorkItemWhereInput[]
    NOT?: WorkItemWhereInput | WorkItemWhereInput[]
    title?: StringFilter<"WorkItem"> | string
    description?: StringNullableFilter<"WorkItem"> | string | null
    type?: EnumWorkItemTypeFilter<"WorkItem"> | $Enums.WorkItemType
    priority?: EnumPriorityFilter<"WorkItem"> | $Enums.Priority
    storyPoints?: FloatNullableFilter<"WorkItem"> | number | null
    estimatedHours?: FloatNullableFilter<"WorkItem"> | number | null
    remainingHours?: FloatNullableFilter<"WorkItem"> | number | null
    order?: IntFilter<"WorkItem"> | number
    dueDate?: DateTimeNullableFilter<"WorkItem"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"WorkItem"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"WorkItem"> | Date | string | null
    createdAt?: DateTimeFilter<"WorkItem"> | Date | string
    updatedAt?: DateTimeFilter<"WorkItem"> | Date | string
    parentId?: StringNullableFilter<"WorkItem"> | string | null
    epicId?: StringNullableFilter<"WorkItem"> | string | null
    projectId?: StringFilter<"WorkItem"> | string
    stateId?: StringNullableFilter<"WorkItem"> | string | null
    assigneeId?: StringNullableFilter<"WorkItem"> | string | null
    creatorId?: StringFilter<"WorkItem"> | string
    sprintId?: StringNullableFilter<"WorkItem"> | string | null
    parent?: XOR<WorkItemNullableScalarRelationFilter, WorkItemWhereInput> | null
    children?: WorkItemListRelationFilter
    epic?: XOR<WorkItemNullableScalarRelationFilter, WorkItemWhereInput> | null
    stories?: WorkItemListRelationFilter
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    state?: XOR<WorkItemStateNullableScalarRelationFilter, WorkItemStateWhereInput> | null
    assignee?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    sprint?: XOR<SprintNullableScalarRelationFilter, SprintWhereInput> | null
    details?: XOR<WorkItemDetailNullableScalarRelationFilter, WorkItemDetailWhereInput> | null
    dependenciesAsSource?: DependencyListRelationFilter
    dependenciesAsTarget?: DependencyListRelationFilter
    comments?: CommentListRelationFilter
    attachments?: AttachmentListRelationFilter
    timeLogs?: TimeLogListRelationFilter
    snapshots?: WorkItemSnapshotListRelationFilter
    tags?: TagOnWorkItemListRelationFilter
    components?: ComponentOnWorkItemListRelationFilter
    embedding?: XOR<WorkItemEmbeddingNullableScalarRelationFilter, WorkItemEmbeddingWhereInput> | null
  }, "id">

  export type WorkItemOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    priority?: SortOrder
    storyPoints?: SortOrderInput | SortOrder
    estimatedHours?: SortOrderInput | SortOrder
    remainingHours?: SortOrderInput | SortOrder
    order?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrderInput | SortOrder
    epicId?: SortOrderInput | SortOrder
    projectId?: SortOrder
    stateId?: SortOrderInput | SortOrder
    assigneeId?: SortOrderInput | SortOrder
    creatorId?: SortOrder
    sprintId?: SortOrderInput | SortOrder
    _count?: WorkItemCountOrderByAggregateInput
    _avg?: WorkItemAvgOrderByAggregateInput
    _max?: WorkItemMaxOrderByAggregateInput
    _min?: WorkItemMinOrderByAggregateInput
    _sum?: WorkItemSumOrderByAggregateInput
  }

  export type WorkItemScalarWhereWithAggregatesInput = {
    AND?: WorkItemScalarWhereWithAggregatesInput | WorkItemScalarWhereWithAggregatesInput[]
    OR?: WorkItemScalarWhereWithAggregatesInput[]
    NOT?: WorkItemScalarWhereWithAggregatesInput | WorkItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkItem"> | string
    title?: StringWithAggregatesFilter<"WorkItem"> | string
    description?: StringNullableWithAggregatesFilter<"WorkItem"> | string | null
    type?: EnumWorkItemTypeWithAggregatesFilter<"WorkItem"> | $Enums.WorkItemType
    priority?: EnumPriorityWithAggregatesFilter<"WorkItem"> | $Enums.Priority
    storyPoints?: FloatNullableWithAggregatesFilter<"WorkItem"> | number | null
    estimatedHours?: FloatNullableWithAggregatesFilter<"WorkItem"> | number | null
    remainingHours?: FloatNullableWithAggregatesFilter<"WorkItem"> | number | null
    order?: IntWithAggregatesFilter<"WorkItem"> | number
    dueDate?: DateTimeNullableWithAggregatesFilter<"WorkItem"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"WorkItem"> | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"WorkItem"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WorkItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WorkItem"> | Date | string
    parentId?: StringNullableWithAggregatesFilter<"WorkItem"> | string | null
    epicId?: StringNullableWithAggregatesFilter<"WorkItem"> | string | null
    projectId?: StringWithAggregatesFilter<"WorkItem"> | string
    stateId?: StringNullableWithAggregatesFilter<"WorkItem"> | string | null
    assigneeId?: StringNullableWithAggregatesFilter<"WorkItem"> | string | null
    creatorId?: StringWithAggregatesFilter<"WorkItem"> | string
    sprintId?: StringNullableWithAggregatesFilter<"WorkItem"> | string | null
  }

  export type WorkItemDetailWhereInput = {
    AND?: WorkItemDetailWhereInput | WorkItemDetailWhereInput[]
    OR?: WorkItemDetailWhereInput[]
    NOT?: WorkItemDetailWhereInput | WorkItemDetailWhereInput[]
    id?: StringFilter<"WorkItemDetail"> | string
    acceptanceCriteria?: StringNullableFilter<"WorkItemDetail"> | string | null
    technicalNotes?: StringNullableFilter<"WorkItemDetail"> | string | null
    reproSteps?: StringNullableFilter<"WorkItemDetail"> | string | null
    businessValue?: StringNullableFilter<"WorkItemDetail"> | string | null
    userPersona?: StringNullableFilter<"WorkItemDetail"> | string | null
    customFields?: JsonFilter<"WorkItemDetail">
    externalReferences?: StringNullableFilter<"WorkItemDetail"> | string | null
    workItemId?: StringFilter<"WorkItemDetail"> | string
    workItem?: XOR<WorkItemScalarRelationFilter, WorkItemWhereInput>
  }

  export type WorkItemDetailOrderByWithRelationInput = {
    id?: SortOrder
    acceptanceCriteria?: SortOrderInput | SortOrder
    technicalNotes?: SortOrderInput | SortOrder
    reproSteps?: SortOrderInput | SortOrder
    businessValue?: SortOrderInput | SortOrder
    userPersona?: SortOrderInput | SortOrder
    customFields?: SortOrder
    externalReferences?: SortOrderInput | SortOrder
    workItemId?: SortOrder
    workItem?: WorkItemOrderByWithRelationInput
  }

  export type WorkItemDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    workItemId?: string
    AND?: WorkItemDetailWhereInput | WorkItemDetailWhereInput[]
    OR?: WorkItemDetailWhereInput[]
    NOT?: WorkItemDetailWhereInput | WorkItemDetailWhereInput[]
    acceptanceCriteria?: StringNullableFilter<"WorkItemDetail"> | string | null
    technicalNotes?: StringNullableFilter<"WorkItemDetail"> | string | null
    reproSteps?: StringNullableFilter<"WorkItemDetail"> | string | null
    businessValue?: StringNullableFilter<"WorkItemDetail"> | string | null
    userPersona?: StringNullableFilter<"WorkItemDetail"> | string | null
    customFields?: JsonFilter<"WorkItemDetail">
    externalReferences?: StringNullableFilter<"WorkItemDetail"> | string | null
    workItem?: XOR<WorkItemScalarRelationFilter, WorkItemWhereInput>
  }, "id" | "workItemId">

  export type WorkItemDetailOrderByWithAggregationInput = {
    id?: SortOrder
    acceptanceCriteria?: SortOrderInput | SortOrder
    technicalNotes?: SortOrderInput | SortOrder
    reproSteps?: SortOrderInput | SortOrder
    businessValue?: SortOrderInput | SortOrder
    userPersona?: SortOrderInput | SortOrder
    customFields?: SortOrder
    externalReferences?: SortOrderInput | SortOrder
    workItemId?: SortOrder
    _count?: WorkItemDetailCountOrderByAggregateInput
    _max?: WorkItemDetailMaxOrderByAggregateInput
    _min?: WorkItemDetailMinOrderByAggregateInput
  }

  export type WorkItemDetailScalarWhereWithAggregatesInput = {
    AND?: WorkItemDetailScalarWhereWithAggregatesInput | WorkItemDetailScalarWhereWithAggregatesInput[]
    OR?: WorkItemDetailScalarWhereWithAggregatesInput[]
    NOT?: WorkItemDetailScalarWhereWithAggregatesInput | WorkItemDetailScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkItemDetail"> | string
    acceptanceCriteria?: StringNullableWithAggregatesFilter<"WorkItemDetail"> | string | null
    technicalNotes?: StringNullableWithAggregatesFilter<"WorkItemDetail"> | string | null
    reproSteps?: StringNullableWithAggregatesFilter<"WorkItemDetail"> | string | null
    businessValue?: StringNullableWithAggregatesFilter<"WorkItemDetail"> | string | null
    userPersona?: StringNullableWithAggregatesFilter<"WorkItemDetail"> | string | null
    customFields?: JsonWithAggregatesFilter<"WorkItemDetail">
    externalReferences?: StringNullableWithAggregatesFilter<"WorkItemDetail"> | string | null
    workItemId?: StringWithAggregatesFilter<"WorkItemDetail"> | string
  }

  export type WorkItemStateWhereInput = {
    AND?: WorkItemStateWhereInput | WorkItemStateWhereInput[]
    OR?: WorkItemStateWhereInput[]
    NOT?: WorkItemStateWhereInput | WorkItemStateWhereInput[]
    id?: StringFilter<"WorkItemState"> | string
    name?: StringFilter<"WorkItemState"> | string
    category?: EnumWorkItemStateCategoryFilter<"WorkItemState"> | $Enums.WorkItemStateCategory
    position?: IntFilter<"WorkItemState"> | number
    wipLimit?: IntNullableFilter<"WorkItemState"> | number | null
    color?: StringFilter<"WorkItemState"> | string
    icon?: StringNullableFilter<"WorkItemState"> | string | null
    isInitial?: BoolFilter<"WorkItemState"> | boolean
    isFinal?: BoolFilter<"WorkItemState"> | boolean
    createdAt?: DateTimeFilter<"WorkItemState"> | Date | string
    updatedAt?: DateTimeFilter<"WorkItemState"> | Date | string
    projectId?: StringFilter<"WorkItemState"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    workItems?: WorkItemListRelationFilter
  }

  export type WorkItemStateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    position?: SortOrder
    wipLimit?: SortOrderInput | SortOrder
    color?: SortOrder
    icon?: SortOrderInput | SortOrder
    isInitial?: SortOrder
    isFinal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    project?: ProjectOrderByWithRelationInput
    workItems?: WorkItemOrderByRelationAggregateInput
  }

  export type WorkItemStateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId_name?: WorkItemStateProjectIdNameCompoundUniqueInput
    AND?: WorkItemStateWhereInput | WorkItemStateWhereInput[]
    OR?: WorkItemStateWhereInput[]
    NOT?: WorkItemStateWhereInput | WorkItemStateWhereInput[]
    name?: StringFilter<"WorkItemState"> | string
    category?: EnumWorkItemStateCategoryFilter<"WorkItemState"> | $Enums.WorkItemStateCategory
    position?: IntFilter<"WorkItemState"> | number
    wipLimit?: IntNullableFilter<"WorkItemState"> | number | null
    color?: StringFilter<"WorkItemState"> | string
    icon?: StringNullableFilter<"WorkItemState"> | string | null
    isInitial?: BoolFilter<"WorkItemState"> | boolean
    isFinal?: BoolFilter<"WorkItemState"> | boolean
    createdAt?: DateTimeFilter<"WorkItemState"> | Date | string
    updatedAt?: DateTimeFilter<"WorkItemState"> | Date | string
    projectId?: StringFilter<"WorkItemState"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    workItems?: WorkItemListRelationFilter
  }, "id" | "projectId_name">

  export type WorkItemStateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    position?: SortOrder
    wipLimit?: SortOrderInput | SortOrder
    color?: SortOrder
    icon?: SortOrderInput | SortOrder
    isInitial?: SortOrder
    isFinal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    _count?: WorkItemStateCountOrderByAggregateInput
    _avg?: WorkItemStateAvgOrderByAggregateInput
    _max?: WorkItemStateMaxOrderByAggregateInput
    _min?: WorkItemStateMinOrderByAggregateInput
    _sum?: WorkItemStateSumOrderByAggregateInput
  }

  export type WorkItemStateScalarWhereWithAggregatesInput = {
    AND?: WorkItemStateScalarWhereWithAggregatesInput | WorkItemStateScalarWhereWithAggregatesInput[]
    OR?: WorkItemStateScalarWhereWithAggregatesInput[]
    NOT?: WorkItemStateScalarWhereWithAggregatesInput | WorkItemStateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkItemState"> | string
    name?: StringWithAggregatesFilter<"WorkItemState"> | string
    category?: EnumWorkItemStateCategoryWithAggregatesFilter<"WorkItemState"> | $Enums.WorkItemStateCategory
    position?: IntWithAggregatesFilter<"WorkItemState"> | number
    wipLimit?: IntNullableWithAggregatesFilter<"WorkItemState"> | number | null
    color?: StringWithAggregatesFilter<"WorkItemState"> | string
    icon?: StringNullableWithAggregatesFilter<"WorkItemState"> | string | null
    isInitial?: BoolWithAggregatesFilter<"WorkItemState"> | boolean
    isFinal?: BoolWithAggregatesFilter<"WorkItemState"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"WorkItemState"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WorkItemState"> | Date | string
    projectId?: StringWithAggregatesFilter<"WorkItemState"> | string
  }

  export type BoardWhereInput = {
    AND?: BoardWhereInput | BoardWhereInput[]
    OR?: BoardWhereInput[]
    NOT?: BoardWhereInput | BoardWhereInput[]
    id?: StringFilter<"Board"> | string
    name?: StringFilter<"Board"> | string
    boardType?: StringFilter<"Board"> | string
    filterQuery?: JsonFilter<"Board">
    settings?: JsonFilter<"Board">
    isDefault?: BoolFilter<"Board"> | boolean
    createdAt?: DateTimeFilter<"Board"> | Date | string
    updatedAt?: DateTimeFilter<"Board"> | Date | string
    projectId?: StringFilter<"Board"> | string
    sprintId?: StringNullableFilter<"Board"> | string | null
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    sprint?: XOR<SprintNullableScalarRelationFilter, SprintWhereInput> | null
    lanes?: BoardLaneListRelationFilter
  }

  export type BoardOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    boardType?: SortOrder
    filterQuery?: SortOrder
    settings?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    sprintId?: SortOrderInput | SortOrder
    project?: ProjectOrderByWithRelationInput
    sprint?: SprintOrderByWithRelationInput
    lanes?: BoardLaneOrderByRelationAggregateInput
  }

  export type BoardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BoardWhereInput | BoardWhereInput[]
    OR?: BoardWhereInput[]
    NOT?: BoardWhereInput | BoardWhereInput[]
    name?: StringFilter<"Board"> | string
    boardType?: StringFilter<"Board"> | string
    filterQuery?: JsonFilter<"Board">
    settings?: JsonFilter<"Board">
    isDefault?: BoolFilter<"Board"> | boolean
    createdAt?: DateTimeFilter<"Board"> | Date | string
    updatedAt?: DateTimeFilter<"Board"> | Date | string
    projectId?: StringFilter<"Board"> | string
    sprintId?: StringNullableFilter<"Board"> | string | null
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    sprint?: XOR<SprintNullableScalarRelationFilter, SprintWhereInput> | null
    lanes?: BoardLaneListRelationFilter
  }, "id">

  export type BoardOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    boardType?: SortOrder
    filterQuery?: SortOrder
    settings?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    sprintId?: SortOrderInput | SortOrder
    _count?: BoardCountOrderByAggregateInput
    _max?: BoardMaxOrderByAggregateInput
    _min?: BoardMinOrderByAggregateInput
  }

  export type BoardScalarWhereWithAggregatesInput = {
    AND?: BoardScalarWhereWithAggregatesInput | BoardScalarWhereWithAggregatesInput[]
    OR?: BoardScalarWhereWithAggregatesInput[]
    NOT?: BoardScalarWhereWithAggregatesInput | BoardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Board"> | string
    name?: StringWithAggregatesFilter<"Board"> | string
    boardType?: StringWithAggregatesFilter<"Board"> | string
    filterQuery?: JsonWithAggregatesFilter<"Board">
    settings?: JsonWithAggregatesFilter<"Board">
    isDefault?: BoolWithAggregatesFilter<"Board"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Board"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Board"> | Date | string
    projectId?: StringWithAggregatesFilter<"Board"> | string
    sprintId?: StringNullableWithAggregatesFilter<"Board"> | string | null
  }

  export type BoardLaneWhereInput = {
    AND?: BoardLaneWhereInput | BoardLaneWhereInput[]
    OR?: BoardLaneWhereInput[]
    NOT?: BoardLaneWhereInput | BoardLaneWhereInput[]
    id?: StringFilter<"BoardLane"> | string
    name?: StringFilter<"BoardLane"> | string
    position?: IntFilter<"BoardLane"> | number
    wipLimit?: IntNullableFilter<"BoardLane"> | number | null
    colorConfig?: JsonFilter<"BoardLane">
    mappedStates?: StringNullableListFilter<"BoardLane">
    isCollapsed?: BoolFilter<"BoardLane"> | boolean
    createdAt?: DateTimeFilter<"BoardLane"> | Date | string
    updatedAt?: DateTimeFilter<"BoardLane"> | Date | string
    boardId?: StringFilter<"BoardLane"> | string
    board?: XOR<BoardScalarRelationFilter, BoardWhereInput>
  }

  export type BoardLaneOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    position?: SortOrder
    wipLimit?: SortOrderInput | SortOrder
    colorConfig?: SortOrder
    mappedStates?: SortOrder
    isCollapsed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    boardId?: SortOrder
    board?: BoardOrderByWithRelationInput
  }

  export type BoardLaneWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BoardLaneWhereInput | BoardLaneWhereInput[]
    OR?: BoardLaneWhereInput[]
    NOT?: BoardLaneWhereInput | BoardLaneWhereInput[]
    name?: StringFilter<"BoardLane"> | string
    position?: IntFilter<"BoardLane"> | number
    wipLimit?: IntNullableFilter<"BoardLane"> | number | null
    colorConfig?: JsonFilter<"BoardLane">
    mappedStates?: StringNullableListFilter<"BoardLane">
    isCollapsed?: BoolFilter<"BoardLane"> | boolean
    createdAt?: DateTimeFilter<"BoardLane"> | Date | string
    updatedAt?: DateTimeFilter<"BoardLane"> | Date | string
    boardId?: StringFilter<"BoardLane"> | string
    board?: XOR<BoardScalarRelationFilter, BoardWhereInput>
  }, "id">

  export type BoardLaneOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    position?: SortOrder
    wipLimit?: SortOrderInput | SortOrder
    colorConfig?: SortOrder
    mappedStates?: SortOrder
    isCollapsed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    boardId?: SortOrder
    _count?: BoardLaneCountOrderByAggregateInput
    _avg?: BoardLaneAvgOrderByAggregateInput
    _max?: BoardLaneMaxOrderByAggregateInput
    _min?: BoardLaneMinOrderByAggregateInput
    _sum?: BoardLaneSumOrderByAggregateInput
  }

  export type BoardLaneScalarWhereWithAggregatesInput = {
    AND?: BoardLaneScalarWhereWithAggregatesInput | BoardLaneScalarWhereWithAggregatesInput[]
    OR?: BoardLaneScalarWhereWithAggregatesInput[]
    NOT?: BoardLaneScalarWhereWithAggregatesInput | BoardLaneScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BoardLane"> | string
    name?: StringWithAggregatesFilter<"BoardLane"> | string
    position?: IntWithAggregatesFilter<"BoardLane"> | number
    wipLimit?: IntNullableWithAggregatesFilter<"BoardLane"> | number | null
    colorConfig?: JsonWithAggregatesFilter<"BoardLane">
    mappedStates?: StringNullableListFilter<"BoardLane">
    isCollapsed?: BoolWithAggregatesFilter<"BoardLane"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"BoardLane"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BoardLane"> | Date | string
    boardId?: StringWithAggregatesFilter<"BoardLane"> | string
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    id?: StringFilter<"Tag"> | string
    name?: StringFilter<"Tag"> | string
    color?: StringFilter<"Tag"> | string
    description?: StringNullableFilter<"Tag"> | string | null
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    workItems?: TagOnWorkItemListRelationFilter
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    workItems?: TagOnWorkItemOrderByRelationAggregateInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    color?: StringFilter<"Tag"> | string
    description?: StringNullableFilter<"Tag"> | string | null
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    workItems?: TagOnWorkItemListRelationFilter
  }, "id" | "name">

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tag"> | string
    name?: StringWithAggregatesFilter<"Tag"> | string
    color?: StringWithAggregatesFilter<"Tag"> | string
    description?: StringNullableWithAggregatesFilter<"Tag"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
  }

  export type TagOnWorkItemWhereInput = {
    AND?: TagOnWorkItemWhereInput | TagOnWorkItemWhereInput[]
    OR?: TagOnWorkItemWhereInput[]
    NOT?: TagOnWorkItemWhereInput | TagOnWorkItemWhereInput[]
    workItemId?: StringFilter<"TagOnWorkItem"> | string
    tagId?: StringFilter<"TagOnWorkItem"> | string
    workItem?: XOR<WorkItemScalarRelationFilter, WorkItemWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }

  export type TagOnWorkItemOrderByWithRelationInput = {
    workItemId?: SortOrder
    tagId?: SortOrder
    workItem?: WorkItemOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type TagOnWorkItemWhereUniqueInput = Prisma.AtLeast<{
    workItemId_tagId?: TagOnWorkItemWorkItemIdTagIdCompoundUniqueInput
    AND?: TagOnWorkItemWhereInput | TagOnWorkItemWhereInput[]
    OR?: TagOnWorkItemWhereInput[]
    NOT?: TagOnWorkItemWhereInput | TagOnWorkItemWhereInput[]
    workItemId?: StringFilter<"TagOnWorkItem"> | string
    tagId?: StringFilter<"TagOnWorkItem"> | string
    workItem?: XOR<WorkItemScalarRelationFilter, WorkItemWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }, "workItemId_tagId">

  export type TagOnWorkItemOrderByWithAggregationInput = {
    workItemId?: SortOrder
    tagId?: SortOrder
    _count?: TagOnWorkItemCountOrderByAggregateInput
    _max?: TagOnWorkItemMaxOrderByAggregateInput
    _min?: TagOnWorkItemMinOrderByAggregateInput
  }

  export type TagOnWorkItemScalarWhereWithAggregatesInput = {
    AND?: TagOnWorkItemScalarWhereWithAggregatesInput | TagOnWorkItemScalarWhereWithAggregatesInput[]
    OR?: TagOnWorkItemScalarWhereWithAggregatesInput[]
    NOT?: TagOnWorkItemScalarWhereWithAggregatesInput | TagOnWorkItemScalarWhereWithAggregatesInput[]
    workItemId?: StringWithAggregatesFilter<"TagOnWorkItem"> | string
    tagId?: StringWithAggregatesFilter<"TagOnWorkItem"> | string
  }

  export type ComponentWhereInput = {
    AND?: ComponentWhereInput | ComponentWhereInput[]
    OR?: ComponentWhereInput[]
    NOT?: ComponentWhereInput | ComponentWhereInput[]
    id?: StringFilter<"Component"> | string
    name?: StringFilter<"Component"> | string
    description?: StringNullableFilter<"Component"> | string | null
    color?: StringFilter<"Component"> | string
    position?: IntFilter<"Component"> | number
    createdAt?: DateTimeFilter<"Component"> | Date | string
    updatedAt?: DateTimeFilter<"Component"> | Date | string
    projectId?: StringFilter<"Component"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    workItems?: ComponentOnWorkItemListRelationFilter
  }

  export type ComponentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    project?: ProjectOrderByWithRelationInput
    workItems?: ComponentOnWorkItemOrderByRelationAggregateInput
  }

  export type ComponentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId_name?: ComponentProjectIdNameCompoundUniqueInput
    AND?: ComponentWhereInput | ComponentWhereInput[]
    OR?: ComponentWhereInput[]
    NOT?: ComponentWhereInput | ComponentWhereInput[]
    name?: StringFilter<"Component"> | string
    description?: StringNullableFilter<"Component"> | string | null
    color?: StringFilter<"Component"> | string
    position?: IntFilter<"Component"> | number
    createdAt?: DateTimeFilter<"Component"> | Date | string
    updatedAt?: DateTimeFilter<"Component"> | Date | string
    projectId?: StringFilter<"Component"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    workItems?: ComponentOnWorkItemListRelationFilter
  }, "id" | "projectId_name">

  export type ComponentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    _count?: ComponentCountOrderByAggregateInput
    _avg?: ComponentAvgOrderByAggregateInput
    _max?: ComponentMaxOrderByAggregateInput
    _min?: ComponentMinOrderByAggregateInput
    _sum?: ComponentSumOrderByAggregateInput
  }

  export type ComponentScalarWhereWithAggregatesInput = {
    AND?: ComponentScalarWhereWithAggregatesInput | ComponentScalarWhereWithAggregatesInput[]
    OR?: ComponentScalarWhereWithAggregatesInput[]
    NOT?: ComponentScalarWhereWithAggregatesInput | ComponentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Component"> | string
    name?: StringWithAggregatesFilter<"Component"> | string
    description?: StringNullableWithAggregatesFilter<"Component"> | string | null
    color?: StringWithAggregatesFilter<"Component"> | string
    position?: IntWithAggregatesFilter<"Component"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Component"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Component"> | Date | string
    projectId?: StringWithAggregatesFilter<"Component"> | string
  }

  export type ComponentOnWorkItemWhereInput = {
    AND?: ComponentOnWorkItemWhereInput | ComponentOnWorkItemWhereInput[]
    OR?: ComponentOnWorkItemWhereInput[]
    NOT?: ComponentOnWorkItemWhereInput | ComponentOnWorkItemWhereInput[]
    workItemId?: StringFilter<"ComponentOnWorkItem"> | string
    componentId?: StringFilter<"ComponentOnWorkItem"> | string
    assignedAt?: DateTimeFilter<"ComponentOnWorkItem"> | Date | string
    workItem?: XOR<WorkItemScalarRelationFilter, WorkItemWhereInput>
    component?: XOR<ComponentScalarRelationFilter, ComponentWhereInput>
  }

  export type ComponentOnWorkItemOrderByWithRelationInput = {
    workItemId?: SortOrder
    componentId?: SortOrder
    assignedAt?: SortOrder
    workItem?: WorkItemOrderByWithRelationInput
    component?: ComponentOrderByWithRelationInput
  }

  export type ComponentOnWorkItemWhereUniqueInput = Prisma.AtLeast<{
    workItemId_componentId?: ComponentOnWorkItemWorkItemIdComponentIdCompoundUniqueInput
    AND?: ComponentOnWorkItemWhereInput | ComponentOnWorkItemWhereInput[]
    OR?: ComponentOnWorkItemWhereInput[]
    NOT?: ComponentOnWorkItemWhereInput | ComponentOnWorkItemWhereInput[]
    workItemId?: StringFilter<"ComponentOnWorkItem"> | string
    componentId?: StringFilter<"ComponentOnWorkItem"> | string
    assignedAt?: DateTimeFilter<"ComponentOnWorkItem"> | Date | string
    workItem?: XOR<WorkItemScalarRelationFilter, WorkItemWhereInput>
    component?: XOR<ComponentScalarRelationFilter, ComponentWhereInput>
  }, "workItemId_componentId">

  export type ComponentOnWorkItemOrderByWithAggregationInput = {
    workItemId?: SortOrder
    componentId?: SortOrder
    assignedAt?: SortOrder
    _count?: ComponentOnWorkItemCountOrderByAggregateInput
    _max?: ComponentOnWorkItemMaxOrderByAggregateInput
    _min?: ComponentOnWorkItemMinOrderByAggregateInput
  }

  export type ComponentOnWorkItemScalarWhereWithAggregatesInput = {
    AND?: ComponentOnWorkItemScalarWhereWithAggregatesInput | ComponentOnWorkItemScalarWhereWithAggregatesInput[]
    OR?: ComponentOnWorkItemScalarWhereWithAggregatesInput[]
    NOT?: ComponentOnWorkItemScalarWhereWithAggregatesInput | ComponentOnWorkItemScalarWhereWithAggregatesInput[]
    workItemId?: StringWithAggregatesFilter<"ComponentOnWorkItem"> | string
    componentId?: StringWithAggregatesFilter<"ComponentOnWorkItem"> | string
    assignedAt?: DateTimeWithAggregatesFilter<"ComponentOnWorkItem"> | Date | string
  }

  export type DependencyWhereInput = {
    AND?: DependencyWhereInput | DependencyWhereInput[]
    OR?: DependencyWhereInput[]
    NOT?: DependencyWhereInput | DependencyWhereInput[]
    id?: StringFilter<"Dependency"> | string
    dependencyType?: StringFilter<"Dependency"> | string
    description?: StringNullableFilter<"Dependency"> | string | null
    createdAt?: DateTimeFilter<"Dependency"> | Date | string
    sourceItemId?: StringFilter<"Dependency"> | string
    targetItemId?: StringFilter<"Dependency"> | string
    sourceItem?: XOR<WorkItemScalarRelationFilter, WorkItemWhereInput>
    targetItem?: XOR<WorkItemScalarRelationFilter, WorkItemWhereInput>
  }

  export type DependencyOrderByWithRelationInput = {
    id?: SortOrder
    dependencyType?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    sourceItemId?: SortOrder
    targetItemId?: SortOrder
    sourceItem?: WorkItemOrderByWithRelationInput
    targetItem?: WorkItemOrderByWithRelationInput
  }

  export type DependencyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sourceItemId_targetItemId?: DependencySourceItemIdTargetItemIdCompoundUniqueInput
    AND?: DependencyWhereInput | DependencyWhereInput[]
    OR?: DependencyWhereInput[]
    NOT?: DependencyWhereInput | DependencyWhereInput[]
    dependencyType?: StringFilter<"Dependency"> | string
    description?: StringNullableFilter<"Dependency"> | string | null
    createdAt?: DateTimeFilter<"Dependency"> | Date | string
    sourceItemId?: StringFilter<"Dependency"> | string
    targetItemId?: StringFilter<"Dependency"> | string
    sourceItem?: XOR<WorkItemScalarRelationFilter, WorkItemWhereInput>
    targetItem?: XOR<WorkItemScalarRelationFilter, WorkItemWhereInput>
  }, "id" | "sourceItemId_targetItemId">

  export type DependencyOrderByWithAggregationInput = {
    id?: SortOrder
    dependencyType?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    sourceItemId?: SortOrder
    targetItemId?: SortOrder
    _count?: DependencyCountOrderByAggregateInput
    _max?: DependencyMaxOrderByAggregateInput
    _min?: DependencyMinOrderByAggregateInput
  }

  export type DependencyScalarWhereWithAggregatesInput = {
    AND?: DependencyScalarWhereWithAggregatesInput | DependencyScalarWhereWithAggregatesInput[]
    OR?: DependencyScalarWhereWithAggregatesInput[]
    NOT?: DependencyScalarWhereWithAggregatesInput | DependencyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Dependency"> | string
    dependencyType?: StringWithAggregatesFilter<"Dependency"> | string
    description?: StringNullableWithAggregatesFilter<"Dependency"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Dependency"> | Date | string
    sourceItemId?: StringWithAggregatesFilter<"Dependency"> | string
    targetItemId?: StringWithAggregatesFilter<"Dependency"> | string
  }

  export type TimeLogWhereInput = {
    AND?: TimeLogWhereInput | TimeLogWhereInput[]
    OR?: TimeLogWhereInput[]
    NOT?: TimeLogWhereInput | TimeLogWhereInput[]
    id?: StringFilter<"TimeLog"> | string
    duration?: IntFilter<"TimeLog"> | number
    description?: StringNullableFilter<"TimeLog"> | string | null
    billable?: BoolFilter<"TimeLog"> | boolean
    logDate?: DateTimeFilter<"TimeLog"> | Date | string
    startedAt?: DateTimeNullableFilter<"TimeLog"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"TimeLog"> | Date | string | null
    createdAt?: DateTimeFilter<"TimeLog"> | Date | string
    updatedAt?: DateTimeFilter<"TimeLog"> | Date | string
    workItemId?: StringFilter<"TimeLog"> | string
    userId?: StringFilter<"TimeLog"> | string
    sprintId?: StringNullableFilter<"TimeLog"> | string | null
    workItem?: XOR<WorkItemScalarRelationFilter, WorkItemWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    sprint?: XOR<SprintNullableScalarRelationFilter, SprintWhereInput> | null
  }

  export type TimeLogOrderByWithRelationInput = {
    id?: SortOrder
    duration?: SortOrder
    description?: SortOrderInput | SortOrder
    billable?: SortOrder
    logDate?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workItemId?: SortOrder
    userId?: SortOrder
    sprintId?: SortOrderInput | SortOrder
    workItem?: WorkItemOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    sprint?: SprintOrderByWithRelationInput
  }

  export type TimeLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TimeLogWhereInput | TimeLogWhereInput[]
    OR?: TimeLogWhereInput[]
    NOT?: TimeLogWhereInput | TimeLogWhereInput[]
    duration?: IntFilter<"TimeLog"> | number
    description?: StringNullableFilter<"TimeLog"> | string | null
    billable?: BoolFilter<"TimeLog"> | boolean
    logDate?: DateTimeFilter<"TimeLog"> | Date | string
    startedAt?: DateTimeNullableFilter<"TimeLog"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"TimeLog"> | Date | string | null
    createdAt?: DateTimeFilter<"TimeLog"> | Date | string
    updatedAt?: DateTimeFilter<"TimeLog"> | Date | string
    workItemId?: StringFilter<"TimeLog"> | string
    userId?: StringFilter<"TimeLog"> | string
    sprintId?: StringNullableFilter<"TimeLog"> | string | null
    workItem?: XOR<WorkItemScalarRelationFilter, WorkItemWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    sprint?: XOR<SprintNullableScalarRelationFilter, SprintWhereInput> | null
  }, "id">

  export type TimeLogOrderByWithAggregationInput = {
    id?: SortOrder
    duration?: SortOrder
    description?: SortOrderInput | SortOrder
    billable?: SortOrder
    logDate?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workItemId?: SortOrder
    userId?: SortOrder
    sprintId?: SortOrderInput | SortOrder
    _count?: TimeLogCountOrderByAggregateInput
    _avg?: TimeLogAvgOrderByAggregateInput
    _max?: TimeLogMaxOrderByAggregateInput
    _min?: TimeLogMinOrderByAggregateInput
    _sum?: TimeLogSumOrderByAggregateInput
  }

  export type TimeLogScalarWhereWithAggregatesInput = {
    AND?: TimeLogScalarWhereWithAggregatesInput | TimeLogScalarWhereWithAggregatesInput[]
    OR?: TimeLogScalarWhereWithAggregatesInput[]
    NOT?: TimeLogScalarWhereWithAggregatesInput | TimeLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TimeLog"> | string
    duration?: IntWithAggregatesFilter<"TimeLog"> | number
    description?: StringNullableWithAggregatesFilter<"TimeLog"> | string | null
    billable?: BoolWithAggregatesFilter<"TimeLog"> | boolean
    logDate?: DateTimeWithAggregatesFilter<"TimeLog"> | Date | string
    startedAt?: DateTimeNullableWithAggregatesFilter<"TimeLog"> | Date | string | null
    endedAt?: DateTimeNullableWithAggregatesFilter<"TimeLog"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TimeLog"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TimeLog"> | Date | string
    workItemId?: StringWithAggregatesFilter<"TimeLog"> | string
    userId?: StringWithAggregatesFilter<"TimeLog"> | string
    sprintId?: StringNullableWithAggregatesFilter<"TimeLog"> | string | null
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: StringFilter<"Comment"> | string
    body?: StringFilter<"Comment"> | string
    sentimentScore?: FloatNullableFilter<"Comment"> | number | null
    sentimentLabel?: StringNullableFilter<"Comment"> | string | null
    isInternal?: BoolFilter<"Comment"> | boolean
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    workItemId?: StringFilter<"Comment"> | string
    userId?: StringFilter<"Comment"> | string
    workItem?: XOR<WorkItemScalarRelationFilter, WorkItemWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    body?: SortOrder
    sentimentScore?: SortOrderInput | SortOrder
    sentimentLabel?: SortOrderInput | SortOrder
    isInternal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workItemId?: SortOrder
    userId?: SortOrder
    workItem?: WorkItemOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    body?: StringFilter<"Comment"> | string
    sentimentScore?: FloatNullableFilter<"Comment"> | number | null
    sentimentLabel?: StringNullableFilter<"Comment"> | string | null
    isInternal?: BoolFilter<"Comment"> | boolean
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    workItemId?: StringFilter<"Comment"> | string
    userId?: StringFilter<"Comment"> | string
    workItem?: XOR<WorkItemScalarRelationFilter, WorkItemWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    body?: SortOrder
    sentimentScore?: SortOrderInput | SortOrder
    sentimentLabel?: SortOrderInput | SortOrder
    isInternal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workItemId?: SortOrder
    userId?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _avg?: CommentAvgOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
    _sum?: CommentSumOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Comment"> | string
    body?: StringWithAggregatesFilter<"Comment"> | string
    sentimentScore?: FloatNullableWithAggregatesFilter<"Comment"> | number | null
    sentimentLabel?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    isInternal?: BoolWithAggregatesFilter<"Comment"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    workItemId?: StringWithAggregatesFilter<"Comment"> | string
    userId?: StringWithAggregatesFilter<"Comment"> | string
  }

  export type AttachmentWhereInput = {
    AND?: AttachmentWhereInput | AttachmentWhereInput[]
    OR?: AttachmentWhereInput[]
    NOT?: AttachmentWhereInput | AttachmentWhereInput[]
    id?: StringFilter<"Attachment"> | string
    fileName?: StringFilter<"Attachment"> | string
    fileType?: StringFilter<"Attachment"> | string
    fileSize?: IntFilter<"Attachment"> | number
    storagePath?: StringFilter<"Attachment"> | string
    fileUrl?: StringFilter<"Attachment"> | string
    ocrContent?: StringNullableFilter<"Attachment"> | string | null
    metadata?: JsonFilter<"Attachment">
    createdAt?: DateTimeFilter<"Attachment"> | Date | string
    workItemId?: StringFilter<"Attachment"> | string
    uploadedBy?: StringFilter<"Attachment"> | string
    workItem?: XOR<WorkItemScalarRelationFilter, WorkItemWhereInput>
  }

  export type AttachmentOrderByWithRelationInput = {
    id?: SortOrder
    fileName?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    storagePath?: SortOrder
    fileUrl?: SortOrder
    ocrContent?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    workItemId?: SortOrder
    uploadedBy?: SortOrder
    workItem?: WorkItemOrderByWithRelationInput
  }

  export type AttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AttachmentWhereInput | AttachmentWhereInput[]
    OR?: AttachmentWhereInput[]
    NOT?: AttachmentWhereInput | AttachmentWhereInput[]
    fileName?: StringFilter<"Attachment"> | string
    fileType?: StringFilter<"Attachment"> | string
    fileSize?: IntFilter<"Attachment"> | number
    storagePath?: StringFilter<"Attachment"> | string
    fileUrl?: StringFilter<"Attachment"> | string
    ocrContent?: StringNullableFilter<"Attachment"> | string | null
    metadata?: JsonFilter<"Attachment">
    createdAt?: DateTimeFilter<"Attachment"> | Date | string
    workItemId?: StringFilter<"Attachment"> | string
    uploadedBy?: StringFilter<"Attachment"> | string
    workItem?: XOR<WorkItemScalarRelationFilter, WorkItemWhereInput>
  }, "id">

  export type AttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    fileName?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    storagePath?: SortOrder
    fileUrl?: SortOrder
    ocrContent?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    workItemId?: SortOrder
    uploadedBy?: SortOrder
    _count?: AttachmentCountOrderByAggregateInput
    _avg?: AttachmentAvgOrderByAggregateInput
    _max?: AttachmentMaxOrderByAggregateInput
    _min?: AttachmentMinOrderByAggregateInput
    _sum?: AttachmentSumOrderByAggregateInput
  }

  export type AttachmentScalarWhereWithAggregatesInput = {
    AND?: AttachmentScalarWhereWithAggregatesInput | AttachmentScalarWhereWithAggregatesInput[]
    OR?: AttachmentScalarWhereWithAggregatesInput[]
    NOT?: AttachmentScalarWhereWithAggregatesInput | AttachmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Attachment"> | string
    fileName?: StringWithAggregatesFilter<"Attachment"> | string
    fileType?: StringWithAggregatesFilter<"Attachment"> | string
    fileSize?: IntWithAggregatesFilter<"Attachment"> | number
    storagePath?: StringWithAggregatesFilter<"Attachment"> | string
    fileUrl?: StringWithAggregatesFilter<"Attachment"> | string
    ocrContent?: StringNullableWithAggregatesFilter<"Attachment"> | string | null
    metadata?: JsonWithAggregatesFilter<"Attachment">
    createdAt?: DateTimeWithAggregatesFilter<"Attachment"> | Date | string
    workItemId?: StringWithAggregatesFilter<"Attachment"> | string
    uploadedBy?: StringWithAggregatesFilter<"Attachment"> | string
  }

  export type WorkItemEmbeddingWhereInput = {
    AND?: WorkItemEmbeddingWhereInput | WorkItemEmbeddingWhereInput[]
    OR?: WorkItemEmbeddingWhereInput[]
    NOT?: WorkItemEmbeddingWhereInput | WorkItemEmbeddingWhereInput[]
    workItemId?: StringFilter<"WorkItemEmbedding"> | string
    version?: IntFilter<"WorkItemEmbedding"> | number
    createdAt?: DateTimeFilter<"WorkItemEmbedding"> | Date | string
    updatedAt?: DateTimeFilter<"WorkItemEmbedding"> | Date | string
    workItem?: XOR<WorkItemScalarRelationFilter, WorkItemWhereInput>
  }

  export type WorkItemEmbeddingOrderByWithRelationInput = {
    workItemId?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workItem?: WorkItemOrderByWithRelationInput
  }

  export type WorkItemEmbeddingWhereUniqueInput = Prisma.AtLeast<{
    workItemId?: string
    AND?: WorkItemEmbeddingWhereInput | WorkItemEmbeddingWhereInput[]
    OR?: WorkItemEmbeddingWhereInput[]
    NOT?: WorkItemEmbeddingWhereInput | WorkItemEmbeddingWhereInput[]
    version?: IntFilter<"WorkItemEmbedding"> | number
    createdAt?: DateTimeFilter<"WorkItemEmbedding"> | Date | string
    updatedAt?: DateTimeFilter<"WorkItemEmbedding"> | Date | string
    workItem?: XOR<WorkItemScalarRelationFilter, WorkItemWhereInput>
  }, "workItemId">

  export type WorkItemEmbeddingOrderByWithAggregationInput = {
    workItemId?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WorkItemEmbeddingCountOrderByAggregateInput
    _avg?: WorkItemEmbeddingAvgOrderByAggregateInput
    _max?: WorkItemEmbeddingMaxOrderByAggregateInput
    _min?: WorkItemEmbeddingMinOrderByAggregateInput
    _sum?: WorkItemEmbeddingSumOrderByAggregateInput
  }

  export type WorkItemEmbeddingScalarWhereWithAggregatesInput = {
    AND?: WorkItemEmbeddingScalarWhereWithAggregatesInput | WorkItemEmbeddingScalarWhereWithAggregatesInput[]
    OR?: WorkItemEmbeddingScalarWhereWithAggregatesInput[]
    NOT?: WorkItemEmbeddingScalarWhereWithAggregatesInput | WorkItemEmbeddingScalarWhereWithAggregatesInput[]
    workItemId?: StringWithAggregatesFilter<"WorkItemEmbedding"> | string
    version?: IntWithAggregatesFilter<"WorkItemEmbedding"> | number
    createdAt?: DateTimeWithAggregatesFilter<"WorkItemEmbedding"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WorkItemEmbedding"> | Date | string
  }

  export type WorkItemSnapshotWhereInput = {
    AND?: WorkItemSnapshotWhereInput | WorkItemSnapshotWhereInput[]
    OR?: WorkItemSnapshotWhereInput[]
    NOT?: WorkItemSnapshotWhereInput | WorkItemSnapshotWhereInput[]
    id?: StringFilter<"WorkItemSnapshot"> | string
    stateId?: StringNullableFilter<"WorkItemSnapshot"> | string | null
    pointsRemaining?: FloatNullableFilter<"WorkItemSnapshot"> | number | null
    hoursRemaining?: FloatNullableFilter<"WorkItemSnapshot"> | number | null
    hoursSpent?: FloatNullableFilter<"WorkItemSnapshot"> | number | null
    daysInCurrentState?: IntFilter<"WorkItemSnapshot"> | number
    blockerIds?: StringNullableListFilter<"WorkItemSnapshot">
    snapshotDate?: DateTimeFilter<"WorkItemSnapshot"> | Date | string
    workItemId?: StringFilter<"WorkItemSnapshot"> | string
    sprintId?: StringNullableFilter<"WorkItemSnapshot"> | string | null
    workItem?: XOR<WorkItemScalarRelationFilter, WorkItemWhereInput>
    sprint?: XOR<SprintNullableScalarRelationFilter, SprintWhereInput> | null
  }

  export type WorkItemSnapshotOrderByWithRelationInput = {
    id?: SortOrder
    stateId?: SortOrderInput | SortOrder
    pointsRemaining?: SortOrderInput | SortOrder
    hoursRemaining?: SortOrderInput | SortOrder
    hoursSpent?: SortOrderInput | SortOrder
    daysInCurrentState?: SortOrder
    blockerIds?: SortOrder
    snapshotDate?: SortOrder
    workItemId?: SortOrder
    sprintId?: SortOrderInput | SortOrder
    workItem?: WorkItemOrderByWithRelationInput
    sprint?: SprintOrderByWithRelationInput
  }

  export type WorkItemSnapshotWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkItemSnapshotWhereInput | WorkItemSnapshotWhereInput[]
    OR?: WorkItemSnapshotWhereInput[]
    NOT?: WorkItemSnapshotWhereInput | WorkItemSnapshotWhereInput[]
    stateId?: StringNullableFilter<"WorkItemSnapshot"> | string | null
    pointsRemaining?: FloatNullableFilter<"WorkItemSnapshot"> | number | null
    hoursRemaining?: FloatNullableFilter<"WorkItemSnapshot"> | number | null
    hoursSpent?: FloatNullableFilter<"WorkItemSnapshot"> | number | null
    daysInCurrentState?: IntFilter<"WorkItemSnapshot"> | number
    blockerIds?: StringNullableListFilter<"WorkItemSnapshot">
    snapshotDate?: DateTimeFilter<"WorkItemSnapshot"> | Date | string
    workItemId?: StringFilter<"WorkItemSnapshot"> | string
    sprintId?: StringNullableFilter<"WorkItemSnapshot"> | string | null
    workItem?: XOR<WorkItemScalarRelationFilter, WorkItemWhereInput>
    sprint?: XOR<SprintNullableScalarRelationFilter, SprintWhereInput> | null
  }, "id">

  export type WorkItemSnapshotOrderByWithAggregationInput = {
    id?: SortOrder
    stateId?: SortOrderInput | SortOrder
    pointsRemaining?: SortOrderInput | SortOrder
    hoursRemaining?: SortOrderInput | SortOrder
    hoursSpent?: SortOrderInput | SortOrder
    daysInCurrentState?: SortOrder
    blockerIds?: SortOrder
    snapshotDate?: SortOrder
    workItemId?: SortOrder
    sprintId?: SortOrderInput | SortOrder
    _count?: WorkItemSnapshotCountOrderByAggregateInput
    _avg?: WorkItemSnapshotAvgOrderByAggregateInput
    _max?: WorkItemSnapshotMaxOrderByAggregateInput
    _min?: WorkItemSnapshotMinOrderByAggregateInput
    _sum?: WorkItemSnapshotSumOrderByAggregateInput
  }

  export type WorkItemSnapshotScalarWhereWithAggregatesInput = {
    AND?: WorkItemSnapshotScalarWhereWithAggregatesInput | WorkItemSnapshotScalarWhereWithAggregatesInput[]
    OR?: WorkItemSnapshotScalarWhereWithAggregatesInput[]
    NOT?: WorkItemSnapshotScalarWhereWithAggregatesInput | WorkItemSnapshotScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkItemSnapshot"> | string
    stateId?: StringNullableWithAggregatesFilter<"WorkItemSnapshot"> | string | null
    pointsRemaining?: FloatNullableWithAggregatesFilter<"WorkItemSnapshot"> | number | null
    hoursRemaining?: FloatNullableWithAggregatesFilter<"WorkItemSnapshot"> | number | null
    hoursSpent?: FloatNullableWithAggregatesFilter<"WorkItemSnapshot"> | number | null
    daysInCurrentState?: IntWithAggregatesFilter<"WorkItemSnapshot"> | number
    blockerIds?: StringNullableListFilter<"WorkItemSnapshot">
    snapshotDate?: DateTimeWithAggregatesFilter<"WorkItemSnapshot"> | Date | string
    workItemId?: StringWithAggregatesFilter<"WorkItemSnapshot"> | string
    sprintId?: StringNullableWithAggregatesFilter<"WorkItemSnapshot"> | string | null
  }

  export type UserSkillProfileWhereInput = {
    AND?: UserSkillProfileWhereInput | UserSkillProfileWhereInput[]
    OR?: UserSkillProfileWhereInput[]
    NOT?: UserSkillProfileWhereInput | UserSkillProfileWhereInput[]
    id?: StringFilter<"UserSkillProfile"> | string
    skills?: StringNullableListFilter<"UserSkillProfile">
    proficiencyScores?: JsonFilter<"UserSkillProfile">
    certifiedSkills?: StringNullableListFilter<"UserSkillProfile">
    overallProficiency?: FloatFilter<"UserSkillProfile"> | number
    lastUpdated?: DateTimeFilter<"UserSkillProfile"> | Date | string
    userId?: StringFilter<"UserSkillProfile"> | string
    teamId?: StringNullableFilter<"UserSkillProfile"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    team?: XOR<TeamNullableScalarRelationFilter, TeamWhereInput> | null
  }

  export type UserSkillProfileOrderByWithRelationInput = {
    id?: SortOrder
    skills?: SortOrder
    proficiencyScores?: SortOrder
    certifiedSkills?: SortOrder
    overallProficiency?: SortOrder
    lastUpdated?: SortOrder
    userId?: SortOrder
    teamId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    team?: TeamOrderByWithRelationInput
  }

  export type UserSkillProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserSkillProfileWhereInput | UserSkillProfileWhereInput[]
    OR?: UserSkillProfileWhereInput[]
    NOT?: UserSkillProfileWhereInput | UserSkillProfileWhereInput[]
    skills?: StringNullableListFilter<"UserSkillProfile">
    proficiencyScores?: JsonFilter<"UserSkillProfile">
    certifiedSkills?: StringNullableListFilter<"UserSkillProfile">
    overallProficiency?: FloatFilter<"UserSkillProfile"> | number
    lastUpdated?: DateTimeFilter<"UserSkillProfile"> | Date | string
    teamId?: StringNullableFilter<"UserSkillProfile"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    team?: XOR<TeamNullableScalarRelationFilter, TeamWhereInput> | null
  }, "id" | "userId">

  export type UserSkillProfileOrderByWithAggregationInput = {
    id?: SortOrder
    skills?: SortOrder
    proficiencyScores?: SortOrder
    certifiedSkills?: SortOrder
    overallProficiency?: SortOrder
    lastUpdated?: SortOrder
    userId?: SortOrder
    teamId?: SortOrderInput | SortOrder
    _count?: UserSkillProfileCountOrderByAggregateInput
    _avg?: UserSkillProfileAvgOrderByAggregateInput
    _max?: UserSkillProfileMaxOrderByAggregateInput
    _min?: UserSkillProfileMinOrderByAggregateInput
    _sum?: UserSkillProfileSumOrderByAggregateInput
  }

  export type UserSkillProfileScalarWhereWithAggregatesInput = {
    AND?: UserSkillProfileScalarWhereWithAggregatesInput | UserSkillProfileScalarWhereWithAggregatesInput[]
    OR?: UserSkillProfileScalarWhereWithAggregatesInput[]
    NOT?: UserSkillProfileScalarWhereWithAggregatesInput | UserSkillProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserSkillProfile"> | string
    skills?: StringNullableListFilter<"UserSkillProfile">
    proficiencyScores?: JsonWithAggregatesFilter<"UserSkillProfile">
    certifiedSkills?: StringNullableListFilter<"UserSkillProfile">
    overallProficiency?: FloatWithAggregatesFilter<"UserSkillProfile"> | number
    lastUpdated?: DateTimeWithAggregatesFilter<"UserSkillProfile"> | Date | string
    userId?: StringWithAggregatesFilter<"UserSkillProfile"> | string
    teamId?: StringNullableWithAggregatesFilter<"UserSkillProfile"> | string | null
  }

  export type WorkflowRuleWhereInput = {
    AND?: WorkflowRuleWhereInput | WorkflowRuleWhereInput[]
    OR?: WorkflowRuleWhereInput[]
    NOT?: WorkflowRuleWhereInput | WorkflowRuleWhereInput[]
    id?: StringFilter<"WorkflowRule"> | string
    name?: StringFilter<"WorkflowRule"> | string
    description?: StringNullableFilter<"WorkflowRule"> | string | null
    trigger?: StringFilter<"WorkflowRule"> | string
    action?: JsonFilter<"WorkflowRule">
    conditions?: JsonFilter<"WorkflowRule">
    isActive?: BoolFilter<"WorkflowRule"> | boolean
    priority?: IntFilter<"WorkflowRule"> | number
    createdAt?: DateTimeFilter<"WorkflowRule"> | Date | string
    updatedAt?: DateTimeFilter<"WorkflowRule"> | Date | string
    projectId?: StringFilter<"WorkflowRule"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type WorkflowRuleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    trigger?: SortOrder
    action?: SortOrder
    conditions?: SortOrder
    isActive?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type WorkflowRuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkflowRuleWhereInput | WorkflowRuleWhereInput[]
    OR?: WorkflowRuleWhereInput[]
    NOT?: WorkflowRuleWhereInput | WorkflowRuleWhereInput[]
    name?: StringFilter<"WorkflowRule"> | string
    description?: StringNullableFilter<"WorkflowRule"> | string | null
    trigger?: StringFilter<"WorkflowRule"> | string
    action?: JsonFilter<"WorkflowRule">
    conditions?: JsonFilter<"WorkflowRule">
    isActive?: BoolFilter<"WorkflowRule"> | boolean
    priority?: IntFilter<"WorkflowRule"> | number
    createdAt?: DateTimeFilter<"WorkflowRule"> | Date | string
    updatedAt?: DateTimeFilter<"WorkflowRule"> | Date | string
    projectId?: StringFilter<"WorkflowRule"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id">

  export type WorkflowRuleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    trigger?: SortOrder
    action?: SortOrder
    conditions?: SortOrder
    isActive?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    _count?: WorkflowRuleCountOrderByAggregateInput
    _avg?: WorkflowRuleAvgOrderByAggregateInput
    _max?: WorkflowRuleMaxOrderByAggregateInput
    _min?: WorkflowRuleMinOrderByAggregateInput
    _sum?: WorkflowRuleSumOrderByAggregateInput
  }

  export type WorkflowRuleScalarWhereWithAggregatesInput = {
    AND?: WorkflowRuleScalarWhereWithAggregatesInput | WorkflowRuleScalarWhereWithAggregatesInput[]
    OR?: WorkflowRuleScalarWhereWithAggregatesInput[]
    NOT?: WorkflowRuleScalarWhereWithAggregatesInput | WorkflowRuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkflowRule"> | string
    name?: StringWithAggregatesFilter<"WorkflowRule"> | string
    description?: StringNullableWithAggregatesFilter<"WorkflowRule"> | string | null
    trigger?: StringWithAggregatesFilter<"WorkflowRule"> | string
    action?: JsonWithAggregatesFilter<"WorkflowRule">
    conditions?: JsonWithAggregatesFilter<"WorkflowRule">
    isActive?: BoolWithAggregatesFilter<"WorkflowRule"> | boolean
    priority?: IntWithAggregatesFilter<"WorkflowRule"> | number
    createdAt?: DateTimeWithAggregatesFilter<"WorkflowRule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WorkflowRule"> | Date | string
    projectId?: StringWithAggregatesFilter<"WorkflowRule"> | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    body?: StringNullableFilter<"Notification"> | string | null
    targetUrl?: StringNullableFilter<"Notification"> | string | null
    priorityScore?: FloatFilter<"Notification"> | number
    isRead?: BoolFilter<"Notification"> | boolean
    metadata?: JsonFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    userId?: StringFilter<"Notification"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrderInput | SortOrder
    targetUrl?: SortOrderInput | SortOrder
    priorityScore?: SortOrder
    isRead?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrderInput | SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    body?: StringNullableFilter<"Notification"> | string | null
    targetUrl?: StringNullableFilter<"Notification"> | string | null
    priorityScore?: FloatFilter<"Notification"> | number
    isRead?: BoolFilter<"Notification"> | boolean
    metadata?: JsonFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    userId?: StringFilter<"Notification"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrderInput | SortOrder
    targetUrl?: SortOrderInput | SortOrder
    priorityScore?: SortOrder
    isRead?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrderInput | SortOrder
    userId?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _avg?: NotificationAvgOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
    _sum?: NotificationSumOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    body?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    targetUrl?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    priorityScore?: FloatWithAggregatesFilter<"Notification"> | number
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    metadata?: JsonWithAggregatesFilter<"Notification">
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    userId?: StringWithAggregatesFilter<"Notification"> | string
  }

  export type ActivityLogWhereInput = {
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    id?: StringFilter<"ActivityLog"> | string
    entityType?: StringFilter<"ActivityLog"> | string
    entityId?: StringFilter<"ActivityLog"> | string
    action?: StringFilter<"ActivityLog"> | string
    actorId?: StringNullableFilter<"ActivityLog"> | string | null
    changeDiff?: JsonFilter<"ActivityLog">
    context?: JsonFilter<"ActivityLog">
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
  }

  export type ActivityLogOrderByWithRelationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    actorId?: SortOrderInput | SortOrder
    changeDiff?: SortOrder
    context?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    entityType?: StringFilter<"ActivityLog"> | string
    entityId?: StringFilter<"ActivityLog"> | string
    action?: StringFilter<"ActivityLog"> | string
    actorId?: StringNullableFilter<"ActivityLog"> | string | null
    changeDiff?: JsonFilter<"ActivityLog">
    context?: JsonFilter<"ActivityLog">
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
  }, "id">

  export type ActivityLogOrderByWithAggregationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    actorId?: SortOrderInput | SortOrder
    changeDiff?: SortOrder
    context?: SortOrder
    createdAt?: SortOrder
    _count?: ActivityLogCountOrderByAggregateInput
    _max?: ActivityLogMaxOrderByAggregateInput
    _min?: ActivityLogMinOrderByAggregateInput
  }

  export type ActivityLogScalarWhereWithAggregatesInput = {
    AND?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    OR?: ActivityLogScalarWhereWithAggregatesInput[]
    NOT?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ActivityLog"> | string
    entityType?: StringWithAggregatesFilter<"ActivityLog"> | string
    entityId?: StringWithAggregatesFilter<"ActivityLog"> | string
    action?: StringWithAggregatesFilter<"ActivityLog"> | string
    actorId?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    changeDiff?: JsonWithAggregatesFilter<"ActivityLog">
    context?: JsonWithAggregatesFilter<"ActivityLog">
    createdAt?: DateTimeWithAggregatesFilter<"ActivityLog"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    passwordHash?: string | null
    firstName: string
    lastName: string
    avatarUrl?: string | null
    timezone?: string
    availabilityHours?: number
    isActive?: boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    organizationMemberships?: OrganizationMembershipCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMembershipCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectCreateNestedManyWithoutLeadUserInput
    assignedWorkItems?: WorkItemCreateNestedManyWithoutAssigneeInput
    createdWorkItems?: WorkItemCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    timeLogs?: TimeLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    skillProfile?: UserSkillProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    passwordHash?: string | null
    firstName: string
    lastName: string
    avatarUrl?: string | null
    timezone?: string
    availabilityHours?: number
    isActive?: boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    organizationMemberships?: OrganizationMembershipUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMembershipUncheckedCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutLeadUserInput
    assignedWorkItems?: WorkItemUncheckedCreateNestedManyWithoutAssigneeInput
    createdWorkItems?: WorkItemUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    skillProfile?: UserSkillProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    availabilityHours?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    organizationMemberships?: OrganizationMembershipUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMembershipUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUpdateManyWithoutLeadUserNestedInput
    assignedWorkItems?: WorkItemUpdateManyWithoutAssigneeNestedInput
    createdWorkItems?: WorkItemUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    timeLogs?: TimeLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    skillProfile?: UserSkillProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    availabilityHours?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    organizationMemberships?: OrganizationMembershipUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMembershipUncheckedUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutLeadUserNestedInput
    assignedWorkItems?: WorkItemUncheckedUpdateManyWithoutAssigneeNestedInput
    createdWorkItems?: WorkItemUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    skillProfile?: UserSkillProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    passwordHash?: string | null
    firstName: string
    lastName: string
    avatarUrl?: string | null
    timezone?: string
    availabilityHours?: number
    isActive?: boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    availabilityHours?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    availabilityHours?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    userId: string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type SessionCreateManyInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    userId: string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type AccountCreateInput = {
    id: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id: string
    accountId: string
    providerId: string
    userId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyInput = {
    id: string
    accountId: string
    providerId: string
    userId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateInput = {
    id: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUncheckedCreateInput = {
    id: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateManyInput = {
    id: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    planTier?: string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: OrganizationMembershipCreateNestedManyWithoutOrganizationInput
    portfolios?: PortfolioCreateNestedManyWithoutOrganizationInput
    teams?: TeamCreateNestedManyWithoutOrganizationInput
    projects?: ProjectCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    planTier?: string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: OrganizationMembershipUncheckedCreateNestedManyWithoutOrganizationInput
    portfolios?: PortfolioUncheckedCreateNestedManyWithoutOrganizationInput
    teams?: TeamUncheckedCreateNestedManyWithoutOrganizationInput
    projects?: ProjectUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    planTier?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: OrganizationMembershipUpdateManyWithoutOrganizationNestedInput
    portfolios?: PortfolioUpdateManyWithoutOrganizationNestedInput
    teams?: TeamUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    planTier?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: OrganizationMembershipUncheckedUpdateManyWithoutOrganizationNestedInput
    portfolios?: PortfolioUncheckedUpdateManyWithoutOrganizationNestedInput
    teams?: TeamUncheckedUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    planTier?: string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    planTier?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    planTier?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamCreateInput = {
    id?: string
    name: string
    description?: string | null
    velocityHistory?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutTeamsInput
    members?: TeamMembershipCreateNestedManyWithoutTeamInput
    projects?: ProjectCreateNestedManyWithoutTeamsInput
    skillProfiles?: UserSkillProfileCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    velocityHistory?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    organizationId: string
    members?: TeamMembershipUncheckedCreateNestedManyWithoutTeamInput
    projects?: ProjectUncheckedCreateNestedManyWithoutTeamsInput
    skillProfiles?: UserSkillProfileUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    velocityHistory?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutTeamsNestedInput
    members?: TeamMembershipUpdateManyWithoutTeamNestedInput
    projects?: ProjectUpdateManyWithoutTeamsNestedInput
    skillProfiles?: UserSkillProfileUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    velocityHistory?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: StringFieldUpdateOperationsInput | string
    members?: TeamMembershipUncheckedUpdateManyWithoutTeamNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutTeamsNestedInput
    skillProfiles?: UserSkillProfileUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    velocityHistory?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    organizationId: string
  }

  export type TeamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    velocityHistory?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    velocityHistory?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: StringFieldUpdateOperationsInput | string
  }

  export type RoleCreateInput = {
    id?: string
    name: string
    description?: string | null
    permissions: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    teamMemberships?: TeamMembershipCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    permissions: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    teamMemberships?: TeamMembershipUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamMemberships?: TeamMembershipUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamMemberships?: TeamMembershipUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    permissions: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type RoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationMembershipCreateInput = {
    id?: string
    role?: string
    joinedAt?: Date | string
    user: UserCreateNestedOneWithoutOrganizationMembershipsInput
    organization: OrganizationCreateNestedOneWithoutUsersInput
  }

  export type OrganizationMembershipUncheckedCreateInput = {
    id?: string
    userId: string
    organizationId: string
    role?: string
    joinedAt?: Date | string
  }

  export type OrganizationMembershipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrganizationMembershipsNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutUsersNestedInput
  }

  export type OrganizationMembershipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationMembershipCreateManyInput = {
    id?: string
    userId: string
    organizationId: string
    role?: string
    joinedAt?: Date | string
  }

  export type OrganizationMembershipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationMembershipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMembershipCreateInput = {
    id?: string
    joinedAt?: Date | string
    leftAt?: Date | string | null
    user: UserCreateNestedOneWithoutTeamMembershipsInput
    team: TeamCreateNestedOneWithoutMembersInput
    role?: RoleCreateNestedOneWithoutTeamMembershipsInput
  }

  export type TeamMembershipUncheckedCreateInput = {
    id?: string
    userId: string
    teamId: string
    roleId?: string | null
    joinedAt?: Date | string
    leftAt?: Date | string | null
  }

  export type TeamMembershipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutTeamMembershipsNestedInput
    team?: TeamUpdateOneRequiredWithoutMembersNestedInput
    role?: RoleUpdateOneWithoutTeamMembershipsNestedInput
  }

  export type TeamMembershipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TeamMembershipCreateManyInput = {
    id?: string
    userId: string
    teamId: string
    roleId?: string | null
    joinedAt?: Date | string
    leftAt?: Date | string | null
  }

  export type TeamMembershipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TeamMembershipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PortfolioCreateInput = {
    id?: string
    name: string
    description?: string | null
    strategicGoal?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutPortfoliosInput
    projects?: ProjectCreateNestedManyWithoutPortfolioInput
  }

  export type PortfolioUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    strategicGoal?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organizationId: string
    projects?: ProjectUncheckedCreateNestedManyWithoutPortfolioInput
  }

  export type PortfolioUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    strategicGoal?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutPortfoliosNestedInput
    projects?: ProjectUpdateManyWithoutPortfolioNestedInput
  }

  export type PortfolioUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    strategicGoal?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: StringFieldUpdateOperationsInput | string
    projects?: ProjectUncheckedUpdateManyWithoutPortfolioNestedInput
  }

  export type PortfolioCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    strategicGoal?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organizationId: string
  }

  export type PortfolioUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    strategicGoal?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    strategicGoal?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectCreateInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    projectType?: string
    riskScore?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    portfolio?: PortfolioCreateNestedOneWithoutProjectsInput
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    leadUser?: UserCreateNestedOneWithoutOwnedProjectsInput
    workItems?: WorkItemCreateNestedManyWithoutProjectInput
    sprints?: SprintCreateNestedManyWithoutProjectInput
    milestones?: MilestoneCreateNestedManyWithoutProjectInput
    boards?: BoardCreateNestedManyWithoutProjectInput
    workflowRules?: WorkflowRuleCreateNestedManyWithoutProjectInput
    workItemStates?: WorkItemStateCreateNestedManyWithoutProjectInput
    components?: ComponentCreateNestedManyWithoutProjectInput
    teams?: TeamCreateNestedManyWithoutProjectsInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    projectType?: string
    riskScore?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    portfolioId?: string | null
    organizationId: string
    leadUserId?: string | null
    workItems?: WorkItemUncheckedCreateNestedManyWithoutProjectInput
    sprints?: SprintUncheckedCreateNestedManyWithoutProjectInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutProjectInput
    boards?: BoardUncheckedCreateNestedManyWithoutProjectInput
    workflowRules?: WorkflowRuleUncheckedCreateNestedManyWithoutProjectInput
    workItemStates?: WorkItemStateUncheckedCreateNestedManyWithoutProjectInput
    components?: ComponentUncheckedCreateNestedManyWithoutProjectInput
    teams?: TeamUncheckedCreateNestedManyWithoutProjectsInput
  }

  export type ProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    projectType?: StringFieldUpdateOperationsInput | string
    riskScore?: FloatFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolio?: PortfolioUpdateOneWithoutProjectsNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    leadUser?: UserUpdateOneWithoutOwnedProjectsNestedInput
    workItems?: WorkItemUpdateManyWithoutProjectNestedInput
    sprints?: SprintUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUpdateManyWithoutProjectNestedInput
    boards?: BoardUpdateManyWithoutProjectNestedInput
    workflowRules?: WorkflowRuleUpdateManyWithoutProjectNestedInput
    workItemStates?: WorkItemStateUpdateManyWithoutProjectNestedInput
    components?: ComponentUpdateManyWithoutProjectNestedInput
    teams?: TeamUpdateManyWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    projectType?: StringFieldUpdateOperationsInput | string
    riskScore?: FloatFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolioId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    leadUserId?: NullableStringFieldUpdateOperationsInput | string | null
    workItems?: WorkItemUncheckedUpdateManyWithoutProjectNestedInput
    sprints?: SprintUncheckedUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutProjectNestedInput
    boards?: BoardUncheckedUpdateManyWithoutProjectNestedInput
    workflowRules?: WorkflowRuleUncheckedUpdateManyWithoutProjectNestedInput
    workItemStates?: WorkItemStateUncheckedUpdateManyWithoutProjectNestedInput
    components?: ComponentUncheckedUpdateManyWithoutProjectNestedInput
    teams?: TeamUncheckedUpdateManyWithoutProjectsNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    projectType?: string
    riskScore?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    portfolioId?: string | null
    organizationId: string
    leadUserId?: string | null
  }

  export type ProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    projectType?: StringFieldUpdateOperationsInput | string
    riskScore?: FloatFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    projectType?: StringFieldUpdateOperationsInput | string
    riskScore?: FloatFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolioId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    leadUserId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SprintCreateInput = {
    id?: string
    name: string
    goal?: string | null
    startDate: Date | string
    endDate: Date | string
    state?: string
    committedPoints?: number
    completedPoints?: number
    velocity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutSprintsInput
    workItems?: WorkItemCreateNestedManyWithoutSprintInput
    snapshots?: WorkItemSnapshotCreateNestedManyWithoutSprintInput
    retrospective?: RetrospectiveCreateNestedOneWithoutSprintInput
    timeLogs?: TimeLogCreateNestedManyWithoutSprintInput
    boards?: BoardCreateNestedManyWithoutSprintInput
  }

  export type SprintUncheckedCreateInput = {
    id?: string
    name: string
    goal?: string | null
    startDate: Date | string
    endDate: Date | string
    state?: string
    committedPoints?: number
    completedPoints?: number
    velocity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    workItems?: WorkItemUncheckedCreateNestedManyWithoutSprintInput
    snapshots?: WorkItemSnapshotUncheckedCreateNestedManyWithoutSprintInput
    retrospective?: RetrospectiveUncheckedCreateNestedOneWithoutSprintInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutSprintInput
    boards?: BoardUncheckedCreateNestedManyWithoutSprintInput
  }

  export type SprintUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    goal?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: StringFieldUpdateOperationsInput | string
    committedPoints?: FloatFieldUpdateOperationsInput | number
    completedPoints?: FloatFieldUpdateOperationsInput | number
    velocity?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutSprintsNestedInput
    workItems?: WorkItemUpdateManyWithoutSprintNestedInput
    snapshots?: WorkItemSnapshotUpdateManyWithoutSprintNestedInput
    retrospective?: RetrospectiveUpdateOneWithoutSprintNestedInput
    timeLogs?: TimeLogUpdateManyWithoutSprintNestedInput
    boards?: BoardUpdateManyWithoutSprintNestedInput
  }

  export type SprintUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    goal?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: StringFieldUpdateOperationsInput | string
    committedPoints?: FloatFieldUpdateOperationsInput | number
    completedPoints?: FloatFieldUpdateOperationsInput | number
    velocity?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    workItems?: WorkItemUncheckedUpdateManyWithoutSprintNestedInput
    snapshots?: WorkItemSnapshotUncheckedUpdateManyWithoutSprintNestedInput
    retrospective?: RetrospectiveUncheckedUpdateOneWithoutSprintNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutSprintNestedInput
    boards?: BoardUncheckedUpdateManyWithoutSprintNestedInput
  }

  export type SprintCreateManyInput = {
    id?: string
    name: string
    goal?: string | null
    startDate: Date | string
    endDate: Date | string
    state?: string
    committedPoints?: number
    completedPoints?: number
    velocity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type SprintUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    goal?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: StringFieldUpdateOperationsInput | string
    committedPoints?: FloatFieldUpdateOperationsInput | number
    completedPoints?: FloatFieldUpdateOperationsInput | number
    velocity?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SprintUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    goal?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: StringFieldUpdateOperationsInput | string
    committedPoints?: FloatFieldUpdateOperationsInput | number
    completedPoints?: FloatFieldUpdateOperationsInput | number
    velocity?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type MilestoneCreateInput = {
    id?: string
    name: string
    description?: string | null
    dueDate: Date | string
    completed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutMilestonesInput
  }

  export type MilestoneUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    dueDate: Date | string
    completed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type MilestoneUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMilestonesNestedInput
  }

  export type MilestoneUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type MilestoneCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    dueDate: Date | string
    completed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type MilestoneUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilestoneUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type RetrospectiveCreateInput = {
    id?: string
    content?: JsonNullValueInput | InputJsonValue
    sentimentSummary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sprint: SprintCreateNestedOneWithoutRetrospectiveInput
  }

  export type RetrospectiveUncheckedCreateInput = {
    id?: string
    content?: JsonNullValueInput | InputJsonValue
    sentimentSummary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sprintId: string
  }

  export type RetrospectiveUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    sentimentSummary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sprint?: SprintUpdateOneRequiredWithoutRetrospectiveNestedInput
  }

  export type RetrospectiveUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    sentimentSummary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sprintId?: StringFieldUpdateOperationsInput | string
  }

  export type RetrospectiveCreateManyInput = {
    id?: string
    content?: JsonNullValueInput | InputJsonValue
    sentimentSummary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sprintId: string
  }

  export type RetrospectiveUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    sentimentSummary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RetrospectiveUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    sentimentSummary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sprintId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkItemCreateInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.WorkItemType
    priority?: $Enums.Priority
    storyPoints?: number | null
    estimatedHours?: number | null
    remainingHours?: number | null
    order?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: WorkItemCreateNestedOneWithoutChildrenInput
    children?: WorkItemCreateNestedManyWithoutParentInput
    epic?: WorkItemCreateNestedOneWithoutStoriesInput
    stories?: WorkItemCreateNestedManyWithoutEpicInput
    project: ProjectCreateNestedOneWithoutWorkItemsInput
    state?: WorkItemStateCreateNestedOneWithoutWorkItemsInput
    assignee?: UserCreateNestedOneWithoutAssignedWorkItemsInput
    creator: UserCreateNestedOneWithoutCreatedWorkItemsInput
    sprint?: SprintCreateNestedOneWithoutWorkItemsInput
    details?: WorkItemDetailCreateNestedOneWithoutWorkItemInput
    dependenciesAsSource?: DependencyCreateNestedManyWithoutSourceItemInput
    dependenciesAsTarget?: DependencyCreateNestedManyWithoutTargetItemInput
    comments?: CommentCreateNestedManyWithoutWorkItemInput
    attachments?: AttachmentCreateNestedManyWithoutWorkItemInput
    timeLogs?: TimeLogCreateNestedManyWithoutWorkItemInput
    snapshots?: WorkItemSnapshotCreateNestedManyWithoutWorkItemInput
    tags?: TagOnWorkItemCreateNestedManyWithoutWorkItemInput
    components?: ComponentOnWorkItemCreateNestedManyWithoutWorkItemInput
    embedding?: WorkItemEmbeddingCreateNestedOneWithoutWorkItemInput
  }

  export type WorkItemUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.WorkItemType
    priority?: $Enums.Priority
    storyPoints?: number | null
    estimatedHours?: number | null
    remainingHours?: number | null
    order?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    epicId?: string | null
    projectId: string
    stateId?: string | null
    assigneeId?: string | null
    creatorId: string
    sprintId?: string | null
    children?: WorkItemUncheckedCreateNestedManyWithoutParentInput
    stories?: WorkItemUncheckedCreateNestedManyWithoutEpicInput
    details?: WorkItemDetailUncheckedCreateNestedOneWithoutWorkItemInput
    dependenciesAsSource?: DependencyUncheckedCreateNestedManyWithoutSourceItemInput
    dependenciesAsTarget?: DependencyUncheckedCreateNestedManyWithoutTargetItemInput
    comments?: CommentUncheckedCreateNestedManyWithoutWorkItemInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutWorkItemInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutWorkItemInput
    snapshots?: WorkItemSnapshotUncheckedCreateNestedManyWithoutWorkItemInput
    tags?: TagOnWorkItemUncheckedCreateNestedManyWithoutWorkItemInput
    components?: ComponentOnWorkItemUncheckedCreateNestedManyWithoutWorkItemInput
    embedding?: WorkItemEmbeddingUncheckedCreateNestedOneWithoutWorkItemInput
  }

  export type WorkItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWorkItemTypeFieldUpdateOperationsInput | $Enums.WorkItemType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    storyPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: WorkItemUpdateOneWithoutChildrenNestedInput
    children?: WorkItemUpdateManyWithoutParentNestedInput
    epic?: WorkItemUpdateOneWithoutStoriesNestedInput
    stories?: WorkItemUpdateManyWithoutEpicNestedInput
    project?: ProjectUpdateOneRequiredWithoutWorkItemsNestedInput
    state?: WorkItemStateUpdateOneWithoutWorkItemsNestedInput
    assignee?: UserUpdateOneWithoutAssignedWorkItemsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedWorkItemsNestedInput
    sprint?: SprintUpdateOneWithoutWorkItemsNestedInput
    details?: WorkItemDetailUpdateOneWithoutWorkItemNestedInput
    dependenciesAsSource?: DependencyUpdateManyWithoutSourceItemNestedInput
    dependenciesAsTarget?: DependencyUpdateManyWithoutTargetItemNestedInput
    comments?: CommentUpdateManyWithoutWorkItemNestedInput
    attachments?: AttachmentUpdateManyWithoutWorkItemNestedInput
    timeLogs?: TimeLogUpdateManyWithoutWorkItemNestedInput
    snapshots?: WorkItemSnapshotUpdateManyWithoutWorkItemNestedInput
    tags?: TagOnWorkItemUpdateManyWithoutWorkItemNestedInput
    components?: ComponentOnWorkItemUpdateManyWithoutWorkItemNestedInput
    embedding?: WorkItemEmbeddingUpdateOneWithoutWorkItemNestedInput
  }

  export type WorkItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWorkItemTypeFieldUpdateOperationsInput | $Enums.WorkItemType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    storyPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    epicId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: WorkItemUncheckedUpdateManyWithoutParentNestedInput
    stories?: WorkItemUncheckedUpdateManyWithoutEpicNestedInput
    details?: WorkItemDetailUncheckedUpdateOneWithoutWorkItemNestedInput
    dependenciesAsSource?: DependencyUncheckedUpdateManyWithoutSourceItemNestedInput
    dependenciesAsTarget?: DependencyUncheckedUpdateManyWithoutTargetItemNestedInput
    comments?: CommentUncheckedUpdateManyWithoutWorkItemNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutWorkItemNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutWorkItemNestedInput
    snapshots?: WorkItemSnapshotUncheckedUpdateManyWithoutWorkItemNestedInput
    tags?: TagOnWorkItemUncheckedUpdateManyWithoutWorkItemNestedInput
    components?: ComponentOnWorkItemUncheckedUpdateManyWithoutWorkItemNestedInput
    embedding?: WorkItemEmbeddingUncheckedUpdateOneWithoutWorkItemNestedInput
  }

  export type WorkItemCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.WorkItemType
    priority?: $Enums.Priority
    storyPoints?: number | null
    estimatedHours?: number | null
    remainingHours?: number | null
    order?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    epicId?: string | null
    projectId: string
    stateId?: string | null
    assigneeId?: string | null
    creatorId: string
    sprintId?: string | null
  }

  export type WorkItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWorkItemTypeFieldUpdateOperationsInput | $Enums.WorkItemType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    storyPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWorkItemTypeFieldUpdateOperationsInput | $Enums.WorkItemType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    storyPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    epicId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkItemDetailCreateInput = {
    id?: string
    acceptanceCriteria?: string | null
    technicalNotes?: string | null
    reproSteps?: string | null
    businessValue?: string | null
    userPersona?: string | null
    customFields?: JsonNullValueInput | InputJsonValue
    externalReferences?: string | null
    workItem: WorkItemCreateNestedOneWithoutDetailsInput
  }

  export type WorkItemDetailUncheckedCreateInput = {
    id?: string
    acceptanceCriteria?: string | null
    technicalNotes?: string | null
    reproSteps?: string | null
    businessValue?: string | null
    userPersona?: string | null
    customFields?: JsonNullValueInput | InputJsonValue
    externalReferences?: string | null
    workItemId: string
  }

  export type WorkItemDetailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    acceptanceCriteria?: NullableStringFieldUpdateOperationsInput | string | null
    technicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    reproSteps?: NullableStringFieldUpdateOperationsInput | string | null
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    userPersona?: NullableStringFieldUpdateOperationsInput | string | null
    customFields?: JsonNullValueInput | InputJsonValue
    externalReferences?: NullableStringFieldUpdateOperationsInput | string | null
    workItem?: WorkItemUpdateOneRequiredWithoutDetailsNestedInput
  }

  export type WorkItemDetailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    acceptanceCriteria?: NullableStringFieldUpdateOperationsInput | string | null
    technicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    reproSteps?: NullableStringFieldUpdateOperationsInput | string | null
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    userPersona?: NullableStringFieldUpdateOperationsInput | string | null
    customFields?: JsonNullValueInput | InputJsonValue
    externalReferences?: NullableStringFieldUpdateOperationsInput | string | null
    workItemId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkItemDetailCreateManyInput = {
    id?: string
    acceptanceCriteria?: string | null
    technicalNotes?: string | null
    reproSteps?: string | null
    businessValue?: string | null
    userPersona?: string | null
    customFields?: JsonNullValueInput | InputJsonValue
    externalReferences?: string | null
    workItemId: string
  }

  export type WorkItemDetailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    acceptanceCriteria?: NullableStringFieldUpdateOperationsInput | string | null
    technicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    reproSteps?: NullableStringFieldUpdateOperationsInput | string | null
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    userPersona?: NullableStringFieldUpdateOperationsInput | string | null
    customFields?: JsonNullValueInput | InputJsonValue
    externalReferences?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkItemDetailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    acceptanceCriteria?: NullableStringFieldUpdateOperationsInput | string | null
    technicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    reproSteps?: NullableStringFieldUpdateOperationsInput | string | null
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    userPersona?: NullableStringFieldUpdateOperationsInput | string | null
    customFields?: JsonNullValueInput | InputJsonValue
    externalReferences?: NullableStringFieldUpdateOperationsInput | string | null
    workItemId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkItemStateCreateInput = {
    id?: string
    name: string
    category: $Enums.WorkItemStateCategory
    position: number
    wipLimit?: number | null
    color?: string
    icon?: string | null
    isInitial?: boolean
    isFinal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutWorkItemStatesInput
    workItems?: WorkItemCreateNestedManyWithoutStateInput
  }

  export type WorkItemStateUncheckedCreateInput = {
    id?: string
    name: string
    category: $Enums.WorkItemStateCategory
    position: number
    wipLimit?: number | null
    color?: string
    icon?: string | null
    isInitial?: boolean
    isFinal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    workItems?: WorkItemUncheckedCreateNestedManyWithoutStateInput
  }

  export type WorkItemStateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumWorkItemStateCategoryFieldUpdateOperationsInput | $Enums.WorkItemStateCategory
    position?: IntFieldUpdateOperationsInput | number
    wipLimit?: NullableIntFieldUpdateOperationsInput | number | null
    color?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isInitial?: BoolFieldUpdateOperationsInput | boolean
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutWorkItemStatesNestedInput
    workItems?: WorkItemUpdateManyWithoutStateNestedInput
  }

  export type WorkItemStateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumWorkItemStateCategoryFieldUpdateOperationsInput | $Enums.WorkItemStateCategory
    position?: IntFieldUpdateOperationsInput | number
    wipLimit?: NullableIntFieldUpdateOperationsInput | number | null
    color?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isInitial?: BoolFieldUpdateOperationsInput | boolean
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    workItems?: WorkItemUncheckedUpdateManyWithoutStateNestedInput
  }

  export type WorkItemStateCreateManyInput = {
    id?: string
    name: string
    category: $Enums.WorkItemStateCategory
    position: number
    wipLimit?: number | null
    color?: string
    icon?: string | null
    isInitial?: boolean
    isFinal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type WorkItemStateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumWorkItemStateCategoryFieldUpdateOperationsInput | $Enums.WorkItemStateCategory
    position?: IntFieldUpdateOperationsInput | number
    wipLimit?: NullableIntFieldUpdateOperationsInput | number | null
    color?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isInitial?: BoolFieldUpdateOperationsInput | boolean
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkItemStateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumWorkItemStateCategoryFieldUpdateOperationsInput | $Enums.WorkItemStateCategory
    position?: IntFieldUpdateOperationsInput | number
    wipLimit?: NullableIntFieldUpdateOperationsInput | number | null
    color?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isInitial?: BoolFieldUpdateOperationsInput | boolean
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type BoardCreateInput = {
    id?: string
    name: string
    boardType?: string
    filterQuery?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutBoardsInput
    sprint?: SprintCreateNestedOneWithoutBoardsInput
    lanes?: BoardLaneCreateNestedManyWithoutBoardInput
  }

  export type BoardUncheckedCreateInput = {
    id?: string
    name: string
    boardType?: string
    filterQuery?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    sprintId?: string | null
    lanes?: BoardLaneUncheckedCreateNestedManyWithoutBoardInput
  }

  export type BoardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    boardType?: StringFieldUpdateOperationsInput | string
    filterQuery?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutBoardsNestedInput
    sprint?: SprintUpdateOneWithoutBoardsNestedInput
    lanes?: BoardLaneUpdateManyWithoutBoardNestedInput
  }

  export type BoardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    boardType?: StringFieldUpdateOperationsInput | string
    filterQuery?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    lanes?: BoardLaneUncheckedUpdateManyWithoutBoardNestedInput
  }

  export type BoardCreateManyInput = {
    id?: string
    name: string
    boardType?: string
    filterQuery?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    sprintId?: string | null
  }

  export type BoardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    boardType?: StringFieldUpdateOperationsInput | string
    filterQuery?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BoardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    boardType?: StringFieldUpdateOperationsInput | string
    filterQuery?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BoardLaneCreateInput = {
    id?: string
    name: string
    position: number
    wipLimit?: number | null
    colorConfig?: JsonNullValueInput | InputJsonValue
    mappedStates?: BoardLaneCreatemappedStatesInput | string[]
    isCollapsed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    board: BoardCreateNestedOneWithoutLanesInput
  }

  export type BoardLaneUncheckedCreateInput = {
    id?: string
    name: string
    position: number
    wipLimit?: number | null
    colorConfig?: JsonNullValueInput | InputJsonValue
    mappedStates?: BoardLaneCreatemappedStatesInput | string[]
    isCollapsed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    boardId: string
  }

  export type BoardLaneUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    wipLimit?: NullableIntFieldUpdateOperationsInput | number | null
    colorConfig?: JsonNullValueInput | InputJsonValue
    mappedStates?: BoardLaneUpdatemappedStatesInput | string[]
    isCollapsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    board?: BoardUpdateOneRequiredWithoutLanesNestedInput
  }

  export type BoardLaneUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    wipLimit?: NullableIntFieldUpdateOperationsInput | number | null
    colorConfig?: JsonNullValueInput | InputJsonValue
    mappedStates?: BoardLaneUpdatemappedStatesInput | string[]
    isCollapsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    boardId?: StringFieldUpdateOperationsInput | string
  }

  export type BoardLaneCreateManyInput = {
    id?: string
    name: string
    position: number
    wipLimit?: number | null
    colorConfig?: JsonNullValueInput | InputJsonValue
    mappedStates?: BoardLaneCreatemappedStatesInput | string[]
    isCollapsed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    boardId: string
  }

  export type BoardLaneUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    wipLimit?: NullableIntFieldUpdateOperationsInput | number | null
    colorConfig?: JsonNullValueInput | InputJsonValue
    mappedStates?: BoardLaneUpdatemappedStatesInput | string[]
    isCollapsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BoardLaneUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    wipLimit?: NullableIntFieldUpdateOperationsInput | number | null
    colorConfig?: JsonNullValueInput | InputJsonValue
    mappedStates?: BoardLaneUpdatemappedStatesInput | string[]
    isCollapsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    boardId?: StringFieldUpdateOperationsInput | string
  }

  export type TagCreateInput = {
    id?: string
    name: string
    color?: string
    description?: string | null
    createdAt?: Date | string
    workItems?: TagOnWorkItemCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateInput = {
    id?: string
    name: string
    color?: string
    description?: string | null
    createdAt?: Date | string
    workItems?: TagOnWorkItemUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workItems?: TagOnWorkItemUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workItems?: TagOnWorkItemUncheckedUpdateManyWithoutTagNestedInput
  }

  export type TagCreateManyInput = {
    id?: string
    name: string
    color?: string
    description?: string | null
    createdAt?: Date | string
  }

  export type TagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagOnWorkItemCreateInput = {
    workItem: WorkItemCreateNestedOneWithoutTagsInput
    tag: TagCreateNestedOneWithoutWorkItemsInput
  }

  export type TagOnWorkItemUncheckedCreateInput = {
    workItemId: string
    tagId: string
  }

  export type TagOnWorkItemUpdateInput = {
    workItem?: WorkItemUpdateOneRequiredWithoutTagsNestedInput
    tag?: TagUpdateOneRequiredWithoutWorkItemsNestedInput
  }

  export type TagOnWorkItemUncheckedUpdateInput = {
    workItemId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type TagOnWorkItemCreateManyInput = {
    workItemId: string
    tagId: string
  }

  export type TagOnWorkItemUpdateManyMutationInput = {

  }

  export type TagOnWorkItemUncheckedUpdateManyInput = {
    workItemId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type ComponentCreateInput = {
    id?: string
    name: string
    description?: string | null
    color?: string
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutComponentsInput
    workItems?: ComponentOnWorkItemCreateNestedManyWithoutComponentInput
  }

  export type ComponentUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    color?: string
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    workItems?: ComponentOnWorkItemUncheckedCreateNestedManyWithoutComponentInput
  }

  export type ComponentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutComponentsNestedInput
    workItems?: ComponentOnWorkItemUpdateManyWithoutComponentNestedInput
  }

  export type ComponentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    workItems?: ComponentOnWorkItemUncheckedUpdateManyWithoutComponentNestedInput
  }

  export type ComponentCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    color?: string
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type ComponentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComponentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type ComponentOnWorkItemCreateInput = {
    assignedAt?: Date | string
    workItem: WorkItemCreateNestedOneWithoutComponentsInput
    component: ComponentCreateNestedOneWithoutWorkItemsInput
  }

  export type ComponentOnWorkItemUncheckedCreateInput = {
    workItemId: string
    componentId: string
    assignedAt?: Date | string
  }

  export type ComponentOnWorkItemUpdateInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workItem?: WorkItemUpdateOneRequiredWithoutComponentsNestedInput
    component?: ComponentUpdateOneRequiredWithoutWorkItemsNestedInput
  }

  export type ComponentOnWorkItemUncheckedUpdateInput = {
    workItemId?: StringFieldUpdateOperationsInput | string
    componentId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComponentOnWorkItemCreateManyInput = {
    workItemId: string
    componentId: string
    assignedAt?: Date | string
  }

  export type ComponentOnWorkItemUpdateManyMutationInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComponentOnWorkItemUncheckedUpdateManyInput = {
    workItemId?: StringFieldUpdateOperationsInput | string
    componentId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DependencyCreateInput = {
    id?: string
    dependencyType?: string
    description?: string | null
    createdAt?: Date | string
    sourceItem: WorkItemCreateNestedOneWithoutDependenciesAsSourceInput
    targetItem: WorkItemCreateNestedOneWithoutDependenciesAsTargetInput
  }

  export type DependencyUncheckedCreateInput = {
    id?: string
    dependencyType?: string
    description?: string | null
    createdAt?: Date | string
    sourceItemId: string
    targetItemId: string
  }

  export type DependencyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dependencyType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceItem?: WorkItemUpdateOneRequiredWithoutDependenciesAsSourceNestedInput
    targetItem?: WorkItemUpdateOneRequiredWithoutDependenciesAsTargetNestedInput
  }

  export type DependencyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dependencyType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceItemId?: StringFieldUpdateOperationsInput | string
    targetItemId?: StringFieldUpdateOperationsInput | string
  }

  export type DependencyCreateManyInput = {
    id?: string
    dependencyType?: string
    description?: string | null
    createdAt?: Date | string
    sourceItemId: string
    targetItemId: string
  }

  export type DependencyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dependencyType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DependencyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    dependencyType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceItemId?: StringFieldUpdateOperationsInput | string
    targetItemId?: StringFieldUpdateOperationsInput | string
  }

  export type TimeLogCreateInput = {
    id?: string
    duration: number
    description?: string | null
    billable?: boolean
    logDate: Date | string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workItem: WorkItemCreateNestedOneWithoutTimeLogsInput
    user: UserCreateNestedOneWithoutTimeLogsInput
    sprint?: SprintCreateNestedOneWithoutTimeLogsInput
  }

  export type TimeLogUncheckedCreateInput = {
    id?: string
    duration: number
    description?: string | null
    billable?: boolean
    logDate: Date | string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workItemId: string
    userId: string
    sprintId?: string | null
  }

  export type TimeLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    billable?: BoolFieldUpdateOperationsInput | boolean
    logDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workItem?: WorkItemUpdateOneRequiredWithoutTimeLogsNestedInput
    user?: UserUpdateOneRequiredWithoutTimeLogsNestedInput
    sprint?: SprintUpdateOneWithoutTimeLogsNestedInput
  }

  export type TimeLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    billable?: BoolFieldUpdateOperationsInput | boolean
    logDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workItemId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TimeLogCreateManyInput = {
    id?: string
    duration: number
    description?: string | null
    billable?: boolean
    logDate: Date | string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workItemId: string
    userId: string
    sprintId?: string | null
  }

  export type TimeLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    billable?: BoolFieldUpdateOperationsInput | boolean
    logDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    billable?: BoolFieldUpdateOperationsInput | boolean
    logDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workItemId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentCreateInput = {
    id?: string
    body: string
    sentimentScore?: number | null
    sentimentLabel?: string | null
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workItem: WorkItemCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    body: string
    sentimentScore?: number | null
    sentimentLabel?: string | null
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workItemId: string
    userId: string
  }

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    sentimentLabel?: NullableStringFieldUpdateOperationsInput | string | null
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workItem?: WorkItemUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    sentimentLabel?: NullableStringFieldUpdateOperationsInput | string | null
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workItemId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type CommentCreateManyInput = {
    id?: string
    body: string
    sentimentScore?: number | null
    sentimentLabel?: string | null
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workItemId: string
    userId: string
  }

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    sentimentLabel?: NullableStringFieldUpdateOperationsInput | string | null
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    sentimentLabel?: NullableStringFieldUpdateOperationsInput | string | null
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workItemId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type AttachmentCreateInput = {
    id?: string
    fileName: string
    fileType: string
    fileSize: number
    storagePath: string
    fileUrl: string
    ocrContent?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    uploadedBy: string
    workItem: WorkItemCreateNestedOneWithoutAttachmentsInput
  }

  export type AttachmentUncheckedCreateInput = {
    id?: string
    fileName: string
    fileType: string
    fileSize: number
    storagePath: string
    fileUrl: string
    ocrContent?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    workItemId: string
    uploadedBy: string
  }

  export type AttachmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storagePath?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    ocrContent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    workItem?: WorkItemUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type AttachmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storagePath?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    ocrContent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workItemId?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
  }

  export type AttachmentCreateManyInput = {
    id?: string
    fileName: string
    fileType: string
    fileSize: number
    storagePath: string
    fileUrl: string
    ocrContent?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    workItemId: string
    uploadedBy: string
  }

  export type AttachmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storagePath?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    ocrContent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
  }

  export type AttachmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storagePath?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    ocrContent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workItemId?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
  }

  export type WorkItemEmbeddingUpdateInput = {
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workItem?: WorkItemUpdateOneRequiredWithoutEmbeddingNestedInput
  }

  export type WorkItemEmbeddingUncheckedUpdateInput = {
    workItemId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkItemEmbeddingUpdateManyMutationInput = {
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkItemEmbeddingUncheckedUpdateManyInput = {
    workItemId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkItemSnapshotCreateInput = {
    id?: string
    stateId?: string | null
    pointsRemaining?: number | null
    hoursRemaining?: number | null
    hoursSpent?: number | null
    daysInCurrentState?: number
    blockerIds?: WorkItemSnapshotCreateblockerIdsInput | string[]
    snapshotDate?: Date | string
    workItem: WorkItemCreateNestedOneWithoutSnapshotsInput
    sprint?: SprintCreateNestedOneWithoutSnapshotsInput
  }

  export type WorkItemSnapshotUncheckedCreateInput = {
    id?: string
    stateId?: string | null
    pointsRemaining?: number | null
    hoursRemaining?: number | null
    hoursSpent?: number | null
    daysInCurrentState?: number
    blockerIds?: WorkItemSnapshotCreateblockerIdsInput | string[]
    snapshotDate?: Date | string
    workItemId: string
    sprintId?: string | null
  }

  export type WorkItemSnapshotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    pointsRemaining?: NullableFloatFieldUpdateOperationsInput | number | null
    hoursRemaining?: NullableFloatFieldUpdateOperationsInput | number | null
    hoursSpent?: NullableFloatFieldUpdateOperationsInput | number | null
    daysInCurrentState?: IntFieldUpdateOperationsInput | number
    blockerIds?: WorkItemSnapshotUpdateblockerIdsInput | string[]
    snapshotDate?: DateTimeFieldUpdateOperationsInput | Date | string
    workItem?: WorkItemUpdateOneRequiredWithoutSnapshotsNestedInput
    sprint?: SprintUpdateOneWithoutSnapshotsNestedInput
  }

  export type WorkItemSnapshotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    pointsRemaining?: NullableFloatFieldUpdateOperationsInput | number | null
    hoursRemaining?: NullableFloatFieldUpdateOperationsInput | number | null
    hoursSpent?: NullableFloatFieldUpdateOperationsInput | number | null
    daysInCurrentState?: IntFieldUpdateOperationsInput | number
    blockerIds?: WorkItemSnapshotUpdateblockerIdsInput | string[]
    snapshotDate?: DateTimeFieldUpdateOperationsInput | Date | string
    workItemId?: StringFieldUpdateOperationsInput | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkItemSnapshotCreateManyInput = {
    id?: string
    stateId?: string | null
    pointsRemaining?: number | null
    hoursRemaining?: number | null
    hoursSpent?: number | null
    daysInCurrentState?: number
    blockerIds?: WorkItemSnapshotCreateblockerIdsInput | string[]
    snapshotDate?: Date | string
    workItemId: string
    sprintId?: string | null
  }

  export type WorkItemSnapshotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    pointsRemaining?: NullableFloatFieldUpdateOperationsInput | number | null
    hoursRemaining?: NullableFloatFieldUpdateOperationsInput | number | null
    hoursSpent?: NullableFloatFieldUpdateOperationsInput | number | null
    daysInCurrentState?: IntFieldUpdateOperationsInput | number
    blockerIds?: WorkItemSnapshotUpdateblockerIdsInput | string[]
    snapshotDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkItemSnapshotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    pointsRemaining?: NullableFloatFieldUpdateOperationsInput | number | null
    hoursRemaining?: NullableFloatFieldUpdateOperationsInput | number | null
    hoursSpent?: NullableFloatFieldUpdateOperationsInput | number | null
    daysInCurrentState?: IntFieldUpdateOperationsInput | number
    blockerIds?: WorkItemSnapshotUpdateblockerIdsInput | string[]
    snapshotDate?: DateTimeFieldUpdateOperationsInput | Date | string
    workItemId?: StringFieldUpdateOperationsInput | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserSkillProfileCreateInput = {
    id?: string
    skills?: UserSkillProfileCreateskillsInput | string[]
    proficiencyScores?: JsonNullValueInput | InputJsonValue
    certifiedSkills?: UserSkillProfileCreatecertifiedSkillsInput | string[]
    overallProficiency?: number
    lastUpdated?: Date | string
    user: UserCreateNestedOneWithoutSkillProfileInput
    team?: TeamCreateNestedOneWithoutSkillProfilesInput
  }

  export type UserSkillProfileUncheckedCreateInput = {
    id?: string
    skills?: UserSkillProfileCreateskillsInput | string[]
    proficiencyScores?: JsonNullValueInput | InputJsonValue
    certifiedSkills?: UserSkillProfileCreatecertifiedSkillsInput | string[]
    overallProficiency?: number
    lastUpdated?: Date | string
    userId: string
    teamId?: string | null
  }

  export type UserSkillProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    skills?: UserSkillProfileUpdateskillsInput | string[]
    proficiencyScores?: JsonNullValueInput | InputJsonValue
    certifiedSkills?: UserSkillProfileUpdatecertifiedSkillsInput | string[]
    overallProficiency?: FloatFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSkillProfileNestedInput
    team?: TeamUpdateOneWithoutSkillProfilesNestedInput
  }

  export type UserSkillProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    skills?: UserSkillProfileUpdateskillsInput | string[]
    proficiencyScores?: JsonNullValueInput | InputJsonValue
    certifiedSkills?: UserSkillProfileUpdatecertifiedSkillsInput | string[]
    overallProficiency?: FloatFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserSkillProfileCreateManyInput = {
    id?: string
    skills?: UserSkillProfileCreateskillsInput | string[]
    proficiencyScores?: JsonNullValueInput | InputJsonValue
    certifiedSkills?: UserSkillProfileCreatecertifiedSkillsInput | string[]
    overallProficiency?: number
    lastUpdated?: Date | string
    userId: string
    teamId?: string | null
  }

  export type UserSkillProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    skills?: UserSkillProfileUpdateskillsInput | string[]
    proficiencyScores?: JsonNullValueInput | InputJsonValue
    certifiedSkills?: UserSkillProfileUpdatecertifiedSkillsInput | string[]
    overallProficiency?: FloatFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSkillProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    skills?: UserSkillProfileUpdateskillsInput | string[]
    proficiencyScores?: JsonNullValueInput | InputJsonValue
    certifiedSkills?: UserSkillProfileUpdatecertifiedSkillsInput | string[]
    overallProficiency?: FloatFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkflowRuleCreateInput = {
    id?: string
    name: string
    description?: string | null
    trigger: string
    action: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutWorkflowRulesInput
  }

  export type WorkflowRuleUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    trigger: string
    action: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type WorkflowRuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trigger?: StringFieldUpdateOperationsInput | string
    action?: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutWorkflowRulesNestedInput
  }

  export type WorkflowRuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trigger?: StringFieldUpdateOperationsInput | string
    action?: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkflowRuleCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    trigger: string
    action: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type WorkflowRuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trigger?: StringFieldUpdateOperationsInput | string
    action?: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowRuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trigger?: StringFieldUpdateOperationsInput | string
    action?: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: string
    title: string
    body?: string | null
    targetUrl?: string | null
    priorityScore?: number
    isRead?: boolean
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    type: string
    title: string
    body?: string | null
    targetUrl?: string | null
    priorityScore?: number
    isRead?: boolean
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
    userId: string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    targetUrl?: NullableStringFieldUpdateOperationsInput | string | null
    priorityScore?: FloatFieldUpdateOperationsInput | number
    isRead?: BoolFieldUpdateOperationsInput | boolean
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    targetUrl?: NullableStringFieldUpdateOperationsInput | string | null
    priorityScore?: FloatFieldUpdateOperationsInput | number
    isRead?: BoolFieldUpdateOperationsInput | boolean
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    type: string
    title: string
    body?: string | null
    targetUrl?: string | null
    priorityScore?: number
    isRead?: boolean
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
    userId: string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    targetUrl?: NullableStringFieldUpdateOperationsInput | string | null
    priorityScore?: FloatFieldUpdateOperationsInput | number
    isRead?: BoolFieldUpdateOperationsInput | boolean
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    targetUrl?: NullableStringFieldUpdateOperationsInput | string | null
    priorityScore?: FloatFieldUpdateOperationsInput | number
    isRead?: BoolFieldUpdateOperationsInput | boolean
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ActivityLogCreateInput = {
    id?: string
    entityType: string
    entityId: string
    action: string
    actorId?: string | null
    changeDiff: JsonNullValueInput | InputJsonValue
    context?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ActivityLogUncheckedCreateInput = {
    id?: string
    entityType: string
    entityId: string
    action: string
    actorId?: string | null
    changeDiff: JsonNullValueInput | InputJsonValue
    context?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ActivityLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    changeDiff?: JsonNullValueInput | InputJsonValue
    context?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    changeDiff?: JsonNullValueInput | InputJsonValue
    context?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogCreateManyInput = {
    id?: string
    entityType: string
    entityId: string
    action: string
    actorId?: string | null
    changeDiff: JsonNullValueInput | InputJsonValue
    context?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ActivityLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    changeDiff?: JsonNullValueInput | InputJsonValue
    context?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    changeDiff?: JsonNullValueInput | InputJsonValue
    context?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type OrganizationMembershipListRelationFilter = {
    every?: OrganizationMembershipWhereInput
    some?: OrganizationMembershipWhereInput
    none?: OrganizationMembershipWhereInput
  }

  export type TeamMembershipListRelationFilter = {
    every?: TeamMembershipWhereInput
    some?: TeamMembershipWhereInput
    none?: TeamMembershipWhereInput
  }

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput
    some?: ProjectWhereInput
    none?: ProjectWhereInput
  }

  export type WorkItemListRelationFilter = {
    every?: WorkItemWhereInput
    some?: WorkItemWhereInput
    none?: WorkItemWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type TimeLogListRelationFilter = {
    every?: TimeLogWhereInput
    some?: TimeLogWhereInput
    none?: TimeLogWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type UserSkillProfileNullableScalarRelationFilter = {
    is?: UserSkillProfileWhereInput | null
    isNot?: UserSkillProfileWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationMembershipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamMembershipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TimeLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    avatarUrl?: SortOrder
    timezone?: SortOrder
    availabilityHours?: SortOrder
    isActive?: SortOrder
    preferences?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    availabilityHours?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    avatarUrl?: SortOrder
    timezone?: SortOrder
    availabilityHours?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    avatarUrl?: SortOrder
    timezone?: SortOrder
    availabilityHours?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    availabilityHours?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type VerificationCountOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMinOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PortfolioListRelationFilter = {
    every?: PortfolioWhereInput
    some?: PortfolioWhereInput
    none?: PortfolioWhereInput
  }

  export type TeamListRelationFilter = {
    every?: TeamWhereInput
    some?: TeamWhereInput
    none?: TeamWhereInput
  }

  export type PortfolioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    planTier?: SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    planTier?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    planTier?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationScalarRelationFilter = {
    is?: OrganizationWhereInput
    isNot?: OrganizationWhereInput
  }

  export type UserSkillProfileListRelationFilter = {
    every?: UserSkillProfileWhereInput
    some?: UserSkillProfileWhereInput
    none?: UserSkillProfileWhereInput
  }

  export type UserSkillProfileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    velocityHistory?: SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organizationId?: SortOrder
  }

  export type TeamMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organizationId?: SortOrder
  }

  export type TeamMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organizationId?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    permissions?: SortOrder
    createdAt?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type OrganizationMembershipUserIdOrganizationIdCompoundUniqueInput = {
    userId: string
    organizationId: string
  }

  export type OrganizationMembershipCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    organizationId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type OrganizationMembershipMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    organizationId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type OrganizationMembershipMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    organizationId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type TeamScalarRelationFilter = {
    is?: TeamWhereInput
    isNot?: TeamWhereInput
  }

  export type RoleNullableScalarRelationFilter = {
    is?: RoleWhereInput | null
    isNot?: RoleWhereInput | null
  }

  export type TeamMembershipCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
    roleId?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrder
  }

  export type TeamMembershipMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
    roleId?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrder
  }

  export type TeamMembershipMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
    roleId?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrder
  }

  export type PortfolioCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    strategicGoal?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organizationId?: SortOrder
  }

  export type PortfolioMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    strategicGoal?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organizationId?: SortOrder
  }

  export type PortfolioMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    strategicGoal?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organizationId?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type PortfolioNullableScalarRelationFilter = {
    is?: PortfolioWhereInput | null
    isNot?: PortfolioWhereInput | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type SprintListRelationFilter = {
    every?: SprintWhereInput
    some?: SprintWhereInput
    none?: SprintWhereInput
  }

  export type MilestoneListRelationFilter = {
    every?: MilestoneWhereInput
    some?: MilestoneWhereInput
    none?: MilestoneWhereInput
  }

  export type BoardListRelationFilter = {
    every?: BoardWhereInput
    some?: BoardWhereInput
    none?: BoardWhereInput
  }

  export type WorkflowRuleListRelationFilter = {
    every?: WorkflowRuleWhereInput
    some?: WorkflowRuleWhereInput
    none?: WorkflowRuleWhereInput
  }

  export type WorkItemStateListRelationFilter = {
    every?: WorkItemStateWhereInput
    some?: WorkItemStateWhereInput
    none?: WorkItemStateWhereInput
  }

  export type ComponentListRelationFilter = {
    every?: ComponentWhereInput
    some?: ComponentWhereInput
    none?: ComponentWhereInput
  }

  export type SprintOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MilestoneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BoardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkflowRuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkItemStateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ComponentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectOrganizationIdKeyCompoundUniqueInput = {
    organizationId: string
    key: string
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    description?: SortOrder
    projectType?: SortOrder
    riskScore?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    portfolioId?: SortOrder
    organizationId?: SortOrder
    leadUserId?: SortOrder
  }

  export type ProjectAvgOrderByAggregateInput = {
    riskScore?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    description?: SortOrder
    projectType?: SortOrder
    riskScore?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    portfolioId?: SortOrder
    organizationId?: SortOrder
    leadUserId?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    description?: SortOrder
    projectType?: SortOrder
    riskScore?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    portfolioId?: SortOrder
    organizationId?: SortOrder
    leadUserId?: SortOrder
  }

  export type ProjectSumOrderByAggregateInput = {
    riskScore?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type ProjectScalarRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type WorkItemSnapshotListRelationFilter = {
    every?: WorkItemSnapshotWhereInput
    some?: WorkItemSnapshotWhereInput
    none?: WorkItemSnapshotWhereInput
  }

  export type RetrospectiveNullableScalarRelationFilter = {
    is?: RetrospectiveWhereInput | null
    isNot?: RetrospectiveWhereInput | null
  }

  export type WorkItemSnapshotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SprintCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    goal?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    state?: SortOrder
    committedPoints?: SortOrder
    completedPoints?: SortOrder
    velocity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type SprintAvgOrderByAggregateInput = {
    committedPoints?: SortOrder
    completedPoints?: SortOrder
    velocity?: SortOrder
  }

  export type SprintMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    goal?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    state?: SortOrder
    committedPoints?: SortOrder
    completedPoints?: SortOrder
    velocity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type SprintMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    goal?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    state?: SortOrder
    committedPoints?: SortOrder
    completedPoints?: SortOrder
    velocity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type SprintSumOrderByAggregateInput = {
    committedPoints?: SortOrder
    completedPoints?: SortOrder
    velocity?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type MilestoneCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    dueDate?: SortOrder
    completed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type MilestoneMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    dueDate?: SortOrder
    completed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type MilestoneMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    dueDate?: SortOrder
    completed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type SprintScalarRelationFilter = {
    is?: SprintWhereInput
    isNot?: SprintWhereInput
  }

  export type RetrospectiveCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    sentimentSummary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sprintId?: SortOrder
  }

  export type RetrospectiveMaxOrderByAggregateInput = {
    id?: SortOrder
    sentimentSummary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sprintId?: SortOrder
  }

  export type RetrospectiveMinOrderByAggregateInput = {
    id?: SortOrder
    sentimentSummary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sprintId?: SortOrder
  }

  export type EnumWorkItemTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkItemType | EnumWorkItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkItemType[] | ListEnumWorkItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkItemType[] | ListEnumWorkItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkItemTypeFilter<$PrismaModel> | $Enums.WorkItemType
  }

  export type EnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type WorkItemNullableScalarRelationFilter = {
    is?: WorkItemWhereInput | null
    isNot?: WorkItemWhereInput | null
  }

  export type WorkItemStateNullableScalarRelationFilter = {
    is?: WorkItemStateWhereInput | null
    isNot?: WorkItemStateWhereInput | null
  }

  export type SprintNullableScalarRelationFilter = {
    is?: SprintWhereInput | null
    isNot?: SprintWhereInput | null
  }

  export type WorkItemDetailNullableScalarRelationFilter = {
    is?: WorkItemDetailWhereInput | null
    isNot?: WorkItemDetailWhereInput | null
  }

  export type DependencyListRelationFilter = {
    every?: DependencyWhereInput
    some?: DependencyWhereInput
    none?: DependencyWhereInput
  }

  export type AttachmentListRelationFilter = {
    every?: AttachmentWhereInput
    some?: AttachmentWhereInput
    none?: AttachmentWhereInput
  }

  export type TagOnWorkItemListRelationFilter = {
    every?: TagOnWorkItemWhereInput
    some?: TagOnWorkItemWhereInput
    none?: TagOnWorkItemWhereInput
  }

  export type ComponentOnWorkItemListRelationFilter = {
    every?: ComponentOnWorkItemWhereInput
    some?: ComponentOnWorkItemWhereInput
    none?: ComponentOnWorkItemWhereInput
  }

  export type WorkItemEmbeddingNullableScalarRelationFilter = {
    is?: WorkItemEmbeddingWhereInput | null
    isNot?: WorkItemEmbeddingWhereInput | null
  }

  export type DependencyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TagOnWorkItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ComponentOnWorkItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkItemCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    storyPoints?: SortOrder
    estimatedHours?: SortOrder
    remainingHours?: SortOrder
    order?: SortOrder
    dueDate?: SortOrder
    completedAt?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrder
    epicId?: SortOrder
    projectId?: SortOrder
    stateId?: SortOrder
    assigneeId?: SortOrder
    creatorId?: SortOrder
    sprintId?: SortOrder
  }

  export type WorkItemAvgOrderByAggregateInput = {
    storyPoints?: SortOrder
    estimatedHours?: SortOrder
    remainingHours?: SortOrder
    order?: SortOrder
  }

  export type WorkItemMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    storyPoints?: SortOrder
    estimatedHours?: SortOrder
    remainingHours?: SortOrder
    order?: SortOrder
    dueDate?: SortOrder
    completedAt?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrder
    epicId?: SortOrder
    projectId?: SortOrder
    stateId?: SortOrder
    assigneeId?: SortOrder
    creatorId?: SortOrder
    sprintId?: SortOrder
  }

  export type WorkItemMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    storyPoints?: SortOrder
    estimatedHours?: SortOrder
    remainingHours?: SortOrder
    order?: SortOrder
    dueDate?: SortOrder
    completedAt?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrder
    epicId?: SortOrder
    projectId?: SortOrder
    stateId?: SortOrder
    assigneeId?: SortOrder
    creatorId?: SortOrder
    sprintId?: SortOrder
  }

  export type WorkItemSumOrderByAggregateInput = {
    storyPoints?: SortOrder
    estimatedHours?: SortOrder
    remainingHours?: SortOrder
    order?: SortOrder
  }

  export type EnumWorkItemTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkItemType | EnumWorkItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkItemType[] | ListEnumWorkItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkItemType[] | ListEnumWorkItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkItemTypeWithAggregatesFilter<$PrismaModel> | $Enums.WorkItemType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkItemTypeFilter<$PrismaModel>
    _max?: NestedEnumWorkItemTypeFilter<$PrismaModel>
  }

  export type EnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type WorkItemScalarRelationFilter = {
    is?: WorkItemWhereInput
    isNot?: WorkItemWhereInput
  }

  export type WorkItemDetailCountOrderByAggregateInput = {
    id?: SortOrder
    acceptanceCriteria?: SortOrder
    technicalNotes?: SortOrder
    reproSteps?: SortOrder
    businessValue?: SortOrder
    userPersona?: SortOrder
    customFields?: SortOrder
    externalReferences?: SortOrder
    workItemId?: SortOrder
  }

  export type WorkItemDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    acceptanceCriteria?: SortOrder
    technicalNotes?: SortOrder
    reproSteps?: SortOrder
    businessValue?: SortOrder
    userPersona?: SortOrder
    externalReferences?: SortOrder
    workItemId?: SortOrder
  }

  export type WorkItemDetailMinOrderByAggregateInput = {
    id?: SortOrder
    acceptanceCriteria?: SortOrder
    technicalNotes?: SortOrder
    reproSteps?: SortOrder
    businessValue?: SortOrder
    userPersona?: SortOrder
    externalReferences?: SortOrder
    workItemId?: SortOrder
  }

  export type EnumWorkItemStateCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkItemStateCategory | EnumWorkItemStateCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.WorkItemStateCategory[] | ListEnumWorkItemStateCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkItemStateCategory[] | ListEnumWorkItemStateCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkItemStateCategoryFilter<$PrismaModel> | $Enums.WorkItemStateCategory
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type WorkItemStateProjectIdNameCompoundUniqueInput = {
    projectId: string
    name: string
  }

  export type WorkItemStateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    position?: SortOrder
    wipLimit?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    isInitial?: SortOrder
    isFinal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type WorkItemStateAvgOrderByAggregateInput = {
    position?: SortOrder
    wipLimit?: SortOrder
  }

  export type WorkItemStateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    position?: SortOrder
    wipLimit?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    isInitial?: SortOrder
    isFinal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type WorkItemStateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    position?: SortOrder
    wipLimit?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    isInitial?: SortOrder
    isFinal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type WorkItemStateSumOrderByAggregateInput = {
    position?: SortOrder
    wipLimit?: SortOrder
  }

  export type EnumWorkItemStateCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkItemStateCategory | EnumWorkItemStateCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.WorkItemStateCategory[] | ListEnumWorkItemStateCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkItemStateCategory[] | ListEnumWorkItemStateCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkItemStateCategoryWithAggregatesFilter<$PrismaModel> | $Enums.WorkItemStateCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkItemStateCategoryFilter<$PrismaModel>
    _max?: NestedEnumWorkItemStateCategoryFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoardLaneListRelationFilter = {
    every?: BoardLaneWhereInput
    some?: BoardLaneWhereInput
    none?: BoardLaneWhereInput
  }

  export type BoardLaneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BoardCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    boardType?: SortOrder
    filterQuery?: SortOrder
    settings?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    sprintId?: SortOrder
  }

  export type BoardMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    boardType?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    sprintId?: SortOrder
  }

  export type BoardMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    boardType?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    sprintId?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type BoardScalarRelationFilter = {
    is?: BoardWhereInput
    isNot?: BoardWhereInput
  }

  export type BoardLaneCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    position?: SortOrder
    wipLimit?: SortOrder
    colorConfig?: SortOrder
    mappedStates?: SortOrder
    isCollapsed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    boardId?: SortOrder
  }

  export type BoardLaneAvgOrderByAggregateInput = {
    position?: SortOrder
    wipLimit?: SortOrder
  }

  export type BoardLaneMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    position?: SortOrder
    wipLimit?: SortOrder
    isCollapsed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    boardId?: SortOrder
  }

  export type BoardLaneMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    position?: SortOrder
    wipLimit?: SortOrder
    isCollapsed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    boardId?: SortOrder
  }

  export type BoardLaneSumOrderByAggregateInput = {
    position?: SortOrder
    wipLimit?: SortOrder
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type TagScalarRelationFilter = {
    is?: TagWhereInput
    isNot?: TagWhereInput
  }

  export type TagOnWorkItemWorkItemIdTagIdCompoundUniqueInput = {
    workItemId: string
    tagId: string
  }

  export type TagOnWorkItemCountOrderByAggregateInput = {
    workItemId?: SortOrder
    tagId?: SortOrder
  }

  export type TagOnWorkItemMaxOrderByAggregateInput = {
    workItemId?: SortOrder
    tagId?: SortOrder
  }

  export type TagOnWorkItemMinOrderByAggregateInput = {
    workItemId?: SortOrder
    tagId?: SortOrder
  }

  export type ComponentProjectIdNameCompoundUniqueInput = {
    projectId: string
    name: string
  }

  export type ComponentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type ComponentAvgOrderByAggregateInput = {
    position?: SortOrder
  }

  export type ComponentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type ComponentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type ComponentSumOrderByAggregateInput = {
    position?: SortOrder
  }

  export type ComponentScalarRelationFilter = {
    is?: ComponentWhereInput
    isNot?: ComponentWhereInput
  }

  export type ComponentOnWorkItemWorkItemIdComponentIdCompoundUniqueInput = {
    workItemId: string
    componentId: string
  }

  export type ComponentOnWorkItemCountOrderByAggregateInput = {
    workItemId?: SortOrder
    componentId?: SortOrder
    assignedAt?: SortOrder
  }

  export type ComponentOnWorkItemMaxOrderByAggregateInput = {
    workItemId?: SortOrder
    componentId?: SortOrder
    assignedAt?: SortOrder
  }

  export type ComponentOnWorkItemMinOrderByAggregateInput = {
    workItemId?: SortOrder
    componentId?: SortOrder
    assignedAt?: SortOrder
  }

  export type DependencySourceItemIdTargetItemIdCompoundUniqueInput = {
    sourceItemId: string
    targetItemId: string
  }

  export type DependencyCountOrderByAggregateInput = {
    id?: SortOrder
    dependencyType?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    sourceItemId?: SortOrder
    targetItemId?: SortOrder
  }

  export type DependencyMaxOrderByAggregateInput = {
    id?: SortOrder
    dependencyType?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    sourceItemId?: SortOrder
    targetItemId?: SortOrder
  }

  export type DependencyMinOrderByAggregateInput = {
    id?: SortOrder
    dependencyType?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    sourceItemId?: SortOrder
    targetItemId?: SortOrder
  }

  export type TimeLogCountOrderByAggregateInput = {
    id?: SortOrder
    duration?: SortOrder
    description?: SortOrder
    billable?: SortOrder
    logDate?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workItemId?: SortOrder
    userId?: SortOrder
    sprintId?: SortOrder
  }

  export type TimeLogAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type TimeLogMaxOrderByAggregateInput = {
    id?: SortOrder
    duration?: SortOrder
    description?: SortOrder
    billable?: SortOrder
    logDate?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workItemId?: SortOrder
    userId?: SortOrder
    sprintId?: SortOrder
  }

  export type TimeLogMinOrderByAggregateInput = {
    id?: SortOrder
    duration?: SortOrder
    description?: SortOrder
    billable?: SortOrder
    logDate?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workItemId?: SortOrder
    userId?: SortOrder
    sprintId?: SortOrder
  }

  export type TimeLogSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    body?: SortOrder
    sentimentScore?: SortOrder
    sentimentLabel?: SortOrder
    isInternal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workItemId?: SortOrder
    userId?: SortOrder
  }

  export type CommentAvgOrderByAggregateInput = {
    sentimentScore?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    body?: SortOrder
    sentimentScore?: SortOrder
    sentimentLabel?: SortOrder
    isInternal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workItemId?: SortOrder
    userId?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    body?: SortOrder
    sentimentScore?: SortOrder
    sentimentLabel?: SortOrder
    isInternal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workItemId?: SortOrder
    userId?: SortOrder
  }

  export type CommentSumOrderByAggregateInput = {
    sentimentScore?: SortOrder
  }

  export type AttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    fileName?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    storagePath?: SortOrder
    fileUrl?: SortOrder
    ocrContent?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    workItemId?: SortOrder
    uploadedBy?: SortOrder
  }

  export type AttachmentAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type AttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    fileName?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    storagePath?: SortOrder
    fileUrl?: SortOrder
    ocrContent?: SortOrder
    createdAt?: SortOrder
    workItemId?: SortOrder
    uploadedBy?: SortOrder
  }

  export type AttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    fileName?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    storagePath?: SortOrder
    fileUrl?: SortOrder
    ocrContent?: SortOrder
    createdAt?: SortOrder
    workItemId?: SortOrder
    uploadedBy?: SortOrder
  }

  export type AttachmentSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type WorkItemEmbeddingCountOrderByAggregateInput = {
    workItemId?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkItemEmbeddingAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type WorkItemEmbeddingMaxOrderByAggregateInput = {
    workItemId?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkItemEmbeddingMinOrderByAggregateInput = {
    workItemId?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkItemEmbeddingSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type WorkItemSnapshotCountOrderByAggregateInput = {
    id?: SortOrder
    stateId?: SortOrder
    pointsRemaining?: SortOrder
    hoursRemaining?: SortOrder
    hoursSpent?: SortOrder
    daysInCurrentState?: SortOrder
    blockerIds?: SortOrder
    snapshotDate?: SortOrder
    workItemId?: SortOrder
    sprintId?: SortOrder
  }

  export type WorkItemSnapshotAvgOrderByAggregateInput = {
    pointsRemaining?: SortOrder
    hoursRemaining?: SortOrder
    hoursSpent?: SortOrder
    daysInCurrentState?: SortOrder
  }

  export type WorkItemSnapshotMaxOrderByAggregateInput = {
    id?: SortOrder
    stateId?: SortOrder
    pointsRemaining?: SortOrder
    hoursRemaining?: SortOrder
    hoursSpent?: SortOrder
    daysInCurrentState?: SortOrder
    snapshotDate?: SortOrder
    workItemId?: SortOrder
    sprintId?: SortOrder
  }

  export type WorkItemSnapshotMinOrderByAggregateInput = {
    id?: SortOrder
    stateId?: SortOrder
    pointsRemaining?: SortOrder
    hoursRemaining?: SortOrder
    hoursSpent?: SortOrder
    daysInCurrentState?: SortOrder
    snapshotDate?: SortOrder
    workItemId?: SortOrder
    sprintId?: SortOrder
  }

  export type WorkItemSnapshotSumOrderByAggregateInput = {
    pointsRemaining?: SortOrder
    hoursRemaining?: SortOrder
    hoursSpent?: SortOrder
    daysInCurrentState?: SortOrder
  }

  export type TeamNullableScalarRelationFilter = {
    is?: TeamWhereInput | null
    isNot?: TeamWhereInput | null
  }

  export type UserSkillProfileCountOrderByAggregateInput = {
    id?: SortOrder
    skills?: SortOrder
    proficiencyScores?: SortOrder
    certifiedSkills?: SortOrder
    overallProficiency?: SortOrder
    lastUpdated?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
  }

  export type UserSkillProfileAvgOrderByAggregateInput = {
    overallProficiency?: SortOrder
  }

  export type UserSkillProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    overallProficiency?: SortOrder
    lastUpdated?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
  }

  export type UserSkillProfileMinOrderByAggregateInput = {
    id?: SortOrder
    overallProficiency?: SortOrder
    lastUpdated?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
  }

  export type UserSkillProfileSumOrderByAggregateInput = {
    overallProficiency?: SortOrder
  }

  export type WorkflowRuleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    trigger?: SortOrder
    action?: SortOrder
    conditions?: SortOrder
    isActive?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type WorkflowRuleAvgOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type WorkflowRuleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    trigger?: SortOrder
    isActive?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type WorkflowRuleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    trigger?: SortOrder
    isActive?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type WorkflowRuleSumOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    targetUrl?: SortOrder
    priorityScore?: SortOrder
    isRead?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
    userId?: SortOrder
  }

  export type NotificationAvgOrderByAggregateInput = {
    priorityScore?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    targetUrl?: SortOrder
    priorityScore?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
    userId?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    targetUrl?: SortOrder
    priorityScore?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
    userId?: SortOrder
  }

  export type NotificationSumOrderByAggregateInput = {
    priorityScore?: SortOrder
  }

  export type ActivityLogCountOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    actorId?: SortOrder
    changeDiff?: SortOrder
    context?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityLogMaxOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    actorId?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityLogMinOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    actorId?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type OrganizationMembershipCreateNestedManyWithoutUserInput = {
    create?: XOR<OrganizationMembershipCreateWithoutUserInput, OrganizationMembershipUncheckedCreateWithoutUserInput> | OrganizationMembershipCreateWithoutUserInput[] | OrganizationMembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrganizationMembershipCreateOrConnectWithoutUserInput | OrganizationMembershipCreateOrConnectWithoutUserInput[]
    createMany?: OrganizationMembershipCreateManyUserInputEnvelope
    connect?: OrganizationMembershipWhereUniqueInput | OrganizationMembershipWhereUniqueInput[]
  }

  export type TeamMembershipCreateNestedManyWithoutUserInput = {
    create?: XOR<TeamMembershipCreateWithoutUserInput, TeamMembershipUncheckedCreateWithoutUserInput> | TeamMembershipCreateWithoutUserInput[] | TeamMembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMembershipCreateOrConnectWithoutUserInput | TeamMembershipCreateOrConnectWithoutUserInput[]
    createMany?: TeamMembershipCreateManyUserInputEnvelope
    connect?: TeamMembershipWhereUniqueInput | TeamMembershipWhereUniqueInput[]
  }

  export type ProjectCreateNestedManyWithoutLeadUserInput = {
    create?: XOR<ProjectCreateWithoutLeadUserInput, ProjectUncheckedCreateWithoutLeadUserInput> | ProjectCreateWithoutLeadUserInput[] | ProjectUncheckedCreateWithoutLeadUserInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutLeadUserInput | ProjectCreateOrConnectWithoutLeadUserInput[]
    createMany?: ProjectCreateManyLeadUserInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type WorkItemCreateNestedManyWithoutAssigneeInput = {
    create?: XOR<WorkItemCreateWithoutAssigneeInput, WorkItemUncheckedCreateWithoutAssigneeInput> | WorkItemCreateWithoutAssigneeInput[] | WorkItemUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: WorkItemCreateOrConnectWithoutAssigneeInput | WorkItemCreateOrConnectWithoutAssigneeInput[]
    createMany?: WorkItemCreateManyAssigneeInputEnvelope
    connect?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
  }

  export type WorkItemCreateNestedManyWithoutCreatorInput = {
    create?: XOR<WorkItemCreateWithoutCreatorInput, WorkItemUncheckedCreateWithoutCreatorInput> | WorkItemCreateWithoutCreatorInput[] | WorkItemUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: WorkItemCreateOrConnectWithoutCreatorInput | WorkItemCreateOrConnectWithoutCreatorInput[]
    createMany?: WorkItemCreateManyCreatorInputEnvelope
    connect?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type TimeLogCreateNestedManyWithoutUserInput = {
    create?: XOR<TimeLogCreateWithoutUserInput, TimeLogUncheckedCreateWithoutUserInput> | TimeLogCreateWithoutUserInput[] | TimeLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TimeLogCreateOrConnectWithoutUserInput | TimeLogCreateOrConnectWithoutUserInput[]
    createMany?: TimeLogCreateManyUserInputEnvelope
    connect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type UserSkillProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<UserSkillProfileCreateWithoutUserInput, UserSkillProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSkillProfileCreateOrConnectWithoutUserInput
    connect?: UserSkillProfileWhereUniqueInput
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type OrganizationMembershipUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OrganizationMembershipCreateWithoutUserInput, OrganizationMembershipUncheckedCreateWithoutUserInput> | OrganizationMembershipCreateWithoutUserInput[] | OrganizationMembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrganizationMembershipCreateOrConnectWithoutUserInput | OrganizationMembershipCreateOrConnectWithoutUserInput[]
    createMany?: OrganizationMembershipCreateManyUserInputEnvelope
    connect?: OrganizationMembershipWhereUniqueInput | OrganizationMembershipWhereUniqueInput[]
  }

  export type TeamMembershipUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TeamMembershipCreateWithoutUserInput, TeamMembershipUncheckedCreateWithoutUserInput> | TeamMembershipCreateWithoutUserInput[] | TeamMembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMembershipCreateOrConnectWithoutUserInput | TeamMembershipCreateOrConnectWithoutUserInput[]
    createMany?: TeamMembershipCreateManyUserInputEnvelope
    connect?: TeamMembershipWhereUniqueInput | TeamMembershipWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutLeadUserInput = {
    create?: XOR<ProjectCreateWithoutLeadUserInput, ProjectUncheckedCreateWithoutLeadUserInput> | ProjectCreateWithoutLeadUserInput[] | ProjectUncheckedCreateWithoutLeadUserInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutLeadUserInput | ProjectCreateOrConnectWithoutLeadUserInput[]
    createMany?: ProjectCreateManyLeadUserInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type WorkItemUncheckedCreateNestedManyWithoutAssigneeInput = {
    create?: XOR<WorkItemCreateWithoutAssigneeInput, WorkItemUncheckedCreateWithoutAssigneeInput> | WorkItemCreateWithoutAssigneeInput[] | WorkItemUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: WorkItemCreateOrConnectWithoutAssigneeInput | WorkItemCreateOrConnectWithoutAssigneeInput[]
    createMany?: WorkItemCreateManyAssigneeInputEnvelope
    connect?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
  }

  export type WorkItemUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<WorkItemCreateWithoutCreatorInput, WorkItemUncheckedCreateWithoutCreatorInput> | WorkItemCreateWithoutCreatorInput[] | WorkItemUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: WorkItemCreateOrConnectWithoutCreatorInput | WorkItemCreateOrConnectWithoutCreatorInput[]
    createMany?: WorkItemCreateManyCreatorInputEnvelope
    connect?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type TimeLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TimeLogCreateWithoutUserInput, TimeLogUncheckedCreateWithoutUserInput> | TimeLogCreateWithoutUserInput[] | TimeLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TimeLogCreateOrConnectWithoutUserInput | TimeLogCreateOrConnectWithoutUserInput[]
    createMany?: TimeLogCreateManyUserInputEnvelope
    connect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type UserSkillProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserSkillProfileCreateWithoutUserInput, UserSkillProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSkillProfileCreateOrConnectWithoutUserInput
    connect?: UserSkillProfileWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type OrganizationMembershipUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrganizationMembershipCreateWithoutUserInput, OrganizationMembershipUncheckedCreateWithoutUserInput> | OrganizationMembershipCreateWithoutUserInput[] | OrganizationMembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrganizationMembershipCreateOrConnectWithoutUserInput | OrganizationMembershipCreateOrConnectWithoutUserInput[]
    upsert?: OrganizationMembershipUpsertWithWhereUniqueWithoutUserInput | OrganizationMembershipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrganizationMembershipCreateManyUserInputEnvelope
    set?: OrganizationMembershipWhereUniqueInput | OrganizationMembershipWhereUniqueInput[]
    disconnect?: OrganizationMembershipWhereUniqueInput | OrganizationMembershipWhereUniqueInput[]
    delete?: OrganizationMembershipWhereUniqueInput | OrganizationMembershipWhereUniqueInput[]
    connect?: OrganizationMembershipWhereUniqueInput | OrganizationMembershipWhereUniqueInput[]
    update?: OrganizationMembershipUpdateWithWhereUniqueWithoutUserInput | OrganizationMembershipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrganizationMembershipUpdateManyWithWhereWithoutUserInput | OrganizationMembershipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrganizationMembershipScalarWhereInput | OrganizationMembershipScalarWhereInput[]
  }

  export type TeamMembershipUpdateManyWithoutUserNestedInput = {
    create?: XOR<TeamMembershipCreateWithoutUserInput, TeamMembershipUncheckedCreateWithoutUserInput> | TeamMembershipCreateWithoutUserInput[] | TeamMembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMembershipCreateOrConnectWithoutUserInput | TeamMembershipCreateOrConnectWithoutUserInput[]
    upsert?: TeamMembershipUpsertWithWhereUniqueWithoutUserInput | TeamMembershipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TeamMembershipCreateManyUserInputEnvelope
    set?: TeamMembershipWhereUniqueInput | TeamMembershipWhereUniqueInput[]
    disconnect?: TeamMembershipWhereUniqueInput | TeamMembershipWhereUniqueInput[]
    delete?: TeamMembershipWhereUniqueInput | TeamMembershipWhereUniqueInput[]
    connect?: TeamMembershipWhereUniqueInput | TeamMembershipWhereUniqueInput[]
    update?: TeamMembershipUpdateWithWhereUniqueWithoutUserInput | TeamMembershipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TeamMembershipUpdateManyWithWhereWithoutUserInput | TeamMembershipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TeamMembershipScalarWhereInput | TeamMembershipScalarWhereInput[]
  }

  export type ProjectUpdateManyWithoutLeadUserNestedInput = {
    create?: XOR<ProjectCreateWithoutLeadUserInput, ProjectUncheckedCreateWithoutLeadUserInput> | ProjectCreateWithoutLeadUserInput[] | ProjectUncheckedCreateWithoutLeadUserInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutLeadUserInput | ProjectCreateOrConnectWithoutLeadUserInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutLeadUserInput | ProjectUpsertWithWhereUniqueWithoutLeadUserInput[]
    createMany?: ProjectCreateManyLeadUserInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutLeadUserInput | ProjectUpdateWithWhereUniqueWithoutLeadUserInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutLeadUserInput | ProjectUpdateManyWithWhereWithoutLeadUserInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type WorkItemUpdateManyWithoutAssigneeNestedInput = {
    create?: XOR<WorkItemCreateWithoutAssigneeInput, WorkItemUncheckedCreateWithoutAssigneeInput> | WorkItemCreateWithoutAssigneeInput[] | WorkItemUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: WorkItemCreateOrConnectWithoutAssigneeInput | WorkItemCreateOrConnectWithoutAssigneeInput[]
    upsert?: WorkItemUpsertWithWhereUniqueWithoutAssigneeInput | WorkItemUpsertWithWhereUniqueWithoutAssigneeInput[]
    createMany?: WorkItemCreateManyAssigneeInputEnvelope
    set?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    disconnect?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    delete?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    connect?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    update?: WorkItemUpdateWithWhereUniqueWithoutAssigneeInput | WorkItemUpdateWithWhereUniqueWithoutAssigneeInput[]
    updateMany?: WorkItemUpdateManyWithWhereWithoutAssigneeInput | WorkItemUpdateManyWithWhereWithoutAssigneeInput[]
    deleteMany?: WorkItemScalarWhereInput | WorkItemScalarWhereInput[]
  }

  export type WorkItemUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<WorkItemCreateWithoutCreatorInput, WorkItemUncheckedCreateWithoutCreatorInput> | WorkItemCreateWithoutCreatorInput[] | WorkItemUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: WorkItemCreateOrConnectWithoutCreatorInput | WorkItemCreateOrConnectWithoutCreatorInput[]
    upsert?: WorkItemUpsertWithWhereUniqueWithoutCreatorInput | WorkItemUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: WorkItemCreateManyCreatorInputEnvelope
    set?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    disconnect?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    delete?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    connect?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    update?: WorkItemUpdateWithWhereUniqueWithoutCreatorInput | WorkItemUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: WorkItemUpdateManyWithWhereWithoutCreatorInput | WorkItemUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: WorkItemScalarWhereInput | WorkItemScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type TimeLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<TimeLogCreateWithoutUserInput, TimeLogUncheckedCreateWithoutUserInput> | TimeLogCreateWithoutUserInput[] | TimeLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TimeLogCreateOrConnectWithoutUserInput | TimeLogCreateOrConnectWithoutUserInput[]
    upsert?: TimeLogUpsertWithWhereUniqueWithoutUserInput | TimeLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TimeLogCreateManyUserInputEnvelope
    set?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    disconnect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    delete?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    connect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    update?: TimeLogUpdateWithWhereUniqueWithoutUserInput | TimeLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TimeLogUpdateManyWithWhereWithoutUserInput | TimeLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TimeLogScalarWhereInput | TimeLogScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UserSkillProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserSkillProfileCreateWithoutUserInput, UserSkillProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSkillProfileCreateOrConnectWithoutUserInput
    upsert?: UserSkillProfileUpsertWithoutUserInput
    disconnect?: UserSkillProfileWhereInput | boolean
    delete?: UserSkillProfileWhereInput | boolean
    connect?: UserSkillProfileWhereUniqueInput
    update?: XOR<XOR<UserSkillProfileUpdateToOneWithWhereWithoutUserInput, UserSkillProfileUpdateWithoutUserInput>, UserSkillProfileUncheckedUpdateWithoutUserInput>
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type OrganizationMembershipUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrganizationMembershipCreateWithoutUserInput, OrganizationMembershipUncheckedCreateWithoutUserInput> | OrganizationMembershipCreateWithoutUserInput[] | OrganizationMembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrganizationMembershipCreateOrConnectWithoutUserInput | OrganizationMembershipCreateOrConnectWithoutUserInput[]
    upsert?: OrganizationMembershipUpsertWithWhereUniqueWithoutUserInput | OrganizationMembershipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrganizationMembershipCreateManyUserInputEnvelope
    set?: OrganizationMembershipWhereUniqueInput | OrganizationMembershipWhereUniqueInput[]
    disconnect?: OrganizationMembershipWhereUniqueInput | OrganizationMembershipWhereUniqueInput[]
    delete?: OrganizationMembershipWhereUniqueInput | OrganizationMembershipWhereUniqueInput[]
    connect?: OrganizationMembershipWhereUniqueInput | OrganizationMembershipWhereUniqueInput[]
    update?: OrganizationMembershipUpdateWithWhereUniqueWithoutUserInput | OrganizationMembershipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrganizationMembershipUpdateManyWithWhereWithoutUserInput | OrganizationMembershipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrganizationMembershipScalarWhereInput | OrganizationMembershipScalarWhereInput[]
  }

  export type TeamMembershipUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TeamMembershipCreateWithoutUserInput, TeamMembershipUncheckedCreateWithoutUserInput> | TeamMembershipCreateWithoutUserInput[] | TeamMembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMembershipCreateOrConnectWithoutUserInput | TeamMembershipCreateOrConnectWithoutUserInput[]
    upsert?: TeamMembershipUpsertWithWhereUniqueWithoutUserInput | TeamMembershipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TeamMembershipCreateManyUserInputEnvelope
    set?: TeamMembershipWhereUniqueInput | TeamMembershipWhereUniqueInput[]
    disconnect?: TeamMembershipWhereUniqueInput | TeamMembershipWhereUniqueInput[]
    delete?: TeamMembershipWhereUniqueInput | TeamMembershipWhereUniqueInput[]
    connect?: TeamMembershipWhereUniqueInput | TeamMembershipWhereUniqueInput[]
    update?: TeamMembershipUpdateWithWhereUniqueWithoutUserInput | TeamMembershipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TeamMembershipUpdateManyWithWhereWithoutUserInput | TeamMembershipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TeamMembershipScalarWhereInput | TeamMembershipScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutLeadUserNestedInput = {
    create?: XOR<ProjectCreateWithoutLeadUserInput, ProjectUncheckedCreateWithoutLeadUserInput> | ProjectCreateWithoutLeadUserInput[] | ProjectUncheckedCreateWithoutLeadUserInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutLeadUserInput | ProjectCreateOrConnectWithoutLeadUserInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutLeadUserInput | ProjectUpsertWithWhereUniqueWithoutLeadUserInput[]
    createMany?: ProjectCreateManyLeadUserInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutLeadUserInput | ProjectUpdateWithWhereUniqueWithoutLeadUserInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutLeadUserInput | ProjectUpdateManyWithWhereWithoutLeadUserInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type WorkItemUncheckedUpdateManyWithoutAssigneeNestedInput = {
    create?: XOR<WorkItemCreateWithoutAssigneeInput, WorkItemUncheckedCreateWithoutAssigneeInput> | WorkItemCreateWithoutAssigneeInput[] | WorkItemUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: WorkItemCreateOrConnectWithoutAssigneeInput | WorkItemCreateOrConnectWithoutAssigneeInput[]
    upsert?: WorkItemUpsertWithWhereUniqueWithoutAssigneeInput | WorkItemUpsertWithWhereUniqueWithoutAssigneeInput[]
    createMany?: WorkItemCreateManyAssigneeInputEnvelope
    set?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    disconnect?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    delete?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    connect?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    update?: WorkItemUpdateWithWhereUniqueWithoutAssigneeInput | WorkItemUpdateWithWhereUniqueWithoutAssigneeInput[]
    updateMany?: WorkItemUpdateManyWithWhereWithoutAssigneeInput | WorkItemUpdateManyWithWhereWithoutAssigneeInput[]
    deleteMany?: WorkItemScalarWhereInput | WorkItemScalarWhereInput[]
  }

  export type WorkItemUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<WorkItemCreateWithoutCreatorInput, WorkItemUncheckedCreateWithoutCreatorInput> | WorkItemCreateWithoutCreatorInput[] | WorkItemUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: WorkItemCreateOrConnectWithoutCreatorInput | WorkItemCreateOrConnectWithoutCreatorInput[]
    upsert?: WorkItemUpsertWithWhereUniqueWithoutCreatorInput | WorkItemUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: WorkItemCreateManyCreatorInputEnvelope
    set?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    disconnect?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    delete?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    connect?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    update?: WorkItemUpdateWithWhereUniqueWithoutCreatorInput | WorkItemUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: WorkItemUpdateManyWithWhereWithoutCreatorInput | WorkItemUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: WorkItemScalarWhereInput | WorkItemScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type TimeLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TimeLogCreateWithoutUserInput, TimeLogUncheckedCreateWithoutUserInput> | TimeLogCreateWithoutUserInput[] | TimeLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TimeLogCreateOrConnectWithoutUserInput | TimeLogCreateOrConnectWithoutUserInput[]
    upsert?: TimeLogUpsertWithWhereUniqueWithoutUserInput | TimeLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TimeLogCreateManyUserInputEnvelope
    set?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    disconnect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    delete?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    connect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    update?: TimeLogUpdateWithWhereUniqueWithoutUserInput | TimeLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TimeLogUpdateManyWithWhereWithoutUserInput | TimeLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TimeLogScalarWhereInput | TimeLogScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UserSkillProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserSkillProfileCreateWithoutUserInput, UserSkillProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSkillProfileCreateOrConnectWithoutUserInput
    upsert?: UserSkillProfileUpsertWithoutUserInput
    disconnect?: UserSkillProfileWhereInput | boolean
    delete?: UserSkillProfileWhereInput | boolean
    connect?: UserSkillProfileWhereUniqueInput
    update?: XOR<XOR<UserSkillProfileUpdateToOneWithWhereWithoutUserInput, UserSkillProfileUpdateWithoutUserInput>, UserSkillProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type OrganizationMembershipCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<OrganizationMembershipCreateWithoutOrganizationInput, OrganizationMembershipUncheckedCreateWithoutOrganizationInput> | OrganizationMembershipCreateWithoutOrganizationInput[] | OrganizationMembershipUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationMembershipCreateOrConnectWithoutOrganizationInput | OrganizationMembershipCreateOrConnectWithoutOrganizationInput[]
    createMany?: OrganizationMembershipCreateManyOrganizationInputEnvelope
    connect?: OrganizationMembershipWhereUniqueInput | OrganizationMembershipWhereUniqueInput[]
  }

  export type PortfolioCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<PortfolioCreateWithoutOrganizationInput, PortfolioUncheckedCreateWithoutOrganizationInput> | PortfolioCreateWithoutOrganizationInput[] | PortfolioUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: PortfolioCreateOrConnectWithoutOrganizationInput | PortfolioCreateOrConnectWithoutOrganizationInput[]
    createMany?: PortfolioCreateManyOrganizationInputEnvelope
    connect?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
  }

  export type TeamCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<TeamCreateWithoutOrganizationInput, TeamUncheckedCreateWithoutOrganizationInput> | TeamCreateWithoutOrganizationInput[] | TeamUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutOrganizationInput | TeamCreateOrConnectWithoutOrganizationInput[]
    createMany?: TeamCreateManyOrganizationInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type ProjectCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ProjectCreateWithoutOrganizationInput, ProjectUncheckedCreateWithoutOrganizationInput> | ProjectCreateWithoutOrganizationInput[] | ProjectUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutOrganizationInput | ProjectCreateOrConnectWithoutOrganizationInput[]
    createMany?: ProjectCreateManyOrganizationInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type OrganizationMembershipUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<OrganizationMembershipCreateWithoutOrganizationInput, OrganizationMembershipUncheckedCreateWithoutOrganizationInput> | OrganizationMembershipCreateWithoutOrganizationInput[] | OrganizationMembershipUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationMembershipCreateOrConnectWithoutOrganizationInput | OrganizationMembershipCreateOrConnectWithoutOrganizationInput[]
    createMany?: OrganizationMembershipCreateManyOrganizationInputEnvelope
    connect?: OrganizationMembershipWhereUniqueInput | OrganizationMembershipWhereUniqueInput[]
  }

  export type PortfolioUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<PortfolioCreateWithoutOrganizationInput, PortfolioUncheckedCreateWithoutOrganizationInput> | PortfolioCreateWithoutOrganizationInput[] | PortfolioUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: PortfolioCreateOrConnectWithoutOrganizationInput | PortfolioCreateOrConnectWithoutOrganizationInput[]
    createMany?: PortfolioCreateManyOrganizationInputEnvelope
    connect?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
  }

  export type TeamUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<TeamCreateWithoutOrganizationInput, TeamUncheckedCreateWithoutOrganizationInput> | TeamCreateWithoutOrganizationInput[] | TeamUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutOrganizationInput | TeamCreateOrConnectWithoutOrganizationInput[]
    createMany?: TeamCreateManyOrganizationInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ProjectCreateWithoutOrganizationInput, ProjectUncheckedCreateWithoutOrganizationInput> | ProjectCreateWithoutOrganizationInput[] | ProjectUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutOrganizationInput | ProjectCreateOrConnectWithoutOrganizationInput[]
    createMany?: ProjectCreateManyOrganizationInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type OrganizationMembershipUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<OrganizationMembershipCreateWithoutOrganizationInput, OrganizationMembershipUncheckedCreateWithoutOrganizationInput> | OrganizationMembershipCreateWithoutOrganizationInput[] | OrganizationMembershipUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationMembershipCreateOrConnectWithoutOrganizationInput | OrganizationMembershipCreateOrConnectWithoutOrganizationInput[]
    upsert?: OrganizationMembershipUpsertWithWhereUniqueWithoutOrganizationInput | OrganizationMembershipUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: OrganizationMembershipCreateManyOrganizationInputEnvelope
    set?: OrganizationMembershipWhereUniqueInput | OrganizationMembershipWhereUniqueInput[]
    disconnect?: OrganizationMembershipWhereUniqueInput | OrganizationMembershipWhereUniqueInput[]
    delete?: OrganizationMembershipWhereUniqueInput | OrganizationMembershipWhereUniqueInput[]
    connect?: OrganizationMembershipWhereUniqueInput | OrganizationMembershipWhereUniqueInput[]
    update?: OrganizationMembershipUpdateWithWhereUniqueWithoutOrganizationInput | OrganizationMembershipUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: OrganizationMembershipUpdateManyWithWhereWithoutOrganizationInput | OrganizationMembershipUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: OrganizationMembershipScalarWhereInput | OrganizationMembershipScalarWhereInput[]
  }

  export type PortfolioUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<PortfolioCreateWithoutOrganizationInput, PortfolioUncheckedCreateWithoutOrganizationInput> | PortfolioCreateWithoutOrganizationInput[] | PortfolioUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: PortfolioCreateOrConnectWithoutOrganizationInput | PortfolioCreateOrConnectWithoutOrganizationInput[]
    upsert?: PortfolioUpsertWithWhereUniqueWithoutOrganizationInput | PortfolioUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: PortfolioCreateManyOrganizationInputEnvelope
    set?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    disconnect?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    delete?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    connect?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    update?: PortfolioUpdateWithWhereUniqueWithoutOrganizationInput | PortfolioUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: PortfolioUpdateManyWithWhereWithoutOrganizationInput | PortfolioUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: PortfolioScalarWhereInput | PortfolioScalarWhereInput[]
  }

  export type TeamUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<TeamCreateWithoutOrganizationInput, TeamUncheckedCreateWithoutOrganizationInput> | TeamCreateWithoutOrganizationInput[] | TeamUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutOrganizationInput | TeamCreateOrConnectWithoutOrganizationInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutOrganizationInput | TeamUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: TeamCreateManyOrganizationInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutOrganizationInput | TeamUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutOrganizationInput | TeamUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type ProjectUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ProjectCreateWithoutOrganizationInput, ProjectUncheckedCreateWithoutOrganizationInput> | ProjectCreateWithoutOrganizationInput[] | ProjectUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutOrganizationInput | ProjectCreateOrConnectWithoutOrganizationInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutOrganizationInput | ProjectUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ProjectCreateManyOrganizationInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutOrganizationInput | ProjectUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutOrganizationInput | ProjectUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type OrganizationMembershipUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<OrganizationMembershipCreateWithoutOrganizationInput, OrganizationMembershipUncheckedCreateWithoutOrganizationInput> | OrganizationMembershipCreateWithoutOrganizationInput[] | OrganizationMembershipUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationMembershipCreateOrConnectWithoutOrganizationInput | OrganizationMembershipCreateOrConnectWithoutOrganizationInput[]
    upsert?: OrganizationMembershipUpsertWithWhereUniqueWithoutOrganizationInput | OrganizationMembershipUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: OrganizationMembershipCreateManyOrganizationInputEnvelope
    set?: OrganizationMembershipWhereUniqueInput | OrganizationMembershipWhereUniqueInput[]
    disconnect?: OrganizationMembershipWhereUniqueInput | OrganizationMembershipWhereUniqueInput[]
    delete?: OrganizationMembershipWhereUniqueInput | OrganizationMembershipWhereUniqueInput[]
    connect?: OrganizationMembershipWhereUniqueInput | OrganizationMembershipWhereUniqueInput[]
    update?: OrganizationMembershipUpdateWithWhereUniqueWithoutOrganizationInput | OrganizationMembershipUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: OrganizationMembershipUpdateManyWithWhereWithoutOrganizationInput | OrganizationMembershipUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: OrganizationMembershipScalarWhereInput | OrganizationMembershipScalarWhereInput[]
  }

  export type PortfolioUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<PortfolioCreateWithoutOrganizationInput, PortfolioUncheckedCreateWithoutOrganizationInput> | PortfolioCreateWithoutOrganizationInput[] | PortfolioUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: PortfolioCreateOrConnectWithoutOrganizationInput | PortfolioCreateOrConnectWithoutOrganizationInput[]
    upsert?: PortfolioUpsertWithWhereUniqueWithoutOrganizationInput | PortfolioUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: PortfolioCreateManyOrganizationInputEnvelope
    set?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    disconnect?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    delete?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    connect?: PortfolioWhereUniqueInput | PortfolioWhereUniqueInput[]
    update?: PortfolioUpdateWithWhereUniqueWithoutOrganizationInput | PortfolioUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: PortfolioUpdateManyWithWhereWithoutOrganizationInput | PortfolioUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: PortfolioScalarWhereInput | PortfolioScalarWhereInput[]
  }

  export type TeamUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<TeamCreateWithoutOrganizationInput, TeamUncheckedCreateWithoutOrganizationInput> | TeamCreateWithoutOrganizationInput[] | TeamUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutOrganizationInput | TeamCreateOrConnectWithoutOrganizationInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutOrganizationInput | TeamUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: TeamCreateManyOrganizationInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutOrganizationInput | TeamUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutOrganizationInput | TeamUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ProjectCreateWithoutOrganizationInput, ProjectUncheckedCreateWithoutOrganizationInput> | ProjectCreateWithoutOrganizationInput[] | ProjectUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutOrganizationInput | ProjectCreateOrConnectWithoutOrganizationInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutOrganizationInput | ProjectUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ProjectCreateManyOrganizationInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutOrganizationInput | ProjectUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutOrganizationInput | ProjectUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type OrganizationCreateNestedOneWithoutTeamsInput = {
    create?: XOR<OrganizationCreateWithoutTeamsInput, OrganizationUncheckedCreateWithoutTeamsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutTeamsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type TeamMembershipCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamMembershipCreateWithoutTeamInput, TeamMembershipUncheckedCreateWithoutTeamInput> | TeamMembershipCreateWithoutTeamInput[] | TeamMembershipUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMembershipCreateOrConnectWithoutTeamInput | TeamMembershipCreateOrConnectWithoutTeamInput[]
    createMany?: TeamMembershipCreateManyTeamInputEnvelope
    connect?: TeamMembershipWhereUniqueInput | TeamMembershipWhereUniqueInput[]
  }

  export type ProjectCreateNestedManyWithoutTeamsInput = {
    create?: XOR<ProjectCreateWithoutTeamsInput, ProjectUncheckedCreateWithoutTeamsInput> | ProjectCreateWithoutTeamsInput[] | ProjectUncheckedCreateWithoutTeamsInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutTeamsInput | ProjectCreateOrConnectWithoutTeamsInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type UserSkillProfileCreateNestedManyWithoutTeamInput = {
    create?: XOR<UserSkillProfileCreateWithoutTeamInput, UserSkillProfileUncheckedCreateWithoutTeamInput> | UserSkillProfileCreateWithoutTeamInput[] | UserSkillProfileUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: UserSkillProfileCreateOrConnectWithoutTeamInput | UserSkillProfileCreateOrConnectWithoutTeamInput[]
    createMany?: UserSkillProfileCreateManyTeamInputEnvelope
    connect?: UserSkillProfileWhereUniqueInput | UserSkillProfileWhereUniqueInput[]
  }

  export type TeamMembershipUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamMembershipCreateWithoutTeamInput, TeamMembershipUncheckedCreateWithoutTeamInput> | TeamMembershipCreateWithoutTeamInput[] | TeamMembershipUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMembershipCreateOrConnectWithoutTeamInput | TeamMembershipCreateOrConnectWithoutTeamInput[]
    createMany?: TeamMembershipCreateManyTeamInputEnvelope
    connect?: TeamMembershipWhereUniqueInput | TeamMembershipWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutTeamsInput = {
    create?: XOR<ProjectCreateWithoutTeamsInput, ProjectUncheckedCreateWithoutTeamsInput> | ProjectCreateWithoutTeamsInput[] | ProjectUncheckedCreateWithoutTeamsInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutTeamsInput | ProjectCreateOrConnectWithoutTeamsInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type UserSkillProfileUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<UserSkillProfileCreateWithoutTeamInput, UserSkillProfileUncheckedCreateWithoutTeamInput> | UserSkillProfileCreateWithoutTeamInput[] | UserSkillProfileUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: UserSkillProfileCreateOrConnectWithoutTeamInput | UserSkillProfileCreateOrConnectWithoutTeamInput[]
    createMany?: UserSkillProfileCreateManyTeamInputEnvelope
    connect?: UserSkillProfileWhereUniqueInput | UserSkillProfileWhereUniqueInput[]
  }

  export type OrganizationUpdateOneRequiredWithoutTeamsNestedInput = {
    create?: XOR<OrganizationCreateWithoutTeamsInput, OrganizationUncheckedCreateWithoutTeamsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutTeamsInput
    upsert?: OrganizationUpsertWithoutTeamsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutTeamsInput, OrganizationUpdateWithoutTeamsInput>, OrganizationUncheckedUpdateWithoutTeamsInput>
  }

  export type TeamMembershipUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamMembershipCreateWithoutTeamInput, TeamMembershipUncheckedCreateWithoutTeamInput> | TeamMembershipCreateWithoutTeamInput[] | TeamMembershipUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMembershipCreateOrConnectWithoutTeamInput | TeamMembershipCreateOrConnectWithoutTeamInput[]
    upsert?: TeamMembershipUpsertWithWhereUniqueWithoutTeamInput | TeamMembershipUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamMembershipCreateManyTeamInputEnvelope
    set?: TeamMembershipWhereUniqueInput | TeamMembershipWhereUniqueInput[]
    disconnect?: TeamMembershipWhereUniqueInput | TeamMembershipWhereUniqueInput[]
    delete?: TeamMembershipWhereUniqueInput | TeamMembershipWhereUniqueInput[]
    connect?: TeamMembershipWhereUniqueInput | TeamMembershipWhereUniqueInput[]
    update?: TeamMembershipUpdateWithWhereUniqueWithoutTeamInput | TeamMembershipUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamMembershipUpdateManyWithWhereWithoutTeamInput | TeamMembershipUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamMembershipScalarWhereInput | TeamMembershipScalarWhereInput[]
  }

  export type ProjectUpdateManyWithoutTeamsNestedInput = {
    create?: XOR<ProjectCreateWithoutTeamsInput, ProjectUncheckedCreateWithoutTeamsInput> | ProjectCreateWithoutTeamsInput[] | ProjectUncheckedCreateWithoutTeamsInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutTeamsInput | ProjectCreateOrConnectWithoutTeamsInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutTeamsInput | ProjectUpsertWithWhereUniqueWithoutTeamsInput[]
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutTeamsInput | ProjectUpdateWithWhereUniqueWithoutTeamsInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutTeamsInput | ProjectUpdateManyWithWhereWithoutTeamsInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type UserSkillProfileUpdateManyWithoutTeamNestedInput = {
    create?: XOR<UserSkillProfileCreateWithoutTeamInput, UserSkillProfileUncheckedCreateWithoutTeamInput> | UserSkillProfileCreateWithoutTeamInput[] | UserSkillProfileUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: UserSkillProfileCreateOrConnectWithoutTeamInput | UserSkillProfileCreateOrConnectWithoutTeamInput[]
    upsert?: UserSkillProfileUpsertWithWhereUniqueWithoutTeamInput | UserSkillProfileUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: UserSkillProfileCreateManyTeamInputEnvelope
    set?: UserSkillProfileWhereUniqueInput | UserSkillProfileWhereUniqueInput[]
    disconnect?: UserSkillProfileWhereUniqueInput | UserSkillProfileWhereUniqueInput[]
    delete?: UserSkillProfileWhereUniqueInput | UserSkillProfileWhereUniqueInput[]
    connect?: UserSkillProfileWhereUniqueInput | UserSkillProfileWhereUniqueInput[]
    update?: UserSkillProfileUpdateWithWhereUniqueWithoutTeamInput | UserSkillProfileUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: UserSkillProfileUpdateManyWithWhereWithoutTeamInput | UserSkillProfileUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: UserSkillProfileScalarWhereInput | UserSkillProfileScalarWhereInput[]
  }

  export type TeamMembershipUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamMembershipCreateWithoutTeamInput, TeamMembershipUncheckedCreateWithoutTeamInput> | TeamMembershipCreateWithoutTeamInput[] | TeamMembershipUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMembershipCreateOrConnectWithoutTeamInput | TeamMembershipCreateOrConnectWithoutTeamInput[]
    upsert?: TeamMembershipUpsertWithWhereUniqueWithoutTeamInput | TeamMembershipUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamMembershipCreateManyTeamInputEnvelope
    set?: TeamMembershipWhereUniqueInput | TeamMembershipWhereUniqueInput[]
    disconnect?: TeamMembershipWhereUniqueInput | TeamMembershipWhereUniqueInput[]
    delete?: TeamMembershipWhereUniqueInput | TeamMembershipWhereUniqueInput[]
    connect?: TeamMembershipWhereUniqueInput | TeamMembershipWhereUniqueInput[]
    update?: TeamMembershipUpdateWithWhereUniqueWithoutTeamInput | TeamMembershipUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamMembershipUpdateManyWithWhereWithoutTeamInput | TeamMembershipUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamMembershipScalarWhereInput | TeamMembershipScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutTeamsNestedInput = {
    create?: XOR<ProjectCreateWithoutTeamsInput, ProjectUncheckedCreateWithoutTeamsInput> | ProjectCreateWithoutTeamsInput[] | ProjectUncheckedCreateWithoutTeamsInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutTeamsInput | ProjectCreateOrConnectWithoutTeamsInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutTeamsInput | ProjectUpsertWithWhereUniqueWithoutTeamsInput[]
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutTeamsInput | ProjectUpdateWithWhereUniqueWithoutTeamsInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutTeamsInput | ProjectUpdateManyWithWhereWithoutTeamsInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type UserSkillProfileUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<UserSkillProfileCreateWithoutTeamInput, UserSkillProfileUncheckedCreateWithoutTeamInput> | UserSkillProfileCreateWithoutTeamInput[] | UserSkillProfileUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: UserSkillProfileCreateOrConnectWithoutTeamInput | UserSkillProfileCreateOrConnectWithoutTeamInput[]
    upsert?: UserSkillProfileUpsertWithWhereUniqueWithoutTeamInput | UserSkillProfileUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: UserSkillProfileCreateManyTeamInputEnvelope
    set?: UserSkillProfileWhereUniqueInput | UserSkillProfileWhereUniqueInput[]
    disconnect?: UserSkillProfileWhereUniqueInput | UserSkillProfileWhereUniqueInput[]
    delete?: UserSkillProfileWhereUniqueInput | UserSkillProfileWhereUniqueInput[]
    connect?: UserSkillProfileWhereUniqueInput | UserSkillProfileWhereUniqueInput[]
    update?: UserSkillProfileUpdateWithWhereUniqueWithoutTeamInput | UserSkillProfileUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: UserSkillProfileUpdateManyWithWhereWithoutTeamInput | UserSkillProfileUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: UserSkillProfileScalarWhereInput | UserSkillProfileScalarWhereInput[]
  }

  export type TeamMembershipCreateNestedManyWithoutRoleInput = {
    create?: XOR<TeamMembershipCreateWithoutRoleInput, TeamMembershipUncheckedCreateWithoutRoleInput> | TeamMembershipCreateWithoutRoleInput[] | TeamMembershipUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: TeamMembershipCreateOrConnectWithoutRoleInput | TeamMembershipCreateOrConnectWithoutRoleInput[]
    createMany?: TeamMembershipCreateManyRoleInputEnvelope
    connect?: TeamMembershipWhereUniqueInput | TeamMembershipWhereUniqueInput[]
  }

  export type TeamMembershipUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<TeamMembershipCreateWithoutRoleInput, TeamMembershipUncheckedCreateWithoutRoleInput> | TeamMembershipCreateWithoutRoleInput[] | TeamMembershipUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: TeamMembershipCreateOrConnectWithoutRoleInput | TeamMembershipCreateOrConnectWithoutRoleInput[]
    createMany?: TeamMembershipCreateManyRoleInputEnvelope
    connect?: TeamMembershipWhereUniqueInput | TeamMembershipWhereUniqueInput[]
  }

  export type TeamMembershipUpdateManyWithoutRoleNestedInput = {
    create?: XOR<TeamMembershipCreateWithoutRoleInput, TeamMembershipUncheckedCreateWithoutRoleInput> | TeamMembershipCreateWithoutRoleInput[] | TeamMembershipUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: TeamMembershipCreateOrConnectWithoutRoleInput | TeamMembershipCreateOrConnectWithoutRoleInput[]
    upsert?: TeamMembershipUpsertWithWhereUniqueWithoutRoleInput | TeamMembershipUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: TeamMembershipCreateManyRoleInputEnvelope
    set?: TeamMembershipWhereUniqueInput | TeamMembershipWhereUniqueInput[]
    disconnect?: TeamMembershipWhereUniqueInput | TeamMembershipWhereUniqueInput[]
    delete?: TeamMembershipWhereUniqueInput | TeamMembershipWhereUniqueInput[]
    connect?: TeamMembershipWhereUniqueInput | TeamMembershipWhereUniqueInput[]
    update?: TeamMembershipUpdateWithWhereUniqueWithoutRoleInput | TeamMembershipUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: TeamMembershipUpdateManyWithWhereWithoutRoleInput | TeamMembershipUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: TeamMembershipScalarWhereInput | TeamMembershipScalarWhereInput[]
  }

  export type TeamMembershipUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<TeamMembershipCreateWithoutRoleInput, TeamMembershipUncheckedCreateWithoutRoleInput> | TeamMembershipCreateWithoutRoleInput[] | TeamMembershipUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: TeamMembershipCreateOrConnectWithoutRoleInput | TeamMembershipCreateOrConnectWithoutRoleInput[]
    upsert?: TeamMembershipUpsertWithWhereUniqueWithoutRoleInput | TeamMembershipUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: TeamMembershipCreateManyRoleInputEnvelope
    set?: TeamMembershipWhereUniqueInput | TeamMembershipWhereUniqueInput[]
    disconnect?: TeamMembershipWhereUniqueInput | TeamMembershipWhereUniqueInput[]
    delete?: TeamMembershipWhereUniqueInput | TeamMembershipWhereUniqueInput[]
    connect?: TeamMembershipWhereUniqueInput | TeamMembershipWhereUniqueInput[]
    update?: TeamMembershipUpdateWithWhereUniqueWithoutRoleInput | TeamMembershipUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: TeamMembershipUpdateManyWithWhereWithoutRoleInput | TeamMembershipUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: TeamMembershipScalarWhereInput | TeamMembershipScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutOrganizationMembershipsInput = {
    create?: XOR<UserCreateWithoutOrganizationMembershipsInput, UserUncheckedCreateWithoutOrganizationMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationMembershipsInput
    connect?: UserWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutUsersInput = {
    create?: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutUsersInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutOrganizationMembershipsNestedInput = {
    create?: XOR<UserCreateWithoutOrganizationMembershipsInput, UserUncheckedCreateWithoutOrganizationMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationMembershipsInput
    upsert?: UserUpsertWithoutOrganizationMembershipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrganizationMembershipsInput, UserUpdateWithoutOrganizationMembershipsInput>, UserUncheckedUpdateWithoutOrganizationMembershipsInput>
  }

  export type OrganizationUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutUsersInput
    upsert?: OrganizationUpsertWithoutUsersInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutUsersInput, OrganizationUpdateWithoutUsersInput>, OrganizationUncheckedUpdateWithoutUsersInput>
  }

  export type UserCreateNestedOneWithoutTeamMembershipsInput = {
    create?: XOR<UserCreateWithoutTeamMembershipsInput, UserUncheckedCreateWithoutTeamMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamMembershipsInput
    connect?: UserWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutMembersInput = {
    create?: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutMembersInput
    connect?: TeamWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutTeamMembershipsInput = {
    create?: XOR<RoleCreateWithoutTeamMembershipsInput, RoleUncheckedCreateWithoutTeamMembershipsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutTeamMembershipsInput
    connect?: RoleWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTeamMembershipsNestedInput = {
    create?: XOR<UserCreateWithoutTeamMembershipsInput, UserUncheckedCreateWithoutTeamMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamMembershipsInput
    upsert?: UserUpsertWithoutTeamMembershipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTeamMembershipsInput, UserUpdateWithoutTeamMembershipsInput>, UserUncheckedUpdateWithoutTeamMembershipsInput>
  }

  export type TeamUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutMembersInput
    upsert?: TeamUpsertWithoutMembersInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutMembersInput, TeamUpdateWithoutMembersInput>, TeamUncheckedUpdateWithoutMembersInput>
  }

  export type RoleUpdateOneWithoutTeamMembershipsNestedInput = {
    create?: XOR<RoleCreateWithoutTeamMembershipsInput, RoleUncheckedCreateWithoutTeamMembershipsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutTeamMembershipsInput
    upsert?: RoleUpsertWithoutTeamMembershipsInput
    disconnect?: RoleWhereInput | boolean
    delete?: RoleWhereInput | boolean
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutTeamMembershipsInput, RoleUpdateWithoutTeamMembershipsInput>, RoleUncheckedUpdateWithoutTeamMembershipsInput>
  }

  export type OrganizationCreateNestedOneWithoutPortfoliosInput = {
    create?: XOR<OrganizationCreateWithoutPortfoliosInput, OrganizationUncheckedCreateWithoutPortfoliosInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutPortfoliosInput
    connect?: OrganizationWhereUniqueInput
  }

  export type ProjectCreateNestedManyWithoutPortfolioInput = {
    create?: XOR<ProjectCreateWithoutPortfolioInput, ProjectUncheckedCreateWithoutPortfolioInput> | ProjectCreateWithoutPortfolioInput[] | ProjectUncheckedCreateWithoutPortfolioInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutPortfolioInput | ProjectCreateOrConnectWithoutPortfolioInput[]
    createMany?: ProjectCreateManyPortfolioInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutPortfolioInput = {
    create?: XOR<ProjectCreateWithoutPortfolioInput, ProjectUncheckedCreateWithoutPortfolioInput> | ProjectCreateWithoutPortfolioInput[] | ProjectUncheckedCreateWithoutPortfolioInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutPortfolioInput | ProjectCreateOrConnectWithoutPortfolioInput[]
    createMany?: ProjectCreateManyPortfolioInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type OrganizationUpdateOneRequiredWithoutPortfoliosNestedInput = {
    create?: XOR<OrganizationCreateWithoutPortfoliosInput, OrganizationUncheckedCreateWithoutPortfoliosInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutPortfoliosInput
    upsert?: OrganizationUpsertWithoutPortfoliosInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutPortfoliosInput, OrganizationUpdateWithoutPortfoliosInput>, OrganizationUncheckedUpdateWithoutPortfoliosInput>
  }

  export type ProjectUpdateManyWithoutPortfolioNestedInput = {
    create?: XOR<ProjectCreateWithoutPortfolioInput, ProjectUncheckedCreateWithoutPortfolioInput> | ProjectCreateWithoutPortfolioInput[] | ProjectUncheckedCreateWithoutPortfolioInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutPortfolioInput | ProjectCreateOrConnectWithoutPortfolioInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutPortfolioInput | ProjectUpsertWithWhereUniqueWithoutPortfolioInput[]
    createMany?: ProjectCreateManyPortfolioInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutPortfolioInput | ProjectUpdateWithWhereUniqueWithoutPortfolioInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutPortfolioInput | ProjectUpdateManyWithWhereWithoutPortfolioInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutPortfolioNestedInput = {
    create?: XOR<ProjectCreateWithoutPortfolioInput, ProjectUncheckedCreateWithoutPortfolioInput> | ProjectCreateWithoutPortfolioInput[] | ProjectUncheckedCreateWithoutPortfolioInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutPortfolioInput | ProjectCreateOrConnectWithoutPortfolioInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutPortfolioInput | ProjectUpsertWithWhereUniqueWithoutPortfolioInput[]
    createMany?: ProjectCreateManyPortfolioInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutPortfolioInput | ProjectUpdateWithWhereUniqueWithoutPortfolioInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutPortfolioInput | ProjectUpdateManyWithWhereWithoutPortfolioInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type PortfolioCreateNestedOneWithoutProjectsInput = {
    create?: XOR<PortfolioCreateWithoutProjectsInput, PortfolioUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: PortfolioCreateOrConnectWithoutProjectsInput
    connect?: PortfolioWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutProjectsInput = {
    create?: XOR<OrganizationCreateWithoutProjectsInput, OrganizationUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutProjectsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOwnedProjectsInput = {
    create?: XOR<UserCreateWithoutOwnedProjectsInput, UserUncheckedCreateWithoutOwnedProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedProjectsInput
    connect?: UserWhereUniqueInput
  }

  export type WorkItemCreateNestedManyWithoutProjectInput = {
    create?: XOR<WorkItemCreateWithoutProjectInput, WorkItemUncheckedCreateWithoutProjectInput> | WorkItemCreateWithoutProjectInput[] | WorkItemUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: WorkItemCreateOrConnectWithoutProjectInput | WorkItemCreateOrConnectWithoutProjectInput[]
    createMany?: WorkItemCreateManyProjectInputEnvelope
    connect?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
  }

  export type SprintCreateNestedManyWithoutProjectInput = {
    create?: XOR<SprintCreateWithoutProjectInput, SprintUncheckedCreateWithoutProjectInput> | SprintCreateWithoutProjectInput[] | SprintUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SprintCreateOrConnectWithoutProjectInput | SprintCreateOrConnectWithoutProjectInput[]
    createMany?: SprintCreateManyProjectInputEnvelope
    connect?: SprintWhereUniqueInput | SprintWhereUniqueInput[]
  }

  export type MilestoneCreateNestedManyWithoutProjectInput = {
    create?: XOR<MilestoneCreateWithoutProjectInput, MilestoneUncheckedCreateWithoutProjectInput> | MilestoneCreateWithoutProjectInput[] | MilestoneUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MilestoneCreateOrConnectWithoutProjectInput | MilestoneCreateOrConnectWithoutProjectInput[]
    createMany?: MilestoneCreateManyProjectInputEnvelope
    connect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
  }

  export type BoardCreateNestedManyWithoutProjectInput = {
    create?: XOR<BoardCreateWithoutProjectInput, BoardUncheckedCreateWithoutProjectInput> | BoardCreateWithoutProjectInput[] | BoardUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: BoardCreateOrConnectWithoutProjectInput | BoardCreateOrConnectWithoutProjectInput[]
    createMany?: BoardCreateManyProjectInputEnvelope
    connect?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
  }

  export type WorkflowRuleCreateNestedManyWithoutProjectInput = {
    create?: XOR<WorkflowRuleCreateWithoutProjectInput, WorkflowRuleUncheckedCreateWithoutProjectInput> | WorkflowRuleCreateWithoutProjectInput[] | WorkflowRuleUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: WorkflowRuleCreateOrConnectWithoutProjectInput | WorkflowRuleCreateOrConnectWithoutProjectInput[]
    createMany?: WorkflowRuleCreateManyProjectInputEnvelope
    connect?: WorkflowRuleWhereUniqueInput | WorkflowRuleWhereUniqueInput[]
  }

  export type WorkItemStateCreateNestedManyWithoutProjectInput = {
    create?: XOR<WorkItemStateCreateWithoutProjectInput, WorkItemStateUncheckedCreateWithoutProjectInput> | WorkItemStateCreateWithoutProjectInput[] | WorkItemStateUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: WorkItemStateCreateOrConnectWithoutProjectInput | WorkItemStateCreateOrConnectWithoutProjectInput[]
    createMany?: WorkItemStateCreateManyProjectInputEnvelope
    connect?: WorkItemStateWhereUniqueInput | WorkItemStateWhereUniqueInput[]
  }

  export type ComponentCreateNestedManyWithoutProjectInput = {
    create?: XOR<ComponentCreateWithoutProjectInput, ComponentUncheckedCreateWithoutProjectInput> | ComponentCreateWithoutProjectInput[] | ComponentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ComponentCreateOrConnectWithoutProjectInput | ComponentCreateOrConnectWithoutProjectInput[]
    createMany?: ComponentCreateManyProjectInputEnvelope
    connect?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
  }

  export type TeamCreateNestedManyWithoutProjectsInput = {
    create?: XOR<TeamCreateWithoutProjectsInput, TeamUncheckedCreateWithoutProjectsInput> | TeamCreateWithoutProjectsInput[] | TeamUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutProjectsInput | TeamCreateOrConnectWithoutProjectsInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type WorkItemUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<WorkItemCreateWithoutProjectInput, WorkItemUncheckedCreateWithoutProjectInput> | WorkItemCreateWithoutProjectInput[] | WorkItemUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: WorkItemCreateOrConnectWithoutProjectInput | WorkItemCreateOrConnectWithoutProjectInput[]
    createMany?: WorkItemCreateManyProjectInputEnvelope
    connect?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
  }

  export type SprintUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<SprintCreateWithoutProjectInput, SprintUncheckedCreateWithoutProjectInput> | SprintCreateWithoutProjectInput[] | SprintUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SprintCreateOrConnectWithoutProjectInput | SprintCreateOrConnectWithoutProjectInput[]
    createMany?: SprintCreateManyProjectInputEnvelope
    connect?: SprintWhereUniqueInput | SprintWhereUniqueInput[]
  }

  export type MilestoneUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<MilestoneCreateWithoutProjectInput, MilestoneUncheckedCreateWithoutProjectInput> | MilestoneCreateWithoutProjectInput[] | MilestoneUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MilestoneCreateOrConnectWithoutProjectInput | MilestoneCreateOrConnectWithoutProjectInput[]
    createMany?: MilestoneCreateManyProjectInputEnvelope
    connect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
  }

  export type BoardUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<BoardCreateWithoutProjectInput, BoardUncheckedCreateWithoutProjectInput> | BoardCreateWithoutProjectInput[] | BoardUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: BoardCreateOrConnectWithoutProjectInput | BoardCreateOrConnectWithoutProjectInput[]
    createMany?: BoardCreateManyProjectInputEnvelope
    connect?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
  }

  export type WorkflowRuleUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<WorkflowRuleCreateWithoutProjectInput, WorkflowRuleUncheckedCreateWithoutProjectInput> | WorkflowRuleCreateWithoutProjectInput[] | WorkflowRuleUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: WorkflowRuleCreateOrConnectWithoutProjectInput | WorkflowRuleCreateOrConnectWithoutProjectInput[]
    createMany?: WorkflowRuleCreateManyProjectInputEnvelope
    connect?: WorkflowRuleWhereUniqueInput | WorkflowRuleWhereUniqueInput[]
  }

  export type WorkItemStateUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<WorkItemStateCreateWithoutProjectInput, WorkItemStateUncheckedCreateWithoutProjectInput> | WorkItemStateCreateWithoutProjectInput[] | WorkItemStateUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: WorkItemStateCreateOrConnectWithoutProjectInput | WorkItemStateCreateOrConnectWithoutProjectInput[]
    createMany?: WorkItemStateCreateManyProjectInputEnvelope
    connect?: WorkItemStateWhereUniqueInput | WorkItemStateWhereUniqueInput[]
  }

  export type ComponentUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ComponentCreateWithoutProjectInput, ComponentUncheckedCreateWithoutProjectInput> | ComponentCreateWithoutProjectInput[] | ComponentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ComponentCreateOrConnectWithoutProjectInput | ComponentCreateOrConnectWithoutProjectInput[]
    createMany?: ComponentCreateManyProjectInputEnvelope
    connect?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
  }

  export type TeamUncheckedCreateNestedManyWithoutProjectsInput = {
    create?: XOR<TeamCreateWithoutProjectsInput, TeamUncheckedCreateWithoutProjectsInput> | TeamCreateWithoutProjectsInput[] | TeamUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutProjectsInput | TeamCreateOrConnectWithoutProjectsInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PortfolioUpdateOneWithoutProjectsNestedInput = {
    create?: XOR<PortfolioCreateWithoutProjectsInput, PortfolioUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: PortfolioCreateOrConnectWithoutProjectsInput
    upsert?: PortfolioUpsertWithoutProjectsInput
    disconnect?: PortfolioWhereInput | boolean
    delete?: PortfolioWhereInput | boolean
    connect?: PortfolioWhereUniqueInput
    update?: XOR<XOR<PortfolioUpdateToOneWithWhereWithoutProjectsInput, PortfolioUpdateWithoutProjectsInput>, PortfolioUncheckedUpdateWithoutProjectsInput>
  }

  export type OrganizationUpdateOneRequiredWithoutProjectsNestedInput = {
    create?: XOR<OrganizationCreateWithoutProjectsInput, OrganizationUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutProjectsInput
    upsert?: OrganizationUpsertWithoutProjectsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutProjectsInput, OrganizationUpdateWithoutProjectsInput>, OrganizationUncheckedUpdateWithoutProjectsInput>
  }

  export type UserUpdateOneWithoutOwnedProjectsNestedInput = {
    create?: XOR<UserCreateWithoutOwnedProjectsInput, UserUncheckedCreateWithoutOwnedProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedProjectsInput
    upsert?: UserUpsertWithoutOwnedProjectsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOwnedProjectsInput, UserUpdateWithoutOwnedProjectsInput>, UserUncheckedUpdateWithoutOwnedProjectsInput>
  }

  export type WorkItemUpdateManyWithoutProjectNestedInput = {
    create?: XOR<WorkItemCreateWithoutProjectInput, WorkItemUncheckedCreateWithoutProjectInput> | WorkItemCreateWithoutProjectInput[] | WorkItemUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: WorkItemCreateOrConnectWithoutProjectInput | WorkItemCreateOrConnectWithoutProjectInput[]
    upsert?: WorkItemUpsertWithWhereUniqueWithoutProjectInput | WorkItemUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: WorkItemCreateManyProjectInputEnvelope
    set?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    disconnect?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    delete?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    connect?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    update?: WorkItemUpdateWithWhereUniqueWithoutProjectInput | WorkItemUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: WorkItemUpdateManyWithWhereWithoutProjectInput | WorkItemUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: WorkItemScalarWhereInput | WorkItemScalarWhereInput[]
  }

  export type SprintUpdateManyWithoutProjectNestedInput = {
    create?: XOR<SprintCreateWithoutProjectInput, SprintUncheckedCreateWithoutProjectInput> | SprintCreateWithoutProjectInput[] | SprintUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SprintCreateOrConnectWithoutProjectInput | SprintCreateOrConnectWithoutProjectInput[]
    upsert?: SprintUpsertWithWhereUniqueWithoutProjectInput | SprintUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: SprintCreateManyProjectInputEnvelope
    set?: SprintWhereUniqueInput | SprintWhereUniqueInput[]
    disconnect?: SprintWhereUniqueInput | SprintWhereUniqueInput[]
    delete?: SprintWhereUniqueInput | SprintWhereUniqueInput[]
    connect?: SprintWhereUniqueInput | SprintWhereUniqueInput[]
    update?: SprintUpdateWithWhereUniqueWithoutProjectInput | SprintUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: SprintUpdateManyWithWhereWithoutProjectInput | SprintUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: SprintScalarWhereInput | SprintScalarWhereInput[]
  }

  export type MilestoneUpdateManyWithoutProjectNestedInput = {
    create?: XOR<MilestoneCreateWithoutProjectInput, MilestoneUncheckedCreateWithoutProjectInput> | MilestoneCreateWithoutProjectInput[] | MilestoneUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MilestoneCreateOrConnectWithoutProjectInput | MilestoneCreateOrConnectWithoutProjectInput[]
    upsert?: MilestoneUpsertWithWhereUniqueWithoutProjectInput | MilestoneUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: MilestoneCreateManyProjectInputEnvelope
    set?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    disconnect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    delete?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    connect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    update?: MilestoneUpdateWithWhereUniqueWithoutProjectInput | MilestoneUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: MilestoneUpdateManyWithWhereWithoutProjectInput | MilestoneUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: MilestoneScalarWhereInput | MilestoneScalarWhereInput[]
  }

  export type BoardUpdateManyWithoutProjectNestedInput = {
    create?: XOR<BoardCreateWithoutProjectInput, BoardUncheckedCreateWithoutProjectInput> | BoardCreateWithoutProjectInput[] | BoardUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: BoardCreateOrConnectWithoutProjectInput | BoardCreateOrConnectWithoutProjectInput[]
    upsert?: BoardUpsertWithWhereUniqueWithoutProjectInput | BoardUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: BoardCreateManyProjectInputEnvelope
    set?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
    disconnect?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
    delete?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
    connect?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
    update?: BoardUpdateWithWhereUniqueWithoutProjectInput | BoardUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: BoardUpdateManyWithWhereWithoutProjectInput | BoardUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: BoardScalarWhereInput | BoardScalarWhereInput[]
  }

  export type WorkflowRuleUpdateManyWithoutProjectNestedInput = {
    create?: XOR<WorkflowRuleCreateWithoutProjectInput, WorkflowRuleUncheckedCreateWithoutProjectInput> | WorkflowRuleCreateWithoutProjectInput[] | WorkflowRuleUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: WorkflowRuleCreateOrConnectWithoutProjectInput | WorkflowRuleCreateOrConnectWithoutProjectInput[]
    upsert?: WorkflowRuleUpsertWithWhereUniqueWithoutProjectInput | WorkflowRuleUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: WorkflowRuleCreateManyProjectInputEnvelope
    set?: WorkflowRuleWhereUniqueInput | WorkflowRuleWhereUniqueInput[]
    disconnect?: WorkflowRuleWhereUniqueInput | WorkflowRuleWhereUniqueInput[]
    delete?: WorkflowRuleWhereUniqueInput | WorkflowRuleWhereUniqueInput[]
    connect?: WorkflowRuleWhereUniqueInput | WorkflowRuleWhereUniqueInput[]
    update?: WorkflowRuleUpdateWithWhereUniqueWithoutProjectInput | WorkflowRuleUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: WorkflowRuleUpdateManyWithWhereWithoutProjectInput | WorkflowRuleUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: WorkflowRuleScalarWhereInput | WorkflowRuleScalarWhereInput[]
  }

  export type WorkItemStateUpdateManyWithoutProjectNestedInput = {
    create?: XOR<WorkItemStateCreateWithoutProjectInput, WorkItemStateUncheckedCreateWithoutProjectInput> | WorkItemStateCreateWithoutProjectInput[] | WorkItemStateUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: WorkItemStateCreateOrConnectWithoutProjectInput | WorkItemStateCreateOrConnectWithoutProjectInput[]
    upsert?: WorkItemStateUpsertWithWhereUniqueWithoutProjectInput | WorkItemStateUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: WorkItemStateCreateManyProjectInputEnvelope
    set?: WorkItemStateWhereUniqueInput | WorkItemStateWhereUniqueInput[]
    disconnect?: WorkItemStateWhereUniqueInput | WorkItemStateWhereUniqueInput[]
    delete?: WorkItemStateWhereUniqueInput | WorkItemStateWhereUniqueInput[]
    connect?: WorkItemStateWhereUniqueInput | WorkItemStateWhereUniqueInput[]
    update?: WorkItemStateUpdateWithWhereUniqueWithoutProjectInput | WorkItemStateUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: WorkItemStateUpdateManyWithWhereWithoutProjectInput | WorkItemStateUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: WorkItemStateScalarWhereInput | WorkItemStateScalarWhereInput[]
  }

  export type ComponentUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ComponentCreateWithoutProjectInput, ComponentUncheckedCreateWithoutProjectInput> | ComponentCreateWithoutProjectInput[] | ComponentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ComponentCreateOrConnectWithoutProjectInput | ComponentCreateOrConnectWithoutProjectInput[]
    upsert?: ComponentUpsertWithWhereUniqueWithoutProjectInput | ComponentUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ComponentCreateManyProjectInputEnvelope
    set?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    disconnect?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    delete?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    connect?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    update?: ComponentUpdateWithWhereUniqueWithoutProjectInput | ComponentUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ComponentUpdateManyWithWhereWithoutProjectInput | ComponentUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ComponentScalarWhereInput | ComponentScalarWhereInput[]
  }

  export type TeamUpdateManyWithoutProjectsNestedInput = {
    create?: XOR<TeamCreateWithoutProjectsInput, TeamUncheckedCreateWithoutProjectsInput> | TeamCreateWithoutProjectsInput[] | TeamUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutProjectsInput | TeamCreateOrConnectWithoutProjectsInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutProjectsInput | TeamUpsertWithWhereUniqueWithoutProjectsInput[]
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutProjectsInput | TeamUpdateWithWhereUniqueWithoutProjectsInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutProjectsInput | TeamUpdateManyWithWhereWithoutProjectsInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type WorkItemUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<WorkItemCreateWithoutProjectInput, WorkItemUncheckedCreateWithoutProjectInput> | WorkItemCreateWithoutProjectInput[] | WorkItemUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: WorkItemCreateOrConnectWithoutProjectInput | WorkItemCreateOrConnectWithoutProjectInput[]
    upsert?: WorkItemUpsertWithWhereUniqueWithoutProjectInput | WorkItemUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: WorkItemCreateManyProjectInputEnvelope
    set?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    disconnect?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    delete?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    connect?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    update?: WorkItemUpdateWithWhereUniqueWithoutProjectInput | WorkItemUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: WorkItemUpdateManyWithWhereWithoutProjectInput | WorkItemUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: WorkItemScalarWhereInput | WorkItemScalarWhereInput[]
  }

  export type SprintUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<SprintCreateWithoutProjectInput, SprintUncheckedCreateWithoutProjectInput> | SprintCreateWithoutProjectInput[] | SprintUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SprintCreateOrConnectWithoutProjectInput | SprintCreateOrConnectWithoutProjectInput[]
    upsert?: SprintUpsertWithWhereUniqueWithoutProjectInput | SprintUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: SprintCreateManyProjectInputEnvelope
    set?: SprintWhereUniqueInput | SprintWhereUniqueInput[]
    disconnect?: SprintWhereUniqueInput | SprintWhereUniqueInput[]
    delete?: SprintWhereUniqueInput | SprintWhereUniqueInput[]
    connect?: SprintWhereUniqueInput | SprintWhereUniqueInput[]
    update?: SprintUpdateWithWhereUniqueWithoutProjectInput | SprintUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: SprintUpdateManyWithWhereWithoutProjectInput | SprintUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: SprintScalarWhereInput | SprintScalarWhereInput[]
  }

  export type MilestoneUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<MilestoneCreateWithoutProjectInput, MilestoneUncheckedCreateWithoutProjectInput> | MilestoneCreateWithoutProjectInput[] | MilestoneUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MilestoneCreateOrConnectWithoutProjectInput | MilestoneCreateOrConnectWithoutProjectInput[]
    upsert?: MilestoneUpsertWithWhereUniqueWithoutProjectInput | MilestoneUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: MilestoneCreateManyProjectInputEnvelope
    set?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    disconnect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    delete?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    connect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    update?: MilestoneUpdateWithWhereUniqueWithoutProjectInput | MilestoneUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: MilestoneUpdateManyWithWhereWithoutProjectInput | MilestoneUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: MilestoneScalarWhereInput | MilestoneScalarWhereInput[]
  }

  export type BoardUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<BoardCreateWithoutProjectInput, BoardUncheckedCreateWithoutProjectInput> | BoardCreateWithoutProjectInput[] | BoardUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: BoardCreateOrConnectWithoutProjectInput | BoardCreateOrConnectWithoutProjectInput[]
    upsert?: BoardUpsertWithWhereUniqueWithoutProjectInput | BoardUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: BoardCreateManyProjectInputEnvelope
    set?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
    disconnect?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
    delete?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
    connect?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
    update?: BoardUpdateWithWhereUniqueWithoutProjectInput | BoardUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: BoardUpdateManyWithWhereWithoutProjectInput | BoardUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: BoardScalarWhereInput | BoardScalarWhereInput[]
  }

  export type WorkflowRuleUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<WorkflowRuleCreateWithoutProjectInput, WorkflowRuleUncheckedCreateWithoutProjectInput> | WorkflowRuleCreateWithoutProjectInput[] | WorkflowRuleUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: WorkflowRuleCreateOrConnectWithoutProjectInput | WorkflowRuleCreateOrConnectWithoutProjectInput[]
    upsert?: WorkflowRuleUpsertWithWhereUniqueWithoutProjectInput | WorkflowRuleUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: WorkflowRuleCreateManyProjectInputEnvelope
    set?: WorkflowRuleWhereUniqueInput | WorkflowRuleWhereUniqueInput[]
    disconnect?: WorkflowRuleWhereUniqueInput | WorkflowRuleWhereUniqueInput[]
    delete?: WorkflowRuleWhereUniqueInput | WorkflowRuleWhereUniqueInput[]
    connect?: WorkflowRuleWhereUniqueInput | WorkflowRuleWhereUniqueInput[]
    update?: WorkflowRuleUpdateWithWhereUniqueWithoutProjectInput | WorkflowRuleUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: WorkflowRuleUpdateManyWithWhereWithoutProjectInput | WorkflowRuleUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: WorkflowRuleScalarWhereInput | WorkflowRuleScalarWhereInput[]
  }

  export type WorkItemStateUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<WorkItemStateCreateWithoutProjectInput, WorkItemStateUncheckedCreateWithoutProjectInput> | WorkItemStateCreateWithoutProjectInput[] | WorkItemStateUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: WorkItemStateCreateOrConnectWithoutProjectInput | WorkItemStateCreateOrConnectWithoutProjectInput[]
    upsert?: WorkItemStateUpsertWithWhereUniqueWithoutProjectInput | WorkItemStateUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: WorkItemStateCreateManyProjectInputEnvelope
    set?: WorkItemStateWhereUniqueInput | WorkItemStateWhereUniqueInput[]
    disconnect?: WorkItemStateWhereUniqueInput | WorkItemStateWhereUniqueInput[]
    delete?: WorkItemStateWhereUniqueInput | WorkItemStateWhereUniqueInput[]
    connect?: WorkItemStateWhereUniqueInput | WorkItemStateWhereUniqueInput[]
    update?: WorkItemStateUpdateWithWhereUniqueWithoutProjectInput | WorkItemStateUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: WorkItemStateUpdateManyWithWhereWithoutProjectInput | WorkItemStateUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: WorkItemStateScalarWhereInput | WorkItemStateScalarWhereInput[]
  }

  export type ComponentUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ComponentCreateWithoutProjectInput, ComponentUncheckedCreateWithoutProjectInput> | ComponentCreateWithoutProjectInput[] | ComponentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ComponentCreateOrConnectWithoutProjectInput | ComponentCreateOrConnectWithoutProjectInput[]
    upsert?: ComponentUpsertWithWhereUniqueWithoutProjectInput | ComponentUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ComponentCreateManyProjectInputEnvelope
    set?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    disconnect?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    delete?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    connect?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    update?: ComponentUpdateWithWhereUniqueWithoutProjectInput | ComponentUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ComponentUpdateManyWithWhereWithoutProjectInput | ComponentUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ComponentScalarWhereInput | ComponentScalarWhereInput[]
  }

  export type TeamUncheckedUpdateManyWithoutProjectsNestedInput = {
    create?: XOR<TeamCreateWithoutProjectsInput, TeamUncheckedCreateWithoutProjectsInput> | TeamCreateWithoutProjectsInput[] | TeamUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutProjectsInput | TeamCreateOrConnectWithoutProjectsInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutProjectsInput | TeamUpsertWithWhereUniqueWithoutProjectsInput[]
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutProjectsInput | TeamUpdateWithWhereUniqueWithoutProjectsInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutProjectsInput | TeamUpdateManyWithWhereWithoutProjectsInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutSprintsInput = {
    create?: XOR<ProjectCreateWithoutSprintsInput, ProjectUncheckedCreateWithoutSprintsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSprintsInput
    connect?: ProjectWhereUniqueInput
  }

  export type WorkItemCreateNestedManyWithoutSprintInput = {
    create?: XOR<WorkItemCreateWithoutSprintInput, WorkItemUncheckedCreateWithoutSprintInput> | WorkItemCreateWithoutSprintInput[] | WorkItemUncheckedCreateWithoutSprintInput[]
    connectOrCreate?: WorkItemCreateOrConnectWithoutSprintInput | WorkItemCreateOrConnectWithoutSprintInput[]
    createMany?: WorkItemCreateManySprintInputEnvelope
    connect?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
  }

  export type WorkItemSnapshotCreateNestedManyWithoutSprintInput = {
    create?: XOR<WorkItemSnapshotCreateWithoutSprintInput, WorkItemSnapshotUncheckedCreateWithoutSprintInput> | WorkItemSnapshotCreateWithoutSprintInput[] | WorkItemSnapshotUncheckedCreateWithoutSprintInput[]
    connectOrCreate?: WorkItemSnapshotCreateOrConnectWithoutSprintInput | WorkItemSnapshotCreateOrConnectWithoutSprintInput[]
    createMany?: WorkItemSnapshotCreateManySprintInputEnvelope
    connect?: WorkItemSnapshotWhereUniqueInput | WorkItemSnapshotWhereUniqueInput[]
  }

  export type RetrospectiveCreateNestedOneWithoutSprintInput = {
    create?: XOR<RetrospectiveCreateWithoutSprintInput, RetrospectiveUncheckedCreateWithoutSprintInput>
    connectOrCreate?: RetrospectiveCreateOrConnectWithoutSprintInput
    connect?: RetrospectiveWhereUniqueInput
  }

  export type TimeLogCreateNestedManyWithoutSprintInput = {
    create?: XOR<TimeLogCreateWithoutSprintInput, TimeLogUncheckedCreateWithoutSprintInput> | TimeLogCreateWithoutSprintInput[] | TimeLogUncheckedCreateWithoutSprintInput[]
    connectOrCreate?: TimeLogCreateOrConnectWithoutSprintInput | TimeLogCreateOrConnectWithoutSprintInput[]
    createMany?: TimeLogCreateManySprintInputEnvelope
    connect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
  }

  export type BoardCreateNestedManyWithoutSprintInput = {
    create?: XOR<BoardCreateWithoutSprintInput, BoardUncheckedCreateWithoutSprintInput> | BoardCreateWithoutSprintInput[] | BoardUncheckedCreateWithoutSprintInput[]
    connectOrCreate?: BoardCreateOrConnectWithoutSprintInput | BoardCreateOrConnectWithoutSprintInput[]
    createMany?: BoardCreateManySprintInputEnvelope
    connect?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
  }

  export type WorkItemUncheckedCreateNestedManyWithoutSprintInput = {
    create?: XOR<WorkItemCreateWithoutSprintInput, WorkItemUncheckedCreateWithoutSprintInput> | WorkItemCreateWithoutSprintInput[] | WorkItemUncheckedCreateWithoutSprintInput[]
    connectOrCreate?: WorkItemCreateOrConnectWithoutSprintInput | WorkItemCreateOrConnectWithoutSprintInput[]
    createMany?: WorkItemCreateManySprintInputEnvelope
    connect?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
  }

  export type WorkItemSnapshotUncheckedCreateNestedManyWithoutSprintInput = {
    create?: XOR<WorkItemSnapshotCreateWithoutSprintInput, WorkItemSnapshotUncheckedCreateWithoutSprintInput> | WorkItemSnapshotCreateWithoutSprintInput[] | WorkItemSnapshotUncheckedCreateWithoutSprintInput[]
    connectOrCreate?: WorkItemSnapshotCreateOrConnectWithoutSprintInput | WorkItemSnapshotCreateOrConnectWithoutSprintInput[]
    createMany?: WorkItemSnapshotCreateManySprintInputEnvelope
    connect?: WorkItemSnapshotWhereUniqueInput | WorkItemSnapshotWhereUniqueInput[]
  }

  export type RetrospectiveUncheckedCreateNestedOneWithoutSprintInput = {
    create?: XOR<RetrospectiveCreateWithoutSprintInput, RetrospectiveUncheckedCreateWithoutSprintInput>
    connectOrCreate?: RetrospectiveCreateOrConnectWithoutSprintInput
    connect?: RetrospectiveWhereUniqueInput
  }

  export type TimeLogUncheckedCreateNestedManyWithoutSprintInput = {
    create?: XOR<TimeLogCreateWithoutSprintInput, TimeLogUncheckedCreateWithoutSprintInput> | TimeLogCreateWithoutSprintInput[] | TimeLogUncheckedCreateWithoutSprintInput[]
    connectOrCreate?: TimeLogCreateOrConnectWithoutSprintInput | TimeLogCreateOrConnectWithoutSprintInput[]
    createMany?: TimeLogCreateManySprintInputEnvelope
    connect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
  }

  export type BoardUncheckedCreateNestedManyWithoutSprintInput = {
    create?: XOR<BoardCreateWithoutSprintInput, BoardUncheckedCreateWithoutSprintInput> | BoardCreateWithoutSprintInput[] | BoardUncheckedCreateWithoutSprintInput[]
    connectOrCreate?: BoardCreateOrConnectWithoutSprintInput | BoardCreateOrConnectWithoutSprintInput[]
    createMany?: BoardCreateManySprintInputEnvelope
    connect?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProjectUpdateOneRequiredWithoutSprintsNestedInput = {
    create?: XOR<ProjectCreateWithoutSprintsInput, ProjectUncheckedCreateWithoutSprintsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSprintsInput
    upsert?: ProjectUpsertWithoutSprintsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutSprintsInput, ProjectUpdateWithoutSprintsInput>, ProjectUncheckedUpdateWithoutSprintsInput>
  }

  export type WorkItemUpdateManyWithoutSprintNestedInput = {
    create?: XOR<WorkItemCreateWithoutSprintInput, WorkItemUncheckedCreateWithoutSprintInput> | WorkItemCreateWithoutSprintInput[] | WorkItemUncheckedCreateWithoutSprintInput[]
    connectOrCreate?: WorkItemCreateOrConnectWithoutSprintInput | WorkItemCreateOrConnectWithoutSprintInput[]
    upsert?: WorkItemUpsertWithWhereUniqueWithoutSprintInput | WorkItemUpsertWithWhereUniqueWithoutSprintInput[]
    createMany?: WorkItemCreateManySprintInputEnvelope
    set?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    disconnect?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    delete?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    connect?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    update?: WorkItemUpdateWithWhereUniqueWithoutSprintInput | WorkItemUpdateWithWhereUniqueWithoutSprintInput[]
    updateMany?: WorkItemUpdateManyWithWhereWithoutSprintInput | WorkItemUpdateManyWithWhereWithoutSprintInput[]
    deleteMany?: WorkItemScalarWhereInput | WorkItemScalarWhereInput[]
  }

  export type WorkItemSnapshotUpdateManyWithoutSprintNestedInput = {
    create?: XOR<WorkItemSnapshotCreateWithoutSprintInput, WorkItemSnapshotUncheckedCreateWithoutSprintInput> | WorkItemSnapshotCreateWithoutSprintInput[] | WorkItemSnapshotUncheckedCreateWithoutSprintInput[]
    connectOrCreate?: WorkItemSnapshotCreateOrConnectWithoutSprintInput | WorkItemSnapshotCreateOrConnectWithoutSprintInput[]
    upsert?: WorkItemSnapshotUpsertWithWhereUniqueWithoutSprintInput | WorkItemSnapshotUpsertWithWhereUniqueWithoutSprintInput[]
    createMany?: WorkItemSnapshotCreateManySprintInputEnvelope
    set?: WorkItemSnapshotWhereUniqueInput | WorkItemSnapshotWhereUniqueInput[]
    disconnect?: WorkItemSnapshotWhereUniqueInput | WorkItemSnapshotWhereUniqueInput[]
    delete?: WorkItemSnapshotWhereUniqueInput | WorkItemSnapshotWhereUniqueInput[]
    connect?: WorkItemSnapshotWhereUniqueInput | WorkItemSnapshotWhereUniqueInput[]
    update?: WorkItemSnapshotUpdateWithWhereUniqueWithoutSprintInput | WorkItemSnapshotUpdateWithWhereUniqueWithoutSprintInput[]
    updateMany?: WorkItemSnapshotUpdateManyWithWhereWithoutSprintInput | WorkItemSnapshotUpdateManyWithWhereWithoutSprintInput[]
    deleteMany?: WorkItemSnapshotScalarWhereInput | WorkItemSnapshotScalarWhereInput[]
  }

  export type RetrospectiveUpdateOneWithoutSprintNestedInput = {
    create?: XOR<RetrospectiveCreateWithoutSprintInput, RetrospectiveUncheckedCreateWithoutSprintInput>
    connectOrCreate?: RetrospectiveCreateOrConnectWithoutSprintInput
    upsert?: RetrospectiveUpsertWithoutSprintInput
    disconnect?: RetrospectiveWhereInput | boolean
    delete?: RetrospectiveWhereInput | boolean
    connect?: RetrospectiveWhereUniqueInput
    update?: XOR<XOR<RetrospectiveUpdateToOneWithWhereWithoutSprintInput, RetrospectiveUpdateWithoutSprintInput>, RetrospectiveUncheckedUpdateWithoutSprintInput>
  }

  export type TimeLogUpdateManyWithoutSprintNestedInput = {
    create?: XOR<TimeLogCreateWithoutSprintInput, TimeLogUncheckedCreateWithoutSprintInput> | TimeLogCreateWithoutSprintInput[] | TimeLogUncheckedCreateWithoutSprintInput[]
    connectOrCreate?: TimeLogCreateOrConnectWithoutSprintInput | TimeLogCreateOrConnectWithoutSprintInput[]
    upsert?: TimeLogUpsertWithWhereUniqueWithoutSprintInput | TimeLogUpsertWithWhereUniqueWithoutSprintInput[]
    createMany?: TimeLogCreateManySprintInputEnvelope
    set?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    disconnect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    delete?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    connect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    update?: TimeLogUpdateWithWhereUniqueWithoutSprintInput | TimeLogUpdateWithWhereUniqueWithoutSprintInput[]
    updateMany?: TimeLogUpdateManyWithWhereWithoutSprintInput | TimeLogUpdateManyWithWhereWithoutSprintInput[]
    deleteMany?: TimeLogScalarWhereInput | TimeLogScalarWhereInput[]
  }

  export type BoardUpdateManyWithoutSprintNestedInput = {
    create?: XOR<BoardCreateWithoutSprintInput, BoardUncheckedCreateWithoutSprintInput> | BoardCreateWithoutSprintInput[] | BoardUncheckedCreateWithoutSprintInput[]
    connectOrCreate?: BoardCreateOrConnectWithoutSprintInput | BoardCreateOrConnectWithoutSprintInput[]
    upsert?: BoardUpsertWithWhereUniqueWithoutSprintInput | BoardUpsertWithWhereUniqueWithoutSprintInput[]
    createMany?: BoardCreateManySprintInputEnvelope
    set?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
    disconnect?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
    delete?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
    connect?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
    update?: BoardUpdateWithWhereUniqueWithoutSprintInput | BoardUpdateWithWhereUniqueWithoutSprintInput[]
    updateMany?: BoardUpdateManyWithWhereWithoutSprintInput | BoardUpdateManyWithWhereWithoutSprintInput[]
    deleteMany?: BoardScalarWhereInput | BoardScalarWhereInput[]
  }

  export type WorkItemUncheckedUpdateManyWithoutSprintNestedInput = {
    create?: XOR<WorkItemCreateWithoutSprintInput, WorkItemUncheckedCreateWithoutSprintInput> | WorkItemCreateWithoutSprintInput[] | WorkItemUncheckedCreateWithoutSprintInput[]
    connectOrCreate?: WorkItemCreateOrConnectWithoutSprintInput | WorkItemCreateOrConnectWithoutSprintInput[]
    upsert?: WorkItemUpsertWithWhereUniqueWithoutSprintInput | WorkItemUpsertWithWhereUniqueWithoutSprintInput[]
    createMany?: WorkItemCreateManySprintInputEnvelope
    set?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    disconnect?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    delete?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    connect?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    update?: WorkItemUpdateWithWhereUniqueWithoutSprintInput | WorkItemUpdateWithWhereUniqueWithoutSprintInput[]
    updateMany?: WorkItemUpdateManyWithWhereWithoutSprintInput | WorkItemUpdateManyWithWhereWithoutSprintInput[]
    deleteMany?: WorkItemScalarWhereInput | WorkItemScalarWhereInput[]
  }

  export type WorkItemSnapshotUncheckedUpdateManyWithoutSprintNestedInput = {
    create?: XOR<WorkItemSnapshotCreateWithoutSprintInput, WorkItemSnapshotUncheckedCreateWithoutSprintInput> | WorkItemSnapshotCreateWithoutSprintInput[] | WorkItemSnapshotUncheckedCreateWithoutSprintInput[]
    connectOrCreate?: WorkItemSnapshotCreateOrConnectWithoutSprintInput | WorkItemSnapshotCreateOrConnectWithoutSprintInput[]
    upsert?: WorkItemSnapshotUpsertWithWhereUniqueWithoutSprintInput | WorkItemSnapshotUpsertWithWhereUniqueWithoutSprintInput[]
    createMany?: WorkItemSnapshotCreateManySprintInputEnvelope
    set?: WorkItemSnapshotWhereUniqueInput | WorkItemSnapshotWhereUniqueInput[]
    disconnect?: WorkItemSnapshotWhereUniqueInput | WorkItemSnapshotWhereUniqueInput[]
    delete?: WorkItemSnapshotWhereUniqueInput | WorkItemSnapshotWhereUniqueInput[]
    connect?: WorkItemSnapshotWhereUniqueInput | WorkItemSnapshotWhereUniqueInput[]
    update?: WorkItemSnapshotUpdateWithWhereUniqueWithoutSprintInput | WorkItemSnapshotUpdateWithWhereUniqueWithoutSprintInput[]
    updateMany?: WorkItemSnapshotUpdateManyWithWhereWithoutSprintInput | WorkItemSnapshotUpdateManyWithWhereWithoutSprintInput[]
    deleteMany?: WorkItemSnapshotScalarWhereInput | WorkItemSnapshotScalarWhereInput[]
  }

  export type RetrospectiveUncheckedUpdateOneWithoutSprintNestedInput = {
    create?: XOR<RetrospectiveCreateWithoutSprintInput, RetrospectiveUncheckedCreateWithoutSprintInput>
    connectOrCreate?: RetrospectiveCreateOrConnectWithoutSprintInput
    upsert?: RetrospectiveUpsertWithoutSprintInput
    disconnect?: RetrospectiveWhereInput | boolean
    delete?: RetrospectiveWhereInput | boolean
    connect?: RetrospectiveWhereUniqueInput
    update?: XOR<XOR<RetrospectiveUpdateToOneWithWhereWithoutSprintInput, RetrospectiveUpdateWithoutSprintInput>, RetrospectiveUncheckedUpdateWithoutSprintInput>
  }

  export type TimeLogUncheckedUpdateManyWithoutSprintNestedInput = {
    create?: XOR<TimeLogCreateWithoutSprintInput, TimeLogUncheckedCreateWithoutSprintInput> | TimeLogCreateWithoutSprintInput[] | TimeLogUncheckedCreateWithoutSprintInput[]
    connectOrCreate?: TimeLogCreateOrConnectWithoutSprintInput | TimeLogCreateOrConnectWithoutSprintInput[]
    upsert?: TimeLogUpsertWithWhereUniqueWithoutSprintInput | TimeLogUpsertWithWhereUniqueWithoutSprintInput[]
    createMany?: TimeLogCreateManySprintInputEnvelope
    set?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    disconnect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    delete?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    connect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    update?: TimeLogUpdateWithWhereUniqueWithoutSprintInput | TimeLogUpdateWithWhereUniqueWithoutSprintInput[]
    updateMany?: TimeLogUpdateManyWithWhereWithoutSprintInput | TimeLogUpdateManyWithWhereWithoutSprintInput[]
    deleteMany?: TimeLogScalarWhereInput | TimeLogScalarWhereInput[]
  }

  export type BoardUncheckedUpdateManyWithoutSprintNestedInput = {
    create?: XOR<BoardCreateWithoutSprintInput, BoardUncheckedCreateWithoutSprintInput> | BoardCreateWithoutSprintInput[] | BoardUncheckedCreateWithoutSprintInput[]
    connectOrCreate?: BoardCreateOrConnectWithoutSprintInput | BoardCreateOrConnectWithoutSprintInput[]
    upsert?: BoardUpsertWithWhereUniqueWithoutSprintInput | BoardUpsertWithWhereUniqueWithoutSprintInput[]
    createMany?: BoardCreateManySprintInputEnvelope
    set?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
    disconnect?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
    delete?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
    connect?: BoardWhereUniqueInput | BoardWhereUniqueInput[]
    update?: BoardUpdateWithWhereUniqueWithoutSprintInput | BoardUpdateWithWhereUniqueWithoutSprintInput[]
    updateMany?: BoardUpdateManyWithWhereWithoutSprintInput | BoardUpdateManyWithWhereWithoutSprintInput[]
    deleteMany?: BoardScalarWhereInput | BoardScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutMilestonesInput = {
    create?: XOR<ProjectCreateWithoutMilestonesInput, ProjectUncheckedCreateWithoutMilestonesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMilestonesInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutMilestonesNestedInput = {
    create?: XOR<ProjectCreateWithoutMilestonesInput, ProjectUncheckedCreateWithoutMilestonesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMilestonesInput
    upsert?: ProjectUpsertWithoutMilestonesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutMilestonesInput, ProjectUpdateWithoutMilestonesInput>, ProjectUncheckedUpdateWithoutMilestonesInput>
  }

  export type SprintCreateNestedOneWithoutRetrospectiveInput = {
    create?: XOR<SprintCreateWithoutRetrospectiveInput, SprintUncheckedCreateWithoutRetrospectiveInput>
    connectOrCreate?: SprintCreateOrConnectWithoutRetrospectiveInput
    connect?: SprintWhereUniqueInput
  }

  export type SprintUpdateOneRequiredWithoutRetrospectiveNestedInput = {
    create?: XOR<SprintCreateWithoutRetrospectiveInput, SprintUncheckedCreateWithoutRetrospectiveInput>
    connectOrCreate?: SprintCreateOrConnectWithoutRetrospectiveInput
    upsert?: SprintUpsertWithoutRetrospectiveInput
    connect?: SprintWhereUniqueInput
    update?: XOR<XOR<SprintUpdateToOneWithWhereWithoutRetrospectiveInput, SprintUpdateWithoutRetrospectiveInput>, SprintUncheckedUpdateWithoutRetrospectiveInput>
  }

  export type WorkItemCreateNestedOneWithoutChildrenInput = {
    create?: XOR<WorkItemCreateWithoutChildrenInput, WorkItemUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: WorkItemCreateOrConnectWithoutChildrenInput
    connect?: WorkItemWhereUniqueInput
  }

  export type WorkItemCreateNestedManyWithoutParentInput = {
    create?: XOR<WorkItemCreateWithoutParentInput, WorkItemUncheckedCreateWithoutParentInput> | WorkItemCreateWithoutParentInput[] | WorkItemUncheckedCreateWithoutParentInput[]
    connectOrCreate?: WorkItemCreateOrConnectWithoutParentInput | WorkItemCreateOrConnectWithoutParentInput[]
    createMany?: WorkItemCreateManyParentInputEnvelope
    connect?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
  }

  export type WorkItemCreateNestedOneWithoutStoriesInput = {
    create?: XOR<WorkItemCreateWithoutStoriesInput, WorkItemUncheckedCreateWithoutStoriesInput>
    connectOrCreate?: WorkItemCreateOrConnectWithoutStoriesInput
    connect?: WorkItemWhereUniqueInput
  }

  export type WorkItemCreateNestedManyWithoutEpicInput = {
    create?: XOR<WorkItemCreateWithoutEpicInput, WorkItemUncheckedCreateWithoutEpicInput> | WorkItemCreateWithoutEpicInput[] | WorkItemUncheckedCreateWithoutEpicInput[]
    connectOrCreate?: WorkItemCreateOrConnectWithoutEpicInput | WorkItemCreateOrConnectWithoutEpicInput[]
    createMany?: WorkItemCreateManyEpicInputEnvelope
    connect?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
  }

  export type ProjectCreateNestedOneWithoutWorkItemsInput = {
    create?: XOR<ProjectCreateWithoutWorkItemsInput, ProjectUncheckedCreateWithoutWorkItemsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutWorkItemsInput
    connect?: ProjectWhereUniqueInput
  }

  export type WorkItemStateCreateNestedOneWithoutWorkItemsInput = {
    create?: XOR<WorkItemStateCreateWithoutWorkItemsInput, WorkItemStateUncheckedCreateWithoutWorkItemsInput>
    connectOrCreate?: WorkItemStateCreateOrConnectWithoutWorkItemsInput
    connect?: WorkItemStateWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAssignedWorkItemsInput = {
    create?: XOR<UserCreateWithoutAssignedWorkItemsInput, UserUncheckedCreateWithoutAssignedWorkItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedWorkItemsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedWorkItemsInput = {
    create?: XOR<UserCreateWithoutCreatedWorkItemsInput, UserUncheckedCreateWithoutCreatedWorkItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedWorkItemsInput
    connect?: UserWhereUniqueInput
  }

  export type SprintCreateNestedOneWithoutWorkItemsInput = {
    create?: XOR<SprintCreateWithoutWorkItemsInput, SprintUncheckedCreateWithoutWorkItemsInput>
    connectOrCreate?: SprintCreateOrConnectWithoutWorkItemsInput
    connect?: SprintWhereUniqueInput
  }

  export type WorkItemDetailCreateNestedOneWithoutWorkItemInput = {
    create?: XOR<WorkItemDetailCreateWithoutWorkItemInput, WorkItemDetailUncheckedCreateWithoutWorkItemInput>
    connectOrCreate?: WorkItemDetailCreateOrConnectWithoutWorkItemInput
    connect?: WorkItemDetailWhereUniqueInput
  }

  export type DependencyCreateNestedManyWithoutSourceItemInput = {
    create?: XOR<DependencyCreateWithoutSourceItemInput, DependencyUncheckedCreateWithoutSourceItemInput> | DependencyCreateWithoutSourceItemInput[] | DependencyUncheckedCreateWithoutSourceItemInput[]
    connectOrCreate?: DependencyCreateOrConnectWithoutSourceItemInput | DependencyCreateOrConnectWithoutSourceItemInput[]
    createMany?: DependencyCreateManySourceItemInputEnvelope
    connect?: DependencyWhereUniqueInput | DependencyWhereUniqueInput[]
  }

  export type DependencyCreateNestedManyWithoutTargetItemInput = {
    create?: XOR<DependencyCreateWithoutTargetItemInput, DependencyUncheckedCreateWithoutTargetItemInput> | DependencyCreateWithoutTargetItemInput[] | DependencyUncheckedCreateWithoutTargetItemInput[]
    connectOrCreate?: DependencyCreateOrConnectWithoutTargetItemInput | DependencyCreateOrConnectWithoutTargetItemInput[]
    createMany?: DependencyCreateManyTargetItemInputEnvelope
    connect?: DependencyWhereUniqueInput | DependencyWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutWorkItemInput = {
    create?: XOR<CommentCreateWithoutWorkItemInput, CommentUncheckedCreateWithoutWorkItemInput> | CommentCreateWithoutWorkItemInput[] | CommentUncheckedCreateWithoutWorkItemInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutWorkItemInput | CommentCreateOrConnectWithoutWorkItemInput[]
    createMany?: CommentCreateManyWorkItemInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type AttachmentCreateNestedManyWithoutWorkItemInput = {
    create?: XOR<AttachmentCreateWithoutWorkItemInput, AttachmentUncheckedCreateWithoutWorkItemInput> | AttachmentCreateWithoutWorkItemInput[] | AttachmentUncheckedCreateWithoutWorkItemInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutWorkItemInput | AttachmentCreateOrConnectWithoutWorkItemInput[]
    createMany?: AttachmentCreateManyWorkItemInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type TimeLogCreateNestedManyWithoutWorkItemInput = {
    create?: XOR<TimeLogCreateWithoutWorkItemInput, TimeLogUncheckedCreateWithoutWorkItemInput> | TimeLogCreateWithoutWorkItemInput[] | TimeLogUncheckedCreateWithoutWorkItemInput[]
    connectOrCreate?: TimeLogCreateOrConnectWithoutWorkItemInput | TimeLogCreateOrConnectWithoutWorkItemInput[]
    createMany?: TimeLogCreateManyWorkItemInputEnvelope
    connect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
  }

  export type WorkItemSnapshotCreateNestedManyWithoutWorkItemInput = {
    create?: XOR<WorkItemSnapshotCreateWithoutWorkItemInput, WorkItemSnapshotUncheckedCreateWithoutWorkItemInput> | WorkItemSnapshotCreateWithoutWorkItemInput[] | WorkItemSnapshotUncheckedCreateWithoutWorkItemInput[]
    connectOrCreate?: WorkItemSnapshotCreateOrConnectWithoutWorkItemInput | WorkItemSnapshotCreateOrConnectWithoutWorkItemInput[]
    createMany?: WorkItemSnapshotCreateManyWorkItemInputEnvelope
    connect?: WorkItemSnapshotWhereUniqueInput | WorkItemSnapshotWhereUniqueInput[]
  }

  export type TagOnWorkItemCreateNestedManyWithoutWorkItemInput = {
    create?: XOR<TagOnWorkItemCreateWithoutWorkItemInput, TagOnWorkItemUncheckedCreateWithoutWorkItemInput> | TagOnWorkItemCreateWithoutWorkItemInput[] | TagOnWorkItemUncheckedCreateWithoutWorkItemInput[]
    connectOrCreate?: TagOnWorkItemCreateOrConnectWithoutWorkItemInput | TagOnWorkItemCreateOrConnectWithoutWorkItemInput[]
    createMany?: TagOnWorkItemCreateManyWorkItemInputEnvelope
    connect?: TagOnWorkItemWhereUniqueInput | TagOnWorkItemWhereUniqueInput[]
  }

  export type ComponentOnWorkItemCreateNestedManyWithoutWorkItemInput = {
    create?: XOR<ComponentOnWorkItemCreateWithoutWorkItemInput, ComponentOnWorkItemUncheckedCreateWithoutWorkItemInput> | ComponentOnWorkItemCreateWithoutWorkItemInput[] | ComponentOnWorkItemUncheckedCreateWithoutWorkItemInput[]
    connectOrCreate?: ComponentOnWorkItemCreateOrConnectWithoutWorkItemInput | ComponentOnWorkItemCreateOrConnectWithoutWorkItemInput[]
    createMany?: ComponentOnWorkItemCreateManyWorkItemInputEnvelope
    connect?: ComponentOnWorkItemWhereUniqueInput | ComponentOnWorkItemWhereUniqueInput[]
  }

  export type WorkItemEmbeddingCreateNestedOneWithoutWorkItemInput = {
    connect?: WorkItemEmbeddingWhereUniqueInput
  }

  export type WorkItemUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<WorkItemCreateWithoutParentInput, WorkItemUncheckedCreateWithoutParentInput> | WorkItemCreateWithoutParentInput[] | WorkItemUncheckedCreateWithoutParentInput[]
    connectOrCreate?: WorkItemCreateOrConnectWithoutParentInput | WorkItemCreateOrConnectWithoutParentInput[]
    createMany?: WorkItemCreateManyParentInputEnvelope
    connect?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
  }

  export type WorkItemUncheckedCreateNestedManyWithoutEpicInput = {
    create?: XOR<WorkItemCreateWithoutEpicInput, WorkItemUncheckedCreateWithoutEpicInput> | WorkItemCreateWithoutEpicInput[] | WorkItemUncheckedCreateWithoutEpicInput[]
    connectOrCreate?: WorkItemCreateOrConnectWithoutEpicInput | WorkItemCreateOrConnectWithoutEpicInput[]
    createMany?: WorkItemCreateManyEpicInputEnvelope
    connect?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
  }

  export type WorkItemDetailUncheckedCreateNestedOneWithoutWorkItemInput = {
    create?: XOR<WorkItemDetailCreateWithoutWorkItemInput, WorkItemDetailUncheckedCreateWithoutWorkItemInput>
    connectOrCreate?: WorkItemDetailCreateOrConnectWithoutWorkItemInput
    connect?: WorkItemDetailWhereUniqueInput
  }

  export type DependencyUncheckedCreateNestedManyWithoutSourceItemInput = {
    create?: XOR<DependencyCreateWithoutSourceItemInput, DependencyUncheckedCreateWithoutSourceItemInput> | DependencyCreateWithoutSourceItemInput[] | DependencyUncheckedCreateWithoutSourceItemInput[]
    connectOrCreate?: DependencyCreateOrConnectWithoutSourceItemInput | DependencyCreateOrConnectWithoutSourceItemInput[]
    createMany?: DependencyCreateManySourceItemInputEnvelope
    connect?: DependencyWhereUniqueInput | DependencyWhereUniqueInput[]
  }

  export type DependencyUncheckedCreateNestedManyWithoutTargetItemInput = {
    create?: XOR<DependencyCreateWithoutTargetItemInput, DependencyUncheckedCreateWithoutTargetItemInput> | DependencyCreateWithoutTargetItemInput[] | DependencyUncheckedCreateWithoutTargetItemInput[]
    connectOrCreate?: DependencyCreateOrConnectWithoutTargetItemInput | DependencyCreateOrConnectWithoutTargetItemInput[]
    createMany?: DependencyCreateManyTargetItemInputEnvelope
    connect?: DependencyWhereUniqueInput | DependencyWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutWorkItemInput = {
    create?: XOR<CommentCreateWithoutWorkItemInput, CommentUncheckedCreateWithoutWorkItemInput> | CommentCreateWithoutWorkItemInput[] | CommentUncheckedCreateWithoutWorkItemInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutWorkItemInput | CommentCreateOrConnectWithoutWorkItemInput[]
    createMany?: CommentCreateManyWorkItemInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type AttachmentUncheckedCreateNestedManyWithoutWorkItemInput = {
    create?: XOR<AttachmentCreateWithoutWorkItemInput, AttachmentUncheckedCreateWithoutWorkItemInput> | AttachmentCreateWithoutWorkItemInput[] | AttachmentUncheckedCreateWithoutWorkItemInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutWorkItemInput | AttachmentCreateOrConnectWithoutWorkItemInput[]
    createMany?: AttachmentCreateManyWorkItemInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type TimeLogUncheckedCreateNestedManyWithoutWorkItemInput = {
    create?: XOR<TimeLogCreateWithoutWorkItemInput, TimeLogUncheckedCreateWithoutWorkItemInput> | TimeLogCreateWithoutWorkItemInput[] | TimeLogUncheckedCreateWithoutWorkItemInput[]
    connectOrCreate?: TimeLogCreateOrConnectWithoutWorkItemInput | TimeLogCreateOrConnectWithoutWorkItemInput[]
    createMany?: TimeLogCreateManyWorkItemInputEnvelope
    connect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
  }

  export type WorkItemSnapshotUncheckedCreateNestedManyWithoutWorkItemInput = {
    create?: XOR<WorkItemSnapshotCreateWithoutWorkItemInput, WorkItemSnapshotUncheckedCreateWithoutWorkItemInput> | WorkItemSnapshotCreateWithoutWorkItemInput[] | WorkItemSnapshotUncheckedCreateWithoutWorkItemInput[]
    connectOrCreate?: WorkItemSnapshotCreateOrConnectWithoutWorkItemInput | WorkItemSnapshotCreateOrConnectWithoutWorkItemInput[]
    createMany?: WorkItemSnapshotCreateManyWorkItemInputEnvelope
    connect?: WorkItemSnapshotWhereUniqueInput | WorkItemSnapshotWhereUniqueInput[]
  }

  export type TagOnWorkItemUncheckedCreateNestedManyWithoutWorkItemInput = {
    create?: XOR<TagOnWorkItemCreateWithoutWorkItemInput, TagOnWorkItemUncheckedCreateWithoutWorkItemInput> | TagOnWorkItemCreateWithoutWorkItemInput[] | TagOnWorkItemUncheckedCreateWithoutWorkItemInput[]
    connectOrCreate?: TagOnWorkItemCreateOrConnectWithoutWorkItemInput | TagOnWorkItemCreateOrConnectWithoutWorkItemInput[]
    createMany?: TagOnWorkItemCreateManyWorkItemInputEnvelope
    connect?: TagOnWorkItemWhereUniqueInput | TagOnWorkItemWhereUniqueInput[]
  }

  export type ComponentOnWorkItemUncheckedCreateNestedManyWithoutWorkItemInput = {
    create?: XOR<ComponentOnWorkItemCreateWithoutWorkItemInput, ComponentOnWorkItemUncheckedCreateWithoutWorkItemInput> | ComponentOnWorkItemCreateWithoutWorkItemInput[] | ComponentOnWorkItemUncheckedCreateWithoutWorkItemInput[]
    connectOrCreate?: ComponentOnWorkItemCreateOrConnectWithoutWorkItemInput | ComponentOnWorkItemCreateOrConnectWithoutWorkItemInput[]
    createMany?: ComponentOnWorkItemCreateManyWorkItemInputEnvelope
    connect?: ComponentOnWorkItemWhereUniqueInput | ComponentOnWorkItemWhereUniqueInput[]
  }

  export type WorkItemEmbeddingUncheckedCreateNestedOneWithoutWorkItemInput = {
    connect?: WorkItemEmbeddingWhereUniqueInput
  }

  export type EnumWorkItemTypeFieldUpdateOperationsInput = {
    set?: $Enums.WorkItemType
  }

  export type EnumPriorityFieldUpdateOperationsInput = {
    set?: $Enums.Priority
  }

  export type WorkItemUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<WorkItemCreateWithoutChildrenInput, WorkItemUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: WorkItemCreateOrConnectWithoutChildrenInput
    upsert?: WorkItemUpsertWithoutChildrenInput
    disconnect?: WorkItemWhereInput | boolean
    delete?: WorkItemWhereInput | boolean
    connect?: WorkItemWhereUniqueInput
    update?: XOR<XOR<WorkItemUpdateToOneWithWhereWithoutChildrenInput, WorkItemUpdateWithoutChildrenInput>, WorkItemUncheckedUpdateWithoutChildrenInput>
  }

  export type WorkItemUpdateManyWithoutParentNestedInput = {
    create?: XOR<WorkItemCreateWithoutParentInput, WorkItemUncheckedCreateWithoutParentInput> | WorkItemCreateWithoutParentInput[] | WorkItemUncheckedCreateWithoutParentInput[]
    connectOrCreate?: WorkItemCreateOrConnectWithoutParentInput | WorkItemCreateOrConnectWithoutParentInput[]
    upsert?: WorkItemUpsertWithWhereUniqueWithoutParentInput | WorkItemUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: WorkItemCreateManyParentInputEnvelope
    set?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    disconnect?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    delete?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    connect?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    update?: WorkItemUpdateWithWhereUniqueWithoutParentInput | WorkItemUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: WorkItemUpdateManyWithWhereWithoutParentInput | WorkItemUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: WorkItemScalarWhereInput | WorkItemScalarWhereInput[]
  }

  export type WorkItemUpdateOneWithoutStoriesNestedInput = {
    create?: XOR<WorkItemCreateWithoutStoriesInput, WorkItemUncheckedCreateWithoutStoriesInput>
    connectOrCreate?: WorkItemCreateOrConnectWithoutStoriesInput
    upsert?: WorkItemUpsertWithoutStoriesInput
    disconnect?: WorkItemWhereInput | boolean
    delete?: WorkItemWhereInput | boolean
    connect?: WorkItemWhereUniqueInput
    update?: XOR<XOR<WorkItemUpdateToOneWithWhereWithoutStoriesInput, WorkItemUpdateWithoutStoriesInput>, WorkItemUncheckedUpdateWithoutStoriesInput>
  }

  export type WorkItemUpdateManyWithoutEpicNestedInput = {
    create?: XOR<WorkItemCreateWithoutEpicInput, WorkItemUncheckedCreateWithoutEpicInput> | WorkItemCreateWithoutEpicInput[] | WorkItemUncheckedCreateWithoutEpicInput[]
    connectOrCreate?: WorkItemCreateOrConnectWithoutEpicInput | WorkItemCreateOrConnectWithoutEpicInput[]
    upsert?: WorkItemUpsertWithWhereUniqueWithoutEpicInput | WorkItemUpsertWithWhereUniqueWithoutEpicInput[]
    createMany?: WorkItemCreateManyEpicInputEnvelope
    set?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    disconnect?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    delete?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    connect?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    update?: WorkItemUpdateWithWhereUniqueWithoutEpicInput | WorkItemUpdateWithWhereUniqueWithoutEpicInput[]
    updateMany?: WorkItemUpdateManyWithWhereWithoutEpicInput | WorkItemUpdateManyWithWhereWithoutEpicInput[]
    deleteMany?: WorkItemScalarWhereInput | WorkItemScalarWhereInput[]
  }

  export type ProjectUpdateOneRequiredWithoutWorkItemsNestedInput = {
    create?: XOR<ProjectCreateWithoutWorkItemsInput, ProjectUncheckedCreateWithoutWorkItemsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutWorkItemsInput
    upsert?: ProjectUpsertWithoutWorkItemsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutWorkItemsInput, ProjectUpdateWithoutWorkItemsInput>, ProjectUncheckedUpdateWithoutWorkItemsInput>
  }

  export type WorkItemStateUpdateOneWithoutWorkItemsNestedInput = {
    create?: XOR<WorkItemStateCreateWithoutWorkItemsInput, WorkItemStateUncheckedCreateWithoutWorkItemsInput>
    connectOrCreate?: WorkItemStateCreateOrConnectWithoutWorkItemsInput
    upsert?: WorkItemStateUpsertWithoutWorkItemsInput
    disconnect?: WorkItemStateWhereInput | boolean
    delete?: WorkItemStateWhereInput | boolean
    connect?: WorkItemStateWhereUniqueInput
    update?: XOR<XOR<WorkItemStateUpdateToOneWithWhereWithoutWorkItemsInput, WorkItemStateUpdateWithoutWorkItemsInput>, WorkItemStateUncheckedUpdateWithoutWorkItemsInput>
  }

  export type UserUpdateOneWithoutAssignedWorkItemsNestedInput = {
    create?: XOR<UserCreateWithoutAssignedWorkItemsInput, UserUncheckedCreateWithoutAssignedWorkItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedWorkItemsInput
    upsert?: UserUpsertWithoutAssignedWorkItemsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedWorkItemsInput, UserUpdateWithoutAssignedWorkItemsInput>, UserUncheckedUpdateWithoutAssignedWorkItemsInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedWorkItemsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedWorkItemsInput, UserUncheckedCreateWithoutCreatedWorkItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedWorkItemsInput
    upsert?: UserUpsertWithoutCreatedWorkItemsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedWorkItemsInput, UserUpdateWithoutCreatedWorkItemsInput>, UserUncheckedUpdateWithoutCreatedWorkItemsInput>
  }

  export type SprintUpdateOneWithoutWorkItemsNestedInput = {
    create?: XOR<SprintCreateWithoutWorkItemsInput, SprintUncheckedCreateWithoutWorkItemsInput>
    connectOrCreate?: SprintCreateOrConnectWithoutWorkItemsInput
    upsert?: SprintUpsertWithoutWorkItemsInput
    disconnect?: SprintWhereInput | boolean
    delete?: SprintWhereInput | boolean
    connect?: SprintWhereUniqueInput
    update?: XOR<XOR<SprintUpdateToOneWithWhereWithoutWorkItemsInput, SprintUpdateWithoutWorkItemsInput>, SprintUncheckedUpdateWithoutWorkItemsInput>
  }

  export type WorkItemDetailUpdateOneWithoutWorkItemNestedInput = {
    create?: XOR<WorkItemDetailCreateWithoutWorkItemInput, WorkItemDetailUncheckedCreateWithoutWorkItemInput>
    connectOrCreate?: WorkItemDetailCreateOrConnectWithoutWorkItemInput
    upsert?: WorkItemDetailUpsertWithoutWorkItemInput
    disconnect?: WorkItemDetailWhereInput | boolean
    delete?: WorkItemDetailWhereInput | boolean
    connect?: WorkItemDetailWhereUniqueInput
    update?: XOR<XOR<WorkItemDetailUpdateToOneWithWhereWithoutWorkItemInput, WorkItemDetailUpdateWithoutWorkItemInput>, WorkItemDetailUncheckedUpdateWithoutWorkItemInput>
  }

  export type DependencyUpdateManyWithoutSourceItemNestedInput = {
    create?: XOR<DependencyCreateWithoutSourceItemInput, DependencyUncheckedCreateWithoutSourceItemInput> | DependencyCreateWithoutSourceItemInput[] | DependencyUncheckedCreateWithoutSourceItemInput[]
    connectOrCreate?: DependencyCreateOrConnectWithoutSourceItemInput | DependencyCreateOrConnectWithoutSourceItemInput[]
    upsert?: DependencyUpsertWithWhereUniqueWithoutSourceItemInput | DependencyUpsertWithWhereUniqueWithoutSourceItemInput[]
    createMany?: DependencyCreateManySourceItemInputEnvelope
    set?: DependencyWhereUniqueInput | DependencyWhereUniqueInput[]
    disconnect?: DependencyWhereUniqueInput | DependencyWhereUniqueInput[]
    delete?: DependencyWhereUniqueInput | DependencyWhereUniqueInput[]
    connect?: DependencyWhereUniqueInput | DependencyWhereUniqueInput[]
    update?: DependencyUpdateWithWhereUniqueWithoutSourceItemInput | DependencyUpdateWithWhereUniqueWithoutSourceItemInput[]
    updateMany?: DependencyUpdateManyWithWhereWithoutSourceItemInput | DependencyUpdateManyWithWhereWithoutSourceItemInput[]
    deleteMany?: DependencyScalarWhereInput | DependencyScalarWhereInput[]
  }

  export type DependencyUpdateManyWithoutTargetItemNestedInput = {
    create?: XOR<DependencyCreateWithoutTargetItemInput, DependencyUncheckedCreateWithoutTargetItemInput> | DependencyCreateWithoutTargetItemInput[] | DependencyUncheckedCreateWithoutTargetItemInput[]
    connectOrCreate?: DependencyCreateOrConnectWithoutTargetItemInput | DependencyCreateOrConnectWithoutTargetItemInput[]
    upsert?: DependencyUpsertWithWhereUniqueWithoutTargetItemInput | DependencyUpsertWithWhereUniqueWithoutTargetItemInput[]
    createMany?: DependencyCreateManyTargetItemInputEnvelope
    set?: DependencyWhereUniqueInput | DependencyWhereUniqueInput[]
    disconnect?: DependencyWhereUniqueInput | DependencyWhereUniqueInput[]
    delete?: DependencyWhereUniqueInput | DependencyWhereUniqueInput[]
    connect?: DependencyWhereUniqueInput | DependencyWhereUniqueInput[]
    update?: DependencyUpdateWithWhereUniqueWithoutTargetItemInput | DependencyUpdateWithWhereUniqueWithoutTargetItemInput[]
    updateMany?: DependencyUpdateManyWithWhereWithoutTargetItemInput | DependencyUpdateManyWithWhereWithoutTargetItemInput[]
    deleteMany?: DependencyScalarWhereInput | DependencyScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutWorkItemNestedInput = {
    create?: XOR<CommentCreateWithoutWorkItemInput, CommentUncheckedCreateWithoutWorkItemInput> | CommentCreateWithoutWorkItemInput[] | CommentUncheckedCreateWithoutWorkItemInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutWorkItemInput | CommentCreateOrConnectWithoutWorkItemInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutWorkItemInput | CommentUpsertWithWhereUniqueWithoutWorkItemInput[]
    createMany?: CommentCreateManyWorkItemInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutWorkItemInput | CommentUpdateWithWhereUniqueWithoutWorkItemInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutWorkItemInput | CommentUpdateManyWithWhereWithoutWorkItemInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type AttachmentUpdateManyWithoutWorkItemNestedInput = {
    create?: XOR<AttachmentCreateWithoutWorkItemInput, AttachmentUncheckedCreateWithoutWorkItemInput> | AttachmentCreateWithoutWorkItemInput[] | AttachmentUncheckedCreateWithoutWorkItemInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutWorkItemInput | AttachmentCreateOrConnectWithoutWorkItemInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutWorkItemInput | AttachmentUpsertWithWhereUniqueWithoutWorkItemInput[]
    createMany?: AttachmentCreateManyWorkItemInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutWorkItemInput | AttachmentUpdateWithWhereUniqueWithoutWorkItemInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutWorkItemInput | AttachmentUpdateManyWithWhereWithoutWorkItemInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type TimeLogUpdateManyWithoutWorkItemNestedInput = {
    create?: XOR<TimeLogCreateWithoutWorkItemInput, TimeLogUncheckedCreateWithoutWorkItemInput> | TimeLogCreateWithoutWorkItemInput[] | TimeLogUncheckedCreateWithoutWorkItemInput[]
    connectOrCreate?: TimeLogCreateOrConnectWithoutWorkItemInput | TimeLogCreateOrConnectWithoutWorkItemInput[]
    upsert?: TimeLogUpsertWithWhereUniqueWithoutWorkItemInput | TimeLogUpsertWithWhereUniqueWithoutWorkItemInput[]
    createMany?: TimeLogCreateManyWorkItemInputEnvelope
    set?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    disconnect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    delete?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    connect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    update?: TimeLogUpdateWithWhereUniqueWithoutWorkItemInput | TimeLogUpdateWithWhereUniqueWithoutWorkItemInput[]
    updateMany?: TimeLogUpdateManyWithWhereWithoutWorkItemInput | TimeLogUpdateManyWithWhereWithoutWorkItemInput[]
    deleteMany?: TimeLogScalarWhereInput | TimeLogScalarWhereInput[]
  }

  export type WorkItemSnapshotUpdateManyWithoutWorkItemNestedInput = {
    create?: XOR<WorkItemSnapshotCreateWithoutWorkItemInput, WorkItemSnapshotUncheckedCreateWithoutWorkItemInput> | WorkItemSnapshotCreateWithoutWorkItemInput[] | WorkItemSnapshotUncheckedCreateWithoutWorkItemInput[]
    connectOrCreate?: WorkItemSnapshotCreateOrConnectWithoutWorkItemInput | WorkItemSnapshotCreateOrConnectWithoutWorkItemInput[]
    upsert?: WorkItemSnapshotUpsertWithWhereUniqueWithoutWorkItemInput | WorkItemSnapshotUpsertWithWhereUniqueWithoutWorkItemInput[]
    createMany?: WorkItemSnapshotCreateManyWorkItemInputEnvelope
    set?: WorkItemSnapshotWhereUniqueInput | WorkItemSnapshotWhereUniqueInput[]
    disconnect?: WorkItemSnapshotWhereUniqueInput | WorkItemSnapshotWhereUniqueInput[]
    delete?: WorkItemSnapshotWhereUniqueInput | WorkItemSnapshotWhereUniqueInput[]
    connect?: WorkItemSnapshotWhereUniqueInput | WorkItemSnapshotWhereUniqueInput[]
    update?: WorkItemSnapshotUpdateWithWhereUniqueWithoutWorkItemInput | WorkItemSnapshotUpdateWithWhereUniqueWithoutWorkItemInput[]
    updateMany?: WorkItemSnapshotUpdateManyWithWhereWithoutWorkItemInput | WorkItemSnapshotUpdateManyWithWhereWithoutWorkItemInput[]
    deleteMany?: WorkItemSnapshotScalarWhereInput | WorkItemSnapshotScalarWhereInput[]
  }

  export type TagOnWorkItemUpdateManyWithoutWorkItemNestedInput = {
    create?: XOR<TagOnWorkItemCreateWithoutWorkItemInput, TagOnWorkItemUncheckedCreateWithoutWorkItemInput> | TagOnWorkItemCreateWithoutWorkItemInput[] | TagOnWorkItemUncheckedCreateWithoutWorkItemInput[]
    connectOrCreate?: TagOnWorkItemCreateOrConnectWithoutWorkItemInput | TagOnWorkItemCreateOrConnectWithoutWorkItemInput[]
    upsert?: TagOnWorkItemUpsertWithWhereUniqueWithoutWorkItemInput | TagOnWorkItemUpsertWithWhereUniqueWithoutWorkItemInput[]
    createMany?: TagOnWorkItemCreateManyWorkItemInputEnvelope
    set?: TagOnWorkItemWhereUniqueInput | TagOnWorkItemWhereUniqueInput[]
    disconnect?: TagOnWorkItemWhereUniqueInput | TagOnWorkItemWhereUniqueInput[]
    delete?: TagOnWorkItemWhereUniqueInput | TagOnWorkItemWhereUniqueInput[]
    connect?: TagOnWorkItemWhereUniqueInput | TagOnWorkItemWhereUniqueInput[]
    update?: TagOnWorkItemUpdateWithWhereUniqueWithoutWorkItemInput | TagOnWorkItemUpdateWithWhereUniqueWithoutWorkItemInput[]
    updateMany?: TagOnWorkItemUpdateManyWithWhereWithoutWorkItemInput | TagOnWorkItemUpdateManyWithWhereWithoutWorkItemInput[]
    deleteMany?: TagOnWorkItemScalarWhereInput | TagOnWorkItemScalarWhereInput[]
  }

  export type ComponentOnWorkItemUpdateManyWithoutWorkItemNestedInput = {
    create?: XOR<ComponentOnWorkItemCreateWithoutWorkItemInput, ComponentOnWorkItemUncheckedCreateWithoutWorkItemInput> | ComponentOnWorkItemCreateWithoutWorkItemInput[] | ComponentOnWorkItemUncheckedCreateWithoutWorkItemInput[]
    connectOrCreate?: ComponentOnWorkItemCreateOrConnectWithoutWorkItemInput | ComponentOnWorkItemCreateOrConnectWithoutWorkItemInput[]
    upsert?: ComponentOnWorkItemUpsertWithWhereUniqueWithoutWorkItemInput | ComponentOnWorkItemUpsertWithWhereUniqueWithoutWorkItemInput[]
    createMany?: ComponentOnWorkItemCreateManyWorkItemInputEnvelope
    set?: ComponentOnWorkItemWhereUniqueInput | ComponentOnWorkItemWhereUniqueInput[]
    disconnect?: ComponentOnWorkItemWhereUniqueInput | ComponentOnWorkItemWhereUniqueInput[]
    delete?: ComponentOnWorkItemWhereUniqueInput | ComponentOnWorkItemWhereUniqueInput[]
    connect?: ComponentOnWorkItemWhereUniqueInput | ComponentOnWorkItemWhereUniqueInput[]
    update?: ComponentOnWorkItemUpdateWithWhereUniqueWithoutWorkItemInput | ComponentOnWorkItemUpdateWithWhereUniqueWithoutWorkItemInput[]
    updateMany?: ComponentOnWorkItemUpdateManyWithWhereWithoutWorkItemInput | ComponentOnWorkItemUpdateManyWithWhereWithoutWorkItemInput[]
    deleteMany?: ComponentOnWorkItemScalarWhereInput | ComponentOnWorkItemScalarWhereInput[]
  }

  export type WorkItemEmbeddingUpdateOneWithoutWorkItemNestedInput = {
    disconnect?: WorkItemEmbeddingWhereInput | boolean
    delete?: WorkItemEmbeddingWhereInput | boolean
    connect?: WorkItemEmbeddingWhereUniqueInput
    update?: XOR<XOR<WorkItemEmbeddingUpdateToOneWithWhereWithoutWorkItemInput, WorkItemEmbeddingUpdateWithoutWorkItemInput>, WorkItemEmbeddingUncheckedUpdateWithoutWorkItemInput>
  }

  export type WorkItemUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<WorkItemCreateWithoutParentInput, WorkItemUncheckedCreateWithoutParentInput> | WorkItemCreateWithoutParentInput[] | WorkItemUncheckedCreateWithoutParentInput[]
    connectOrCreate?: WorkItemCreateOrConnectWithoutParentInput | WorkItemCreateOrConnectWithoutParentInput[]
    upsert?: WorkItemUpsertWithWhereUniqueWithoutParentInput | WorkItemUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: WorkItemCreateManyParentInputEnvelope
    set?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    disconnect?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    delete?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    connect?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    update?: WorkItemUpdateWithWhereUniqueWithoutParentInput | WorkItemUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: WorkItemUpdateManyWithWhereWithoutParentInput | WorkItemUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: WorkItemScalarWhereInput | WorkItemScalarWhereInput[]
  }

  export type WorkItemUncheckedUpdateManyWithoutEpicNestedInput = {
    create?: XOR<WorkItemCreateWithoutEpicInput, WorkItemUncheckedCreateWithoutEpicInput> | WorkItemCreateWithoutEpicInput[] | WorkItemUncheckedCreateWithoutEpicInput[]
    connectOrCreate?: WorkItemCreateOrConnectWithoutEpicInput | WorkItemCreateOrConnectWithoutEpicInput[]
    upsert?: WorkItemUpsertWithWhereUniqueWithoutEpicInput | WorkItemUpsertWithWhereUniqueWithoutEpicInput[]
    createMany?: WorkItemCreateManyEpicInputEnvelope
    set?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    disconnect?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    delete?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    connect?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    update?: WorkItemUpdateWithWhereUniqueWithoutEpicInput | WorkItemUpdateWithWhereUniqueWithoutEpicInput[]
    updateMany?: WorkItemUpdateManyWithWhereWithoutEpicInput | WorkItemUpdateManyWithWhereWithoutEpicInput[]
    deleteMany?: WorkItemScalarWhereInput | WorkItemScalarWhereInput[]
  }

  export type WorkItemDetailUncheckedUpdateOneWithoutWorkItemNestedInput = {
    create?: XOR<WorkItemDetailCreateWithoutWorkItemInput, WorkItemDetailUncheckedCreateWithoutWorkItemInput>
    connectOrCreate?: WorkItemDetailCreateOrConnectWithoutWorkItemInput
    upsert?: WorkItemDetailUpsertWithoutWorkItemInput
    disconnect?: WorkItemDetailWhereInput | boolean
    delete?: WorkItemDetailWhereInput | boolean
    connect?: WorkItemDetailWhereUniqueInput
    update?: XOR<XOR<WorkItemDetailUpdateToOneWithWhereWithoutWorkItemInput, WorkItemDetailUpdateWithoutWorkItemInput>, WorkItemDetailUncheckedUpdateWithoutWorkItemInput>
  }

  export type DependencyUncheckedUpdateManyWithoutSourceItemNestedInput = {
    create?: XOR<DependencyCreateWithoutSourceItemInput, DependencyUncheckedCreateWithoutSourceItemInput> | DependencyCreateWithoutSourceItemInput[] | DependencyUncheckedCreateWithoutSourceItemInput[]
    connectOrCreate?: DependencyCreateOrConnectWithoutSourceItemInput | DependencyCreateOrConnectWithoutSourceItemInput[]
    upsert?: DependencyUpsertWithWhereUniqueWithoutSourceItemInput | DependencyUpsertWithWhereUniqueWithoutSourceItemInput[]
    createMany?: DependencyCreateManySourceItemInputEnvelope
    set?: DependencyWhereUniqueInput | DependencyWhereUniqueInput[]
    disconnect?: DependencyWhereUniqueInput | DependencyWhereUniqueInput[]
    delete?: DependencyWhereUniqueInput | DependencyWhereUniqueInput[]
    connect?: DependencyWhereUniqueInput | DependencyWhereUniqueInput[]
    update?: DependencyUpdateWithWhereUniqueWithoutSourceItemInput | DependencyUpdateWithWhereUniqueWithoutSourceItemInput[]
    updateMany?: DependencyUpdateManyWithWhereWithoutSourceItemInput | DependencyUpdateManyWithWhereWithoutSourceItemInput[]
    deleteMany?: DependencyScalarWhereInput | DependencyScalarWhereInput[]
  }

  export type DependencyUncheckedUpdateManyWithoutTargetItemNestedInput = {
    create?: XOR<DependencyCreateWithoutTargetItemInput, DependencyUncheckedCreateWithoutTargetItemInput> | DependencyCreateWithoutTargetItemInput[] | DependencyUncheckedCreateWithoutTargetItemInput[]
    connectOrCreate?: DependencyCreateOrConnectWithoutTargetItemInput | DependencyCreateOrConnectWithoutTargetItemInput[]
    upsert?: DependencyUpsertWithWhereUniqueWithoutTargetItemInput | DependencyUpsertWithWhereUniqueWithoutTargetItemInput[]
    createMany?: DependencyCreateManyTargetItemInputEnvelope
    set?: DependencyWhereUniqueInput | DependencyWhereUniqueInput[]
    disconnect?: DependencyWhereUniqueInput | DependencyWhereUniqueInput[]
    delete?: DependencyWhereUniqueInput | DependencyWhereUniqueInput[]
    connect?: DependencyWhereUniqueInput | DependencyWhereUniqueInput[]
    update?: DependencyUpdateWithWhereUniqueWithoutTargetItemInput | DependencyUpdateWithWhereUniqueWithoutTargetItemInput[]
    updateMany?: DependencyUpdateManyWithWhereWithoutTargetItemInput | DependencyUpdateManyWithWhereWithoutTargetItemInput[]
    deleteMany?: DependencyScalarWhereInput | DependencyScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutWorkItemNestedInput = {
    create?: XOR<CommentCreateWithoutWorkItemInput, CommentUncheckedCreateWithoutWorkItemInput> | CommentCreateWithoutWorkItemInput[] | CommentUncheckedCreateWithoutWorkItemInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutWorkItemInput | CommentCreateOrConnectWithoutWorkItemInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutWorkItemInput | CommentUpsertWithWhereUniqueWithoutWorkItemInput[]
    createMany?: CommentCreateManyWorkItemInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutWorkItemInput | CommentUpdateWithWhereUniqueWithoutWorkItemInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutWorkItemInput | CommentUpdateManyWithWhereWithoutWorkItemInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type AttachmentUncheckedUpdateManyWithoutWorkItemNestedInput = {
    create?: XOR<AttachmentCreateWithoutWorkItemInput, AttachmentUncheckedCreateWithoutWorkItemInput> | AttachmentCreateWithoutWorkItemInput[] | AttachmentUncheckedCreateWithoutWorkItemInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutWorkItemInput | AttachmentCreateOrConnectWithoutWorkItemInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutWorkItemInput | AttachmentUpsertWithWhereUniqueWithoutWorkItemInput[]
    createMany?: AttachmentCreateManyWorkItemInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutWorkItemInput | AttachmentUpdateWithWhereUniqueWithoutWorkItemInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutWorkItemInput | AttachmentUpdateManyWithWhereWithoutWorkItemInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type TimeLogUncheckedUpdateManyWithoutWorkItemNestedInput = {
    create?: XOR<TimeLogCreateWithoutWorkItemInput, TimeLogUncheckedCreateWithoutWorkItemInput> | TimeLogCreateWithoutWorkItemInput[] | TimeLogUncheckedCreateWithoutWorkItemInput[]
    connectOrCreate?: TimeLogCreateOrConnectWithoutWorkItemInput | TimeLogCreateOrConnectWithoutWorkItemInput[]
    upsert?: TimeLogUpsertWithWhereUniqueWithoutWorkItemInput | TimeLogUpsertWithWhereUniqueWithoutWorkItemInput[]
    createMany?: TimeLogCreateManyWorkItemInputEnvelope
    set?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    disconnect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    delete?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    connect?: TimeLogWhereUniqueInput | TimeLogWhereUniqueInput[]
    update?: TimeLogUpdateWithWhereUniqueWithoutWorkItemInput | TimeLogUpdateWithWhereUniqueWithoutWorkItemInput[]
    updateMany?: TimeLogUpdateManyWithWhereWithoutWorkItemInput | TimeLogUpdateManyWithWhereWithoutWorkItemInput[]
    deleteMany?: TimeLogScalarWhereInput | TimeLogScalarWhereInput[]
  }

  export type WorkItemSnapshotUncheckedUpdateManyWithoutWorkItemNestedInput = {
    create?: XOR<WorkItemSnapshotCreateWithoutWorkItemInput, WorkItemSnapshotUncheckedCreateWithoutWorkItemInput> | WorkItemSnapshotCreateWithoutWorkItemInput[] | WorkItemSnapshotUncheckedCreateWithoutWorkItemInput[]
    connectOrCreate?: WorkItemSnapshotCreateOrConnectWithoutWorkItemInput | WorkItemSnapshotCreateOrConnectWithoutWorkItemInput[]
    upsert?: WorkItemSnapshotUpsertWithWhereUniqueWithoutWorkItemInput | WorkItemSnapshotUpsertWithWhereUniqueWithoutWorkItemInput[]
    createMany?: WorkItemSnapshotCreateManyWorkItemInputEnvelope
    set?: WorkItemSnapshotWhereUniqueInput | WorkItemSnapshotWhereUniqueInput[]
    disconnect?: WorkItemSnapshotWhereUniqueInput | WorkItemSnapshotWhereUniqueInput[]
    delete?: WorkItemSnapshotWhereUniqueInput | WorkItemSnapshotWhereUniqueInput[]
    connect?: WorkItemSnapshotWhereUniqueInput | WorkItemSnapshotWhereUniqueInput[]
    update?: WorkItemSnapshotUpdateWithWhereUniqueWithoutWorkItemInput | WorkItemSnapshotUpdateWithWhereUniqueWithoutWorkItemInput[]
    updateMany?: WorkItemSnapshotUpdateManyWithWhereWithoutWorkItemInput | WorkItemSnapshotUpdateManyWithWhereWithoutWorkItemInput[]
    deleteMany?: WorkItemSnapshotScalarWhereInput | WorkItemSnapshotScalarWhereInput[]
  }

  export type TagOnWorkItemUncheckedUpdateManyWithoutWorkItemNestedInput = {
    create?: XOR<TagOnWorkItemCreateWithoutWorkItemInput, TagOnWorkItemUncheckedCreateWithoutWorkItemInput> | TagOnWorkItemCreateWithoutWorkItemInput[] | TagOnWorkItemUncheckedCreateWithoutWorkItemInput[]
    connectOrCreate?: TagOnWorkItemCreateOrConnectWithoutWorkItemInput | TagOnWorkItemCreateOrConnectWithoutWorkItemInput[]
    upsert?: TagOnWorkItemUpsertWithWhereUniqueWithoutWorkItemInput | TagOnWorkItemUpsertWithWhereUniqueWithoutWorkItemInput[]
    createMany?: TagOnWorkItemCreateManyWorkItemInputEnvelope
    set?: TagOnWorkItemWhereUniqueInput | TagOnWorkItemWhereUniqueInput[]
    disconnect?: TagOnWorkItemWhereUniqueInput | TagOnWorkItemWhereUniqueInput[]
    delete?: TagOnWorkItemWhereUniqueInput | TagOnWorkItemWhereUniqueInput[]
    connect?: TagOnWorkItemWhereUniqueInput | TagOnWorkItemWhereUniqueInput[]
    update?: TagOnWorkItemUpdateWithWhereUniqueWithoutWorkItemInput | TagOnWorkItemUpdateWithWhereUniqueWithoutWorkItemInput[]
    updateMany?: TagOnWorkItemUpdateManyWithWhereWithoutWorkItemInput | TagOnWorkItemUpdateManyWithWhereWithoutWorkItemInput[]
    deleteMany?: TagOnWorkItemScalarWhereInput | TagOnWorkItemScalarWhereInput[]
  }

  export type ComponentOnWorkItemUncheckedUpdateManyWithoutWorkItemNestedInput = {
    create?: XOR<ComponentOnWorkItemCreateWithoutWorkItemInput, ComponentOnWorkItemUncheckedCreateWithoutWorkItemInput> | ComponentOnWorkItemCreateWithoutWorkItemInput[] | ComponentOnWorkItemUncheckedCreateWithoutWorkItemInput[]
    connectOrCreate?: ComponentOnWorkItemCreateOrConnectWithoutWorkItemInput | ComponentOnWorkItemCreateOrConnectWithoutWorkItemInput[]
    upsert?: ComponentOnWorkItemUpsertWithWhereUniqueWithoutWorkItemInput | ComponentOnWorkItemUpsertWithWhereUniqueWithoutWorkItemInput[]
    createMany?: ComponentOnWorkItemCreateManyWorkItemInputEnvelope
    set?: ComponentOnWorkItemWhereUniqueInput | ComponentOnWorkItemWhereUniqueInput[]
    disconnect?: ComponentOnWorkItemWhereUniqueInput | ComponentOnWorkItemWhereUniqueInput[]
    delete?: ComponentOnWorkItemWhereUniqueInput | ComponentOnWorkItemWhereUniqueInput[]
    connect?: ComponentOnWorkItemWhereUniqueInput | ComponentOnWorkItemWhereUniqueInput[]
    update?: ComponentOnWorkItemUpdateWithWhereUniqueWithoutWorkItemInput | ComponentOnWorkItemUpdateWithWhereUniqueWithoutWorkItemInput[]
    updateMany?: ComponentOnWorkItemUpdateManyWithWhereWithoutWorkItemInput | ComponentOnWorkItemUpdateManyWithWhereWithoutWorkItemInput[]
    deleteMany?: ComponentOnWorkItemScalarWhereInput | ComponentOnWorkItemScalarWhereInput[]
  }

  export type WorkItemEmbeddingUncheckedUpdateOneWithoutWorkItemNestedInput = {
    disconnect?: WorkItemEmbeddingWhereInput | boolean
    delete?: WorkItemEmbeddingWhereInput | boolean
    connect?: WorkItemEmbeddingWhereUniqueInput
    update?: XOR<XOR<WorkItemEmbeddingUpdateToOneWithWhereWithoutWorkItemInput, WorkItemEmbeddingUpdateWithoutWorkItemInput>, WorkItemEmbeddingUncheckedUpdateWithoutWorkItemInput>
  }

  export type WorkItemCreateNestedOneWithoutDetailsInput = {
    create?: XOR<WorkItemCreateWithoutDetailsInput, WorkItemUncheckedCreateWithoutDetailsInput>
    connectOrCreate?: WorkItemCreateOrConnectWithoutDetailsInput
    connect?: WorkItemWhereUniqueInput
  }

  export type WorkItemUpdateOneRequiredWithoutDetailsNestedInput = {
    create?: XOR<WorkItemCreateWithoutDetailsInput, WorkItemUncheckedCreateWithoutDetailsInput>
    connectOrCreate?: WorkItemCreateOrConnectWithoutDetailsInput
    upsert?: WorkItemUpsertWithoutDetailsInput
    connect?: WorkItemWhereUniqueInput
    update?: XOR<XOR<WorkItemUpdateToOneWithWhereWithoutDetailsInput, WorkItemUpdateWithoutDetailsInput>, WorkItemUncheckedUpdateWithoutDetailsInput>
  }

  export type ProjectCreateNestedOneWithoutWorkItemStatesInput = {
    create?: XOR<ProjectCreateWithoutWorkItemStatesInput, ProjectUncheckedCreateWithoutWorkItemStatesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutWorkItemStatesInput
    connect?: ProjectWhereUniqueInput
  }

  export type WorkItemCreateNestedManyWithoutStateInput = {
    create?: XOR<WorkItemCreateWithoutStateInput, WorkItemUncheckedCreateWithoutStateInput> | WorkItemCreateWithoutStateInput[] | WorkItemUncheckedCreateWithoutStateInput[]
    connectOrCreate?: WorkItemCreateOrConnectWithoutStateInput | WorkItemCreateOrConnectWithoutStateInput[]
    createMany?: WorkItemCreateManyStateInputEnvelope
    connect?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
  }

  export type WorkItemUncheckedCreateNestedManyWithoutStateInput = {
    create?: XOR<WorkItemCreateWithoutStateInput, WorkItemUncheckedCreateWithoutStateInput> | WorkItemCreateWithoutStateInput[] | WorkItemUncheckedCreateWithoutStateInput[]
    connectOrCreate?: WorkItemCreateOrConnectWithoutStateInput | WorkItemCreateOrConnectWithoutStateInput[]
    createMany?: WorkItemCreateManyStateInputEnvelope
    connect?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
  }

  export type EnumWorkItemStateCategoryFieldUpdateOperationsInput = {
    set?: $Enums.WorkItemStateCategory
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProjectUpdateOneRequiredWithoutWorkItemStatesNestedInput = {
    create?: XOR<ProjectCreateWithoutWorkItemStatesInput, ProjectUncheckedCreateWithoutWorkItemStatesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutWorkItemStatesInput
    upsert?: ProjectUpsertWithoutWorkItemStatesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutWorkItemStatesInput, ProjectUpdateWithoutWorkItemStatesInput>, ProjectUncheckedUpdateWithoutWorkItemStatesInput>
  }

  export type WorkItemUpdateManyWithoutStateNestedInput = {
    create?: XOR<WorkItemCreateWithoutStateInput, WorkItemUncheckedCreateWithoutStateInput> | WorkItemCreateWithoutStateInput[] | WorkItemUncheckedCreateWithoutStateInput[]
    connectOrCreate?: WorkItemCreateOrConnectWithoutStateInput | WorkItemCreateOrConnectWithoutStateInput[]
    upsert?: WorkItemUpsertWithWhereUniqueWithoutStateInput | WorkItemUpsertWithWhereUniqueWithoutStateInput[]
    createMany?: WorkItemCreateManyStateInputEnvelope
    set?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    disconnect?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    delete?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    connect?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    update?: WorkItemUpdateWithWhereUniqueWithoutStateInput | WorkItemUpdateWithWhereUniqueWithoutStateInput[]
    updateMany?: WorkItemUpdateManyWithWhereWithoutStateInput | WorkItemUpdateManyWithWhereWithoutStateInput[]
    deleteMany?: WorkItemScalarWhereInput | WorkItemScalarWhereInput[]
  }

  export type WorkItemUncheckedUpdateManyWithoutStateNestedInput = {
    create?: XOR<WorkItemCreateWithoutStateInput, WorkItemUncheckedCreateWithoutStateInput> | WorkItemCreateWithoutStateInput[] | WorkItemUncheckedCreateWithoutStateInput[]
    connectOrCreate?: WorkItemCreateOrConnectWithoutStateInput | WorkItemCreateOrConnectWithoutStateInput[]
    upsert?: WorkItemUpsertWithWhereUniqueWithoutStateInput | WorkItemUpsertWithWhereUniqueWithoutStateInput[]
    createMany?: WorkItemCreateManyStateInputEnvelope
    set?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    disconnect?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    delete?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    connect?: WorkItemWhereUniqueInput | WorkItemWhereUniqueInput[]
    update?: WorkItemUpdateWithWhereUniqueWithoutStateInput | WorkItemUpdateWithWhereUniqueWithoutStateInput[]
    updateMany?: WorkItemUpdateManyWithWhereWithoutStateInput | WorkItemUpdateManyWithWhereWithoutStateInput[]
    deleteMany?: WorkItemScalarWhereInput | WorkItemScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutBoardsInput = {
    create?: XOR<ProjectCreateWithoutBoardsInput, ProjectUncheckedCreateWithoutBoardsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutBoardsInput
    connect?: ProjectWhereUniqueInput
  }

  export type SprintCreateNestedOneWithoutBoardsInput = {
    create?: XOR<SprintCreateWithoutBoardsInput, SprintUncheckedCreateWithoutBoardsInput>
    connectOrCreate?: SprintCreateOrConnectWithoutBoardsInput
    connect?: SprintWhereUniqueInput
  }

  export type BoardLaneCreateNestedManyWithoutBoardInput = {
    create?: XOR<BoardLaneCreateWithoutBoardInput, BoardLaneUncheckedCreateWithoutBoardInput> | BoardLaneCreateWithoutBoardInput[] | BoardLaneUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: BoardLaneCreateOrConnectWithoutBoardInput | BoardLaneCreateOrConnectWithoutBoardInput[]
    createMany?: BoardLaneCreateManyBoardInputEnvelope
    connect?: BoardLaneWhereUniqueInput | BoardLaneWhereUniqueInput[]
  }

  export type BoardLaneUncheckedCreateNestedManyWithoutBoardInput = {
    create?: XOR<BoardLaneCreateWithoutBoardInput, BoardLaneUncheckedCreateWithoutBoardInput> | BoardLaneCreateWithoutBoardInput[] | BoardLaneUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: BoardLaneCreateOrConnectWithoutBoardInput | BoardLaneCreateOrConnectWithoutBoardInput[]
    createMany?: BoardLaneCreateManyBoardInputEnvelope
    connect?: BoardLaneWhereUniqueInput | BoardLaneWhereUniqueInput[]
  }

  export type ProjectUpdateOneRequiredWithoutBoardsNestedInput = {
    create?: XOR<ProjectCreateWithoutBoardsInput, ProjectUncheckedCreateWithoutBoardsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutBoardsInput
    upsert?: ProjectUpsertWithoutBoardsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutBoardsInput, ProjectUpdateWithoutBoardsInput>, ProjectUncheckedUpdateWithoutBoardsInput>
  }

  export type SprintUpdateOneWithoutBoardsNestedInput = {
    create?: XOR<SprintCreateWithoutBoardsInput, SprintUncheckedCreateWithoutBoardsInput>
    connectOrCreate?: SprintCreateOrConnectWithoutBoardsInput
    upsert?: SprintUpsertWithoutBoardsInput
    disconnect?: SprintWhereInput | boolean
    delete?: SprintWhereInput | boolean
    connect?: SprintWhereUniqueInput
    update?: XOR<XOR<SprintUpdateToOneWithWhereWithoutBoardsInput, SprintUpdateWithoutBoardsInput>, SprintUncheckedUpdateWithoutBoardsInput>
  }

  export type BoardLaneUpdateManyWithoutBoardNestedInput = {
    create?: XOR<BoardLaneCreateWithoutBoardInput, BoardLaneUncheckedCreateWithoutBoardInput> | BoardLaneCreateWithoutBoardInput[] | BoardLaneUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: BoardLaneCreateOrConnectWithoutBoardInput | BoardLaneCreateOrConnectWithoutBoardInput[]
    upsert?: BoardLaneUpsertWithWhereUniqueWithoutBoardInput | BoardLaneUpsertWithWhereUniqueWithoutBoardInput[]
    createMany?: BoardLaneCreateManyBoardInputEnvelope
    set?: BoardLaneWhereUniqueInput | BoardLaneWhereUniqueInput[]
    disconnect?: BoardLaneWhereUniqueInput | BoardLaneWhereUniqueInput[]
    delete?: BoardLaneWhereUniqueInput | BoardLaneWhereUniqueInput[]
    connect?: BoardLaneWhereUniqueInput | BoardLaneWhereUniqueInput[]
    update?: BoardLaneUpdateWithWhereUniqueWithoutBoardInput | BoardLaneUpdateWithWhereUniqueWithoutBoardInput[]
    updateMany?: BoardLaneUpdateManyWithWhereWithoutBoardInput | BoardLaneUpdateManyWithWhereWithoutBoardInput[]
    deleteMany?: BoardLaneScalarWhereInput | BoardLaneScalarWhereInput[]
  }

  export type BoardLaneUncheckedUpdateManyWithoutBoardNestedInput = {
    create?: XOR<BoardLaneCreateWithoutBoardInput, BoardLaneUncheckedCreateWithoutBoardInput> | BoardLaneCreateWithoutBoardInput[] | BoardLaneUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: BoardLaneCreateOrConnectWithoutBoardInput | BoardLaneCreateOrConnectWithoutBoardInput[]
    upsert?: BoardLaneUpsertWithWhereUniqueWithoutBoardInput | BoardLaneUpsertWithWhereUniqueWithoutBoardInput[]
    createMany?: BoardLaneCreateManyBoardInputEnvelope
    set?: BoardLaneWhereUniqueInput | BoardLaneWhereUniqueInput[]
    disconnect?: BoardLaneWhereUniqueInput | BoardLaneWhereUniqueInput[]
    delete?: BoardLaneWhereUniqueInput | BoardLaneWhereUniqueInput[]
    connect?: BoardLaneWhereUniqueInput | BoardLaneWhereUniqueInput[]
    update?: BoardLaneUpdateWithWhereUniqueWithoutBoardInput | BoardLaneUpdateWithWhereUniqueWithoutBoardInput[]
    updateMany?: BoardLaneUpdateManyWithWhereWithoutBoardInput | BoardLaneUpdateManyWithWhereWithoutBoardInput[]
    deleteMany?: BoardLaneScalarWhereInput | BoardLaneScalarWhereInput[]
  }

  export type BoardLaneCreatemappedStatesInput = {
    set: string[]
  }

  export type BoardCreateNestedOneWithoutLanesInput = {
    create?: XOR<BoardCreateWithoutLanesInput, BoardUncheckedCreateWithoutLanesInput>
    connectOrCreate?: BoardCreateOrConnectWithoutLanesInput
    connect?: BoardWhereUniqueInput
  }

  export type BoardLaneUpdatemappedStatesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BoardUpdateOneRequiredWithoutLanesNestedInput = {
    create?: XOR<BoardCreateWithoutLanesInput, BoardUncheckedCreateWithoutLanesInput>
    connectOrCreate?: BoardCreateOrConnectWithoutLanesInput
    upsert?: BoardUpsertWithoutLanesInput
    connect?: BoardWhereUniqueInput
    update?: XOR<XOR<BoardUpdateToOneWithWhereWithoutLanesInput, BoardUpdateWithoutLanesInput>, BoardUncheckedUpdateWithoutLanesInput>
  }

  export type TagOnWorkItemCreateNestedManyWithoutTagInput = {
    create?: XOR<TagOnWorkItemCreateWithoutTagInput, TagOnWorkItemUncheckedCreateWithoutTagInput> | TagOnWorkItemCreateWithoutTagInput[] | TagOnWorkItemUncheckedCreateWithoutTagInput[]
    connectOrCreate?: TagOnWorkItemCreateOrConnectWithoutTagInput | TagOnWorkItemCreateOrConnectWithoutTagInput[]
    createMany?: TagOnWorkItemCreateManyTagInputEnvelope
    connect?: TagOnWorkItemWhereUniqueInput | TagOnWorkItemWhereUniqueInput[]
  }

  export type TagOnWorkItemUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<TagOnWorkItemCreateWithoutTagInput, TagOnWorkItemUncheckedCreateWithoutTagInput> | TagOnWorkItemCreateWithoutTagInput[] | TagOnWorkItemUncheckedCreateWithoutTagInput[]
    connectOrCreate?: TagOnWorkItemCreateOrConnectWithoutTagInput | TagOnWorkItemCreateOrConnectWithoutTagInput[]
    createMany?: TagOnWorkItemCreateManyTagInputEnvelope
    connect?: TagOnWorkItemWhereUniqueInput | TagOnWorkItemWhereUniqueInput[]
  }

  export type TagOnWorkItemUpdateManyWithoutTagNestedInput = {
    create?: XOR<TagOnWorkItemCreateWithoutTagInput, TagOnWorkItemUncheckedCreateWithoutTagInput> | TagOnWorkItemCreateWithoutTagInput[] | TagOnWorkItemUncheckedCreateWithoutTagInput[]
    connectOrCreate?: TagOnWorkItemCreateOrConnectWithoutTagInput | TagOnWorkItemCreateOrConnectWithoutTagInput[]
    upsert?: TagOnWorkItemUpsertWithWhereUniqueWithoutTagInput | TagOnWorkItemUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: TagOnWorkItemCreateManyTagInputEnvelope
    set?: TagOnWorkItemWhereUniqueInput | TagOnWorkItemWhereUniqueInput[]
    disconnect?: TagOnWorkItemWhereUniqueInput | TagOnWorkItemWhereUniqueInput[]
    delete?: TagOnWorkItemWhereUniqueInput | TagOnWorkItemWhereUniqueInput[]
    connect?: TagOnWorkItemWhereUniqueInput | TagOnWorkItemWhereUniqueInput[]
    update?: TagOnWorkItemUpdateWithWhereUniqueWithoutTagInput | TagOnWorkItemUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: TagOnWorkItemUpdateManyWithWhereWithoutTagInput | TagOnWorkItemUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: TagOnWorkItemScalarWhereInput | TagOnWorkItemScalarWhereInput[]
  }

  export type TagOnWorkItemUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<TagOnWorkItemCreateWithoutTagInput, TagOnWorkItemUncheckedCreateWithoutTagInput> | TagOnWorkItemCreateWithoutTagInput[] | TagOnWorkItemUncheckedCreateWithoutTagInput[]
    connectOrCreate?: TagOnWorkItemCreateOrConnectWithoutTagInput | TagOnWorkItemCreateOrConnectWithoutTagInput[]
    upsert?: TagOnWorkItemUpsertWithWhereUniqueWithoutTagInput | TagOnWorkItemUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: TagOnWorkItemCreateManyTagInputEnvelope
    set?: TagOnWorkItemWhereUniqueInput | TagOnWorkItemWhereUniqueInput[]
    disconnect?: TagOnWorkItemWhereUniqueInput | TagOnWorkItemWhereUniqueInput[]
    delete?: TagOnWorkItemWhereUniqueInput | TagOnWorkItemWhereUniqueInput[]
    connect?: TagOnWorkItemWhereUniqueInput | TagOnWorkItemWhereUniqueInput[]
    update?: TagOnWorkItemUpdateWithWhereUniqueWithoutTagInput | TagOnWorkItemUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: TagOnWorkItemUpdateManyWithWhereWithoutTagInput | TagOnWorkItemUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: TagOnWorkItemScalarWhereInput | TagOnWorkItemScalarWhereInput[]
  }

  export type WorkItemCreateNestedOneWithoutTagsInput = {
    create?: XOR<WorkItemCreateWithoutTagsInput, WorkItemUncheckedCreateWithoutTagsInput>
    connectOrCreate?: WorkItemCreateOrConnectWithoutTagsInput
    connect?: WorkItemWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutWorkItemsInput = {
    create?: XOR<TagCreateWithoutWorkItemsInput, TagUncheckedCreateWithoutWorkItemsInput>
    connectOrCreate?: TagCreateOrConnectWithoutWorkItemsInput
    connect?: TagWhereUniqueInput
  }

  export type WorkItemUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<WorkItemCreateWithoutTagsInput, WorkItemUncheckedCreateWithoutTagsInput>
    connectOrCreate?: WorkItemCreateOrConnectWithoutTagsInput
    upsert?: WorkItemUpsertWithoutTagsInput
    connect?: WorkItemWhereUniqueInput
    update?: XOR<XOR<WorkItemUpdateToOneWithWhereWithoutTagsInput, WorkItemUpdateWithoutTagsInput>, WorkItemUncheckedUpdateWithoutTagsInput>
  }

  export type TagUpdateOneRequiredWithoutWorkItemsNestedInput = {
    create?: XOR<TagCreateWithoutWorkItemsInput, TagUncheckedCreateWithoutWorkItemsInput>
    connectOrCreate?: TagCreateOrConnectWithoutWorkItemsInput
    upsert?: TagUpsertWithoutWorkItemsInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutWorkItemsInput, TagUpdateWithoutWorkItemsInput>, TagUncheckedUpdateWithoutWorkItemsInput>
  }

  export type ProjectCreateNestedOneWithoutComponentsInput = {
    create?: XOR<ProjectCreateWithoutComponentsInput, ProjectUncheckedCreateWithoutComponentsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutComponentsInput
    connect?: ProjectWhereUniqueInput
  }

  export type ComponentOnWorkItemCreateNestedManyWithoutComponentInput = {
    create?: XOR<ComponentOnWorkItemCreateWithoutComponentInput, ComponentOnWorkItemUncheckedCreateWithoutComponentInput> | ComponentOnWorkItemCreateWithoutComponentInput[] | ComponentOnWorkItemUncheckedCreateWithoutComponentInput[]
    connectOrCreate?: ComponentOnWorkItemCreateOrConnectWithoutComponentInput | ComponentOnWorkItemCreateOrConnectWithoutComponentInput[]
    createMany?: ComponentOnWorkItemCreateManyComponentInputEnvelope
    connect?: ComponentOnWorkItemWhereUniqueInput | ComponentOnWorkItemWhereUniqueInput[]
  }

  export type ComponentOnWorkItemUncheckedCreateNestedManyWithoutComponentInput = {
    create?: XOR<ComponentOnWorkItemCreateWithoutComponentInput, ComponentOnWorkItemUncheckedCreateWithoutComponentInput> | ComponentOnWorkItemCreateWithoutComponentInput[] | ComponentOnWorkItemUncheckedCreateWithoutComponentInput[]
    connectOrCreate?: ComponentOnWorkItemCreateOrConnectWithoutComponentInput | ComponentOnWorkItemCreateOrConnectWithoutComponentInput[]
    createMany?: ComponentOnWorkItemCreateManyComponentInputEnvelope
    connect?: ComponentOnWorkItemWhereUniqueInput | ComponentOnWorkItemWhereUniqueInput[]
  }

  export type ProjectUpdateOneRequiredWithoutComponentsNestedInput = {
    create?: XOR<ProjectCreateWithoutComponentsInput, ProjectUncheckedCreateWithoutComponentsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutComponentsInput
    upsert?: ProjectUpsertWithoutComponentsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutComponentsInput, ProjectUpdateWithoutComponentsInput>, ProjectUncheckedUpdateWithoutComponentsInput>
  }

  export type ComponentOnWorkItemUpdateManyWithoutComponentNestedInput = {
    create?: XOR<ComponentOnWorkItemCreateWithoutComponentInput, ComponentOnWorkItemUncheckedCreateWithoutComponentInput> | ComponentOnWorkItemCreateWithoutComponentInput[] | ComponentOnWorkItemUncheckedCreateWithoutComponentInput[]
    connectOrCreate?: ComponentOnWorkItemCreateOrConnectWithoutComponentInput | ComponentOnWorkItemCreateOrConnectWithoutComponentInput[]
    upsert?: ComponentOnWorkItemUpsertWithWhereUniqueWithoutComponentInput | ComponentOnWorkItemUpsertWithWhereUniqueWithoutComponentInput[]
    createMany?: ComponentOnWorkItemCreateManyComponentInputEnvelope
    set?: ComponentOnWorkItemWhereUniqueInput | ComponentOnWorkItemWhereUniqueInput[]
    disconnect?: ComponentOnWorkItemWhereUniqueInput | ComponentOnWorkItemWhereUniqueInput[]
    delete?: ComponentOnWorkItemWhereUniqueInput | ComponentOnWorkItemWhereUniqueInput[]
    connect?: ComponentOnWorkItemWhereUniqueInput | ComponentOnWorkItemWhereUniqueInput[]
    update?: ComponentOnWorkItemUpdateWithWhereUniqueWithoutComponentInput | ComponentOnWorkItemUpdateWithWhereUniqueWithoutComponentInput[]
    updateMany?: ComponentOnWorkItemUpdateManyWithWhereWithoutComponentInput | ComponentOnWorkItemUpdateManyWithWhereWithoutComponentInput[]
    deleteMany?: ComponentOnWorkItemScalarWhereInput | ComponentOnWorkItemScalarWhereInput[]
  }

  export type ComponentOnWorkItemUncheckedUpdateManyWithoutComponentNestedInput = {
    create?: XOR<ComponentOnWorkItemCreateWithoutComponentInput, ComponentOnWorkItemUncheckedCreateWithoutComponentInput> | ComponentOnWorkItemCreateWithoutComponentInput[] | ComponentOnWorkItemUncheckedCreateWithoutComponentInput[]
    connectOrCreate?: ComponentOnWorkItemCreateOrConnectWithoutComponentInput | ComponentOnWorkItemCreateOrConnectWithoutComponentInput[]
    upsert?: ComponentOnWorkItemUpsertWithWhereUniqueWithoutComponentInput | ComponentOnWorkItemUpsertWithWhereUniqueWithoutComponentInput[]
    createMany?: ComponentOnWorkItemCreateManyComponentInputEnvelope
    set?: ComponentOnWorkItemWhereUniqueInput | ComponentOnWorkItemWhereUniqueInput[]
    disconnect?: ComponentOnWorkItemWhereUniqueInput | ComponentOnWorkItemWhereUniqueInput[]
    delete?: ComponentOnWorkItemWhereUniqueInput | ComponentOnWorkItemWhereUniqueInput[]
    connect?: ComponentOnWorkItemWhereUniqueInput | ComponentOnWorkItemWhereUniqueInput[]
    update?: ComponentOnWorkItemUpdateWithWhereUniqueWithoutComponentInput | ComponentOnWorkItemUpdateWithWhereUniqueWithoutComponentInput[]
    updateMany?: ComponentOnWorkItemUpdateManyWithWhereWithoutComponentInput | ComponentOnWorkItemUpdateManyWithWhereWithoutComponentInput[]
    deleteMany?: ComponentOnWorkItemScalarWhereInput | ComponentOnWorkItemScalarWhereInput[]
  }

  export type WorkItemCreateNestedOneWithoutComponentsInput = {
    create?: XOR<WorkItemCreateWithoutComponentsInput, WorkItemUncheckedCreateWithoutComponentsInput>
    connectOrCreate?: WorkItemCreateOrConnectWithoutComponentsInput
    connect?: WorkItemWhereUniqueInput
  }

  export type ComponentCreateNestedOneWithoutWorkItemsInput = {
    create?: XOR<ComponentCreateWithoutWorkItemsInput, ComponentUncheckedCreateWithoutWorkItemsInput>
    connectOrCreate?: ComponentCreateOrConnectWithoutWorkItemsInput
    connect?: ComponentWhereUniqueInput
  }

  export type WorkItemUpdateOneRequiredWithoutComponentsNestedInput = {
    create?: XOR<WorkItemCreateWithoutComponentsInput, WorkItemUncheckedCreateWithoutComponentsInput>
    connectOrCreate?: WorkItemCreateOrConnectWithoutComponentsInput
    upsert?: WorkItemUpsertWithoutComponentsInput
    connect?: WorkItemWhereUniqueInput
    update?: XOR<XOR<WorkItemUpdateToOneWithWhereWithoutComponentsInput, WorkItemUpdateWithoutComponentsInput>, WorkItemUncheckedUpdateWithoutComponentsInput>
  }

  export type ComponentUpdateOneRequiredWithoutWorkItemsNestedInput = {
    create?: XOR<ComponentCreateWithoutWorkItemsInput, ComponentUncheckedCreateWithoutWorkItemsInput>
    connectOrCreate?: ComponentCreateOrConnectWithoutWorkItemsInput
    upsert?: ComponentUpsertWithoutWorkItemsInput
    connect?: ComponentWhereUniqueInput
    update?: XOR<XOR<ComponentUpdateToOneWithWhereWithoutWorkItemsInput, ComponentUpdateWithoutWorkItemsInput>, ComponentUncheckedUpdateWithoutWorkItemsInput>
  }

  export type WorkItemCreateNestedOneWithoutDependenciesAsSourceInput = {
    create?: XOR<WorkItemCreateWithoutDependenciesAsSourceInput, WorkItemUncheckedCreateWithoutDependenciesAsSourceInput>
    connectOrCreate?: WorkItemCreateOrConnectWithoutDependenciesAsSourceInput
    connect?: WorkItemWhereUniqueInput
  }

  export type WorkItemCreateNestedOneWithoutDependenciesAsTargetInput = {
    create?: XOR<WorkItemCreateWithoutDependenciesAsTargetInput, WorkItemUncheckedCreateWithoutDependenciesAsTargetInput>
    connectOrCreate?: WorkItemCreateOrConnectWithoutDependenciesAsTargetInput
    connect?: WorkItemWhereUniqueInput
  }

  export type WorkItemUpdateOneRequiredWithoutDependenciesAsSourceNestedInput = {
    create?: XOR<WorkItemCreateWithoutDependenciesAsSourceInput, WorkItemUncheckedCreateWithoutDependenciesAsSourceInput>
    connectOrCreate?: WorkItemCreateOrConnectWithoutDependenciesAsSourceInput
    upsert?: WorkItemUpsertWithoutDependenciesAsSourceInput
    connect?: WorkItemWhereUniqueInput
    update?: XOR<XOR<WorkItemUpdateToOneWithWhereWithoutDependenciesAsSourceInput, WorkItemUpdateWithoutDependenciesAsSourceInput>, WorkItemUncheckedUpdateWithoutDependenciesAsSourceInput>
  }

  export type WorkItemUpdateOneRequiredWithoutDependenciesAsTargetNestedInput = {
    create?: XOR<WorkItemCreateWithoutDependenciesAsTargetInput, WorkItemUncheckedCreateWithoutDependenciesAsTargetInput>
    connectOrCreate?: WorkItemCreateOrConnectWithoutDependenciesAsTargetInput
    upsert?: WorkItemUpsertWithoutDependenciesAsTargetInput
    connect?: WorkItemWhereUniqueInput
    update?: XOR<XOR<WorkItemUpdateToOneWithWhereWithoutDependenciesAsTargetInput, WorkItemUpdateWithoutDependenciesAsTargetInput>, WorkItemUncheckedUpdateWithoutDependenciesAsTargetInput>
  }

  export type WorkItemCreateNestedOneWithoutTimeLogsInput = {
    create?: XOR<WorkItemCreateWithoutTimeLogsInput, WorkItemUncheckedCreateWithoutTimeLogsInput>
    connectOrCreate?: WorkItemCreateOrConnectWithoutTimeLogsInput
    connect?: WorkItemWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTimeLogsInput = {
    create?: XOR<UserCreateWithoutTimeLogsInput, UserUncheckedCreateWithoutTimeLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTimeLogsInput
    connect?: UserWhereUniqueInput
  }

  export type SprintCreateNestedOneWithoutTimeLogsInput = {
    create?: XOR<SprintCreateWithoutTimeLogsInput, SprintUncheckedCreateWithoutTimeLogsInput>
    connectOrCreate?: SprintCreateOrConnectWithoutTimeLogsInput
    connect?: SprintWhereUniqueInput
  }

  export type WorkItemUpdateOneRequiredWithoutTimeLogsNestedInput = {
    create?: XOR<WorkItemCreateWithoutTimeLogsInput, WorkItemUncheckedCreateWithoutTimeLogsInput>
    connectOrCreate?: WorkItemCreateOrConnectWithoutTimeLogsInput
    upsert?: WorkItemUpsertWithoutTimeLogsInput
    connect?: WorkItemWhereUniqueInput
    update?: XOR<XOR<WorkItemUpdateToOneWithWhereWithoutTimeLogsInput, WorkItemUpdateWithoutTimeLogsInput>, WorkItemUncheckedUpdateWithoutTimeLogsInput>
  }

  export type UserUpdateOneRequiredWithoutTimeLogsNestedInput = {
    create?: XOR<UserCreateWithoutTimeLogsInput, UserUncheckedCreateWithoutTimeLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTimeLogsInput
    upsert?: UserUpsertWithoutTimeLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTimeLogsInput, UserUpdateWithoutTimeLogsInput>, UserUncheckedUpdateWithoutTimeLogsInput>
  }

  export type SprintUpdateOneWithoutTimeLogsNestedInput = {
    create?: XOR<SprintCreateWithoutTimeLogsInput, SprintUncheckedCreateWithoutTimeLogsInput>
    connectOrCreate?: SprintCreateOrConnectWithoutTimeLogsInput
    upsert?: SprintUpsertWithoutTimeLogsInput
    disconnect?: SprintWhereInput | boolean
    delete?: SprintWhereInput | boolean
    connect?: SprintWhereUniqueInput
    update?: XOR<XOR<SprintUpdateToOneWithWhereWithoutTimeLogsInput, SprintUpdateWithoutTimeLogsInput>, SprintUncheckedUpdateWithoutTimeLogsInput>
  }

  export type WorkItemCreateNestedOneWithoutCommentsInput = {
    create?: XOR<WorkItemCreateWithoutCommentsInput, WorkItemUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: WorkItemCreateOrConnectWithoutCommentsInput
    connect?: WorkItemWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type WorkItemUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<WorkItemCreateWithoutCommentsInput, WorkItemUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: WorkItemCreateOrConnectWithoutCommentsInput
    upsert?: WorkItemUpsertWithoutCommentsInput
    connect?: WorkItemWhereUniqueInput
    update?: XOR<XOR<WorkItemUpdateToOneWithWhereWithoutCommentsInput, WorkItemUpdateWithoutCommentsInput>, WorkItemUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    upsert?: UserUpsertWithoutCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentsInput, UserUpdateWithoutCommentsInput>, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type WorkItemCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<WorkItemCreateWithoutAttachmentsInput, WorkItemUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: WorkItemCreateOrConnectWithoutAttachmentsInput
    connect?: WorkItemWhereUniqueInput
  }

  export type WorkItemUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<WorkItemCreateWithoutAttachmentsInput, WorkItemUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: WorkItemCreateOrConnectWithoutAttachmentsInput
    upsert?: WorkItemUpsertWithoutAttachmentsInput
    connect?: WorkItemWhereUniqueInput
    update?: XOR<XOR<WorkItemUpdateToOneWithWhereWithoutAttachmentsInput, WorkItemUpdateWithoutAttachmentsInput>, WorkItemUncheckedUpdateWithoutAttachmentsInput>
  }

  export type WorkItemUpdateOneRequiredWithoutEmbeddingNestedInput = {
    create?: XOR<WorkItemCreateWithoutEmbeddingInput, WorkItemUncheckedCreateWithoutEmbeddingInput>
    connectOrCreate?: WorkItemCreateOrConnectWithoutEmbeddingInput
    upsert?: WorkItemUpsertWithoutEmbeddingInput
    connect?: WorkItemWhereUniqueInput
    update?: XOR<XOR<WorkItemUpdateToOneWithWhereWithoutEmbeddingInput, WorkItemUpdateWithoutEmbeddingInput>, WorkItemUncheckedUpdateWithoutEmbeddingInput>
  }

  export type WorkItemSnapshotCreateblockerIdsInput = {
    set: string[]
  }

  export type WorkItemCreateNestedOneWithoutSnapshotsInput = {
    create?: XOR<WorkItemCreateWithoutSnapshotsInput, WorkItemUncheckedCreateWithoutSnapshotsInput>
    connectOrCreate?: WorkItemCreateOrConnectWithoutSnapshotsInput
    connect?: WorkItemWhereUniqueInput
  }

  export type SprintCreateNestedOneWithoutSnapshotsInput = {
    create?: XOR<SprintCreateWithoutSnapshotsInput, SprintUncheckedCreateWithoutSnapshotsInput>
    connectOrCreate?: SprintCreateOrConnectWithoutSnapshotsInput
    connect?: SprintWhereUniqueInput
  }

  export type WorkItemSnapshotUpdateblockerIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type WorkItemUpdateOneRequiredWithoutSnapshotsNestedInput = {
    create?: XOR<WorkItemCreateWithoutSnapshotsInput, WorkItemUncheckedCreateWithoutSnapshotsInput>
    connectOrCreate?: WorkItemCreateOrConnectWithoutSnapshotsInput
    upsert?: WorkItemUpsertWithoutSnapshotsInput
    connect?: WorkItemWhereUniqueInput
    update?: XOR<XOR<WorkItemUpdateToOneWithWhereWithoutSnapshotsInput, WorkItemUpdateWithoutSnapshotsInput>, WorkItemUncheckedUpdateWithoutSnapshotsInput>
  }

  export type SprintUpdateOneWithoutSnapshotsNestedInput = {
    create?: XOR<SprintCreateWithoutSnapshotsInput, SprintUncheckedCreateWithoutSnapshotsInput>
    connectOrCreate?: SprintCreateOrConnectWithoutSnapshotsInput
    upsert?: SprintUpsertWithoutSnapshotsInput
    disconnect?: SprintWhereInput | boolean
    delete?: SprintWhereInput | boolean
    connect?: SprintWhereUniqueInput
    update?: XOR<XOR<SprintUpdateToOneWithWhereWithoutSnapshotsInput, SprintUpdateWithoutSnapshotsInput>, SprintUncheckedUpdateWithoutSnapshotsInput>
  }

  export type UserSkillProfileCreateskillsInput = {
    set: string[]
  }

  export type UserSkillProfileCreatecertifiedSkillsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutSkillProfileInput = {
    create?: XOR<UserCreateWithoutSkillProfileInput, UserUncheckedCreateWithoutSkillProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutSkillProfileInput
    connect?: UserWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutSkillProfilesInput = {
    create?: XOR<TeamCreateWithoutSkillProfilesInput, TeamUncheckedCreateWithoutSkillProfilesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutSkillProfilesInput
    connect?: TeamWhereUniqueInput
  }

  export type UserSkillProfileUpdateskillsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserSkillProfileUpdatecertifiedSkillsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutSkillProfileNestedInput = {
    create?: XOR<UserCreateWithoutSkillProfileInput, UserUncheckedCreateWithoutSkillProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutSkillProfileInput
    upsert?: UserUpsertWithoutSkillProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSkillProfileInput, UserUpdateWithoutSkillProfileInput>, UserUncheckedUpdateWithoutSkillProfileInput>
  }

  export type TeamUpdateOneWithoutSkillProfilesNestedInput = {
    create?: XOR<TeamCreateWithoutSkillProfilesInput, TeamUncheckedCreateWithoutSkillProfilesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutSkillProfilesInput
    upsert?: TeamUpsertWithoutSkillProfilesInput
    disconnect?: TeamWhereInput | boolean
    delete?: TeamWhereInput | boolean
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutSkillProfilesInput, TeamUpdateWithoutSkillProfilesInput>, TeamUncheckedUpdateWithoutSkillProfilesInput>
  }

  export type ProjectCreateNestedOneWithoutWorkflowRulesInput = {
    create?: XOR<ProjectCreateWithoutWorkflowRulesInput, ProjectUncheckedCreateWithoutWorkflowRulesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutWorkflowRulesInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutWorkflowRulesNestedInput = {
    create?: XOR<ProjectCreateWithoutWorkflowRulesInput, ProjectUncheckedCreateWithoutWorkflowRulesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutWorkflowRulesInput
    upsert?: ProjectUpsertWithoutWorkflowRulesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutWorkflowRulesInput, ProjectUpdateWithoutWorkflowRulesInput>, ProjectUncheckedUpdateWithoutWorkflowRulesInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumWorkItemTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkItemType | EnumWorkItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkItemType[] | ListEnumWorkItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkItemType[] | ListEnumWorkItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkItemTypeFilter<$PrismaModel> | $Enums.WorkItemType
  }

  export type NestedEnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type NestedEnumWorkItemTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkItemType | EnumWorkItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkItemType[] | ListEnumWorkItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkItemType[] | ListEnumWorkItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkItemTypeWithAggregatesFilter<$PrismaModel> | $Enums.WorkItemType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkItemTypeFilter<$PrismaModel>
    _max?: NestedEnumWorkItemTypeFilter<$PrismaModel>
  }

  export type NestedEnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type NestedEnumWorkItemStateCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkItemStateCategory | EnumWorkItemStateCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.WorkItemStateCategory[] | ListEnumWorkItemStateCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkItemStateCategory[] | ListEnumWorkItemStateCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkItemStateCategoryFilter<$PrismaModel> | $Enums.WorkItemStateCategory
  }

  export type NestedEnumWorkItemStateCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkItemStateCategory | EnumWorkItemStateCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.WorkItemStateCategory[] | ListEnumWorkItemStateCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkItemStateCategory[] | ListEnumWorkItemStateCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkItemStateCategoryWithAggregatesFilter<$PrismaModel> | $Enums.WorkItemStateCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkItemStateCategoryFilter<$PrismaModel>
    _max?: NestedEnumWorkItemStateCategoryFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type SessionCreateWithoutUserInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutUserInput = {
    id: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationMembershipCreateWithoutUserInput = {
    id?: string
    role?: string
    joinedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutUsersInput
  }

  export type OrganizationMembershipUncheckedCreateWithoutUserInput = {
    id?: string
    organizationId: string
    role?: string
    joinedAt?: Date | string
  }

  export type OrganizationMembershipCreateOrConnectWithoutUserInput = {
    where: OrganizationMembershipWhereUniqueInput
    create: XOR<OrganizationMembershipCreateWithoutUserInput, OrganizationMembershipUncheckedCreateWithoutUserInput>
  }

  export type OrganizationMembershipCreateManyUserInputEnvelope = {
    data: OrganizationMembershipCreateManyUserInput | OrganizationMembershipCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TeamMembershipCreateWithoutUserInput = {
    id?: string
    joinedAt?: Date | string
    leftAt?: Date | string | null
    team: TeamCreateNestedOneWithoutMembersInput
    role?: RoleCreateNestedOneWithoutTeamMembershipsInput
  }

  export type TeamMembershipUncheckedCreateWithoutUserInput = {
    id?: string
    teamId: string
    roleId?: string | null
    joinedAt?: Date | string
    leftAt?: Date | string | null
  }

  export type TeamMembershipCreateOrConnectWithoutUserInput = {
    where: TeamMembershipWhereUniqueInput
    create: XOR<TeamMembershipCreateWithoutUserInput, TeamMembershipUncheckedCreateWithoutUserInput>
  }

  export type TeamMembershipCreateManyUserInputEnvelope = {
    data: TeamMembershipCreateManyUserInput | TeamMembershipCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutLeadUserInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    projectType?: string
    riskScore?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    portfolio?: PortfolioCreateNestedOneWithoutProjectsInput
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    workItems?: WorkItemCreateNestedManyWithoutProjectInput
    sprints?: SprintCreateNestedManyWithoutProjectInput
    milestones?: MilestoneCreateNestedManyWithoutProjectInput
    boards?: BoardCreateNestedManyWithoutProjectInput
    workflowRules?: WorkflowRuleCreateNestedManyWithoutProjectInput
    workItemStates?: WorkItemStateCreateNestedManyWithoutProjectInput
    components?: ComponentCreateNestedManyWithoutProjectInput
    teams?: TeamCreateNestedManyWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutLeadUserInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    projectType?: string
    riskScore?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    portfolioId?: string | null
    organizationId: string
    workItems?: WorkItemUncheckedCreateNestedManyWithoutProjectInput
    sprints?: SprintUncheckedCreateNestedManyWithoutProjectInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutProjectInput
    boards?: BoardUncheckedCreateNestedManyWithoutProjectInput
    workflowRules?: WorkflowRuleUncheckedCreateNestedManyWithoutProjectInput
    workItemStates?: WorkItemStateUncheckedCreateNestedManyWithoutProjectInput
    components?: ComponentUncheckedCreateNestedManyWithoutProjectInput
    teams?: TeamUncheckedCreateNestedManyWithoutProjectsInput
  }

  export type ProjectCreateOrConnectWithoutLeadUserInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutLeadUserInput, ProjectUncheckedCreateWithoutLeadUserInput>
  }

  export type ProjectCreateManyLeadUserInputEnvelope = {
    data: ProjectCreateManyLeadUserInput | ProjectCreateManyLeadUserInput[]
    skipDuplicates?: boolean
  }

  export type WorkItemCreateWithoutAssigneeInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.WorkItemType
    priority?: $Enums.Priority
    storyPoints?: number | null
    estimatedHours?: number | null
    remainingHours?: number | null
    order?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: WorkItemCreateNestedOneWithoutChildrenInput
    children?: WorkItemCreateNestedManyWithoutParentInput
    epic?: WorkItemCreateNestedOneWithoutStoriesInput
    stories?: WorkItemCreateNestedManyWithoutEpicInput
    project: ProjectCreateNestedOneWithoutWorkItemsInput
    state?: WorkItemStateCreateNestedOneWithoutWorkItemsInput
    creator: UserCreateNestedOneWithoutCreatedWorkItemsInput
    sprint?: SprintCreateNestedOneWithoutWorkItemsInput
    details?: WorkItemDetailCreateNestedOneWithoutWorkItemInput
    dependenciesAsSource?: DependencyCreateNestedManyWithoutSourceItemInput
    dependenciesAsTarget?: DependencyCreateNestedManyWithoutTargetItemInput
    comments?: CommentCreateNestedManyWithoutWorkItemInput
    attachments?: AttachmentCreateNestedManyWithoutWorkItemInput
    timeLogs?: TimeLogCreateNestedManyWithoutWorkItemInput
    snapshots?: WorkItemSnapshotCreateNestedManyWithoutWorkItemInput
    tags?: TagOnWorkItemCreateNestedManyWithoutWorkItemInput
    components?: ComponentOnWorkItemCreateNestedManyWithoutWorkItemInput
    embedding?: WorkItemEmbeddingCreateNestedOneWithoutWorkItemInput
  }

  export type WorkItemUncheckedCreateWithoutAssigneeInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.WorkItemType
    priority?: $Enums.Priority
    storyPoints?: number | null
    estimatedHours?: number | null
    remainingHours?: number | null
    order?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    epicId?: string | null
    projectId: string
    stateId?: string | null
    creatorId: string
    sprintId?: string | null
    children?: WorkItemUncheckedCreateNestedManyWithoutParentInput
    stories?: WorkItemUncheckedCreateNestedManyWithoutEpicInput
    details?: WorkItemDetailUncheckedCreateNestedOneWithoutWorkItemInput
    dependenciesAsSource?: DependencyUncheckedCreateNestedManyWithoutSourceItemInput
    dependenciesAsTarget?: DependencyUncheckedCreateNestedManyWithoutTargetItemInput
    comments?: CommentUncheckedCreateNestedManyWithoutWorkItemInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutWorkItemInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutWorkItemInput
    snapshots?: WorkItemSnapshotUncheckedCreateNestedManyWithoutWorkItemInput
    tags?: TagOnWorkItemUncheckedCreateNestedManyWithoutWorkItemInput
    components?: ComponentOnWorkItemUncheckedCreateNestedManyWithoutWorkItemInput
    embedding?: WorkItemEmbeddingUncheckedCreateNestedOneWithoutWorkItemInput
  }

  export type WorkItemCreateOrConnectWithoutAssigneeInput = {
    where: WorkItemWhereUniqueInput
    create: XOR<WorkItemCreateWithoutAssigneeInput, WorkItemUncheckedCreateWithoutAssigneeInput>
  }

  export type WorkItemCreateManyAssigneeInputEnvelope = {
    data: WorkItemCreateManyAssigneeInput | WorkItemCreateManyAssigneeInput[]
    skipDuplicates?: boolean
  }

  export type WorkItemCreateWithoutCreatorInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.WorkItemType
    priority?: $Enums.Priority
    storyPoints?: number | null
    estimatedHours?: number | null
    remainingHours?: number | null
    order?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: WorkItemCreateNestedOneWithoutChildrenInput
    children?: WorkItemCreateNestedManyWithoutParentInput
    epic?: WorkItemCreateNestedOneWithoutStoriesInput
    stories?: WorkItemCreateNestedManyWithoutEpicInput
    project: ProjectCreateNestedOneWithoutWorkItemsInput
    state?: WorkItemStateCreateNestedOneWithoutWorkItemsInput
    assignee?: UserCreateNestedOneWithoutAssignedWorkItemsInput
    sprint?: SprintCreateNestedOneWithoutWorkItemsInput
    details?: WorkItemDetailCreateNestedOneWithoutWorkItemInput
    dependenciesAsSource?: DependencyCreateNestedManyWithoutSourceItemInput
    dependenciesAsTarget?: DependencyCreateNestedManyWithoutTargetItemInput
    comments?: CommentCreateNestedManyWithoutWorkItemInput
    attachments?: AttachmentCreateNestedManyWithoutWorkItemInput
    timeLogs?: TimeLogCreateNestedManyWithoutWorkItemInput
    snapshots?: WorkItemSnapshotCreateNestedManyWithoutWorkItemInput
    tags?: TagOnWorkItemCreateNestedManyWithoutWorkItemInput
    components?: ComponentOnWorkItemCreateNestedManyWithoutWorkItemInput
    embedding?: WorkItemEmbeddingCreateNestedOneWithoutWorkItemInput
  }

  export type WorkItemUncheckedCreateWithoutCreatorInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.WorkItemType
    priority?: $Enums.Priority
    storyPoints?: number | null
    estimatedHours?: number | null
    remainingHours?: number | null
    order?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    epicId?: string | null
    projectId: string
    stateId?: string | null
    assigneeId?: string | null
    sprintId?: string | null
    children?: WorkItemUncheckedCreateNestedManyWithoutParentInput
    stories?: WorkItemUncheckedCreateNestedManyWithoutEpicInput
    details?: WorkItemDetailUncheckedCreateNestedOneWithoutWorkItemInput
    dependenciesAsSource?: DependencyUncheckedCreateNestedManyWithoutSourceItemInput
    dependenciesAsTarget?: DependencyUncheckedCreateNestedManyWithoutTargetItemInput
    comments?: CommentUncheckedCreateNestedManyWithoutWorkItemInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutWorkItemInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutWorkItemInput
    snapshots?: WorkItemSnapshotUncheckedCreateNestedManyWithoutWorkItemInput
    tags?: TagOnWorkItemUncheckedCreateNestedManyWithoutWorkItemInput
    components?: ComponentOnWorkItemUncheckedCreateNestedManyWithoutWorkItemInput
    embedding?: WorkItemEmbeddingUncheckedCreateNestedOneWithoutWorkItemInput
  }

  export type WorkItemCreateOrConnectWithoutCreatorInput = {
    where: WorkItemWhereUniqueInput
    create: XOR<WorkItemCreateWithoutCreatorInput, WorkItemUncheckedCreateWithoutCreatorInput>
  }

  export type WorkItemCreateManyCreatorInputEnvelope = {
    data: WorkItemCreateManyCreatorInput | WorkItemCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutUserInput = {
    id?: string
    body: string
    sentimentScore?: number | null
    sentimentLabel?: string | null
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workItem: WorkItemCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutUserInput = {
    id?: string
    body: string
    sentimentScore?: number | null
    sentimentLabel?: string | null
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workItemId: string
  }

  export type CommentCreateOrConnectWithoutUserInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentCreateManyUserInputEnvelope = {
    data: CommentCreateManyUserInput | CommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TimeLogCreateWithoutUserInput = {
    id?: string
    duration: number
    description?: string | null
    billable?: boolean
    logDate: Date | string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workItem: WorkItemCreateNestedOneWithoutTimeLogsInput
    sprint?: SprintCreateNestedOneWithoutTimeLogsInput
  }

  export type TimeLogUncheckedCreateWithoutUserInput = {
    id?: string
    duration: number
    description?: string | null
    billable?: boolean
    logDate: Date | string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workItemId: string
    sprintId?: string | null
  }

  export type TimeLogCreateOrConnectWithoutUserInput = {
    where: TimeLogWhereUniqueInput
    create: XOR<TimeLogCreateWithoutUserInput, TimeLogUncheckedCreateWithoutUserInput>
  }

  export type TimeLogCreateManyUserInputEnvelope = {
    data: TimeLogCreateManyUserInput | TimeLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type: string
    title: string
    body?: string | null
    targetUrl?: string | null
    priorityScore?: number
    isRead?: boolean
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    title: string
    body?: string | null
    targetUrl?: string | null
    priorityScore?: number
    isRead?: boolean
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserSkillProfileCreateWithoutUserInput = {
    id?: string
    skills?: UserSkillProfileCreateskillsInput | string[]
    proficiencyScores?: JsonNullValueInput | InputJsonValue
    certifiedSkills?: UserSkillProfileCreatecertifiedSkillsInput | string[]
    overallProficiency?: number
    lastUpdated?: Date | string
    team?: TeamCreateNestedOneWithoutSkillProfilesInput
  }

  export type UserSkillProfileUncheckedCreateWithoutUserInput = {
    id?: string
    skills?: UserSkillProfileCreateskillsInput | string[]
    proficiencyScores?: JsonNullValueInput | InputJsonValue
    certifiedSkills?: UserSkillProfileCreatecertifiedSkillsInput | string[]
    overallProficiency?: number
    lastUpdated?: Date | string
    teamId?: string | null
  }

  export type UserSkillProfileCreateOrConnectWithoutUserInput = {
    where: UserSkillProfileWhereUniqueInput
    create: XOR<UserSkillProfileCreateWithoutUserInput, UserSkillProfileUncheckedCreateWithoutUserInput>
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    token?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
  }

  export type OrganizationMembershipUpsertWithWhereUniqueWithoutUserInput = {
    where: OrganizationMembershipWhereUniqueInput
    update: XOR<OrganizationMembershipUpdateWithoutUserInput, OrganizationMembershipUncheckedUpdateWithoutUserInput>
    create: XOR<OrganizationMembershipCreateWithoutUserInput, OrganizationMembershipUncheckedCreateWithoutUserInput>
  }

  export type OrganizationMembershipUpdateWithWhereUniqueWithoutUserInput = {
    where: OrganizationMembershipWhereUniqueInput
    data: XOR<OrganizationMembershipUpdateWithoutUserInput, OrganizationMembershipUncheckedUpdateWithoutUserInput>
  }

  export type OrganizationMembershipUpdateManyWithWhereWithoutUserInput = {
    where: OrganizationMembershipScalarWhereInput
    data: XOR<OrganizationMembershipUpdateManyMutationInput, OrganizationMembershipUncheckedUpdateManyWithoutUserInput>
  }

  export type OrganizationMembershipScalarWhereInput = {
    AND?: OrganizationMembershipScalarWhereInput | OrganizationMembershipScalarWhereInput[]
    OR?: OrganizationMembershipScalarWhereInput[]
    NOT?: OrganizationMembershipScalarWhereInput | OrganizationMembershipScalarWhereInput[]
    id?: StringFilter<"OrganizationMembership"> | string
    userId?: StringFilter<"OrganizationMembership"> | string
    organizationId?: StringFilter<"OrganizationMembership"> | string
    role?: StringFilter<"OrganizationMembership"> | string
    joinedAt?: DateTimeFilter<"OrganizationMembership"> | Date | string
  }

  export type TeamMembershipUpsertWithWhereUniqueWithoutUserInput = {
    where: TeamMembershipWhereUniqueInput
    update: XOR<TeamMembershipUpdateWithoutUserInput, TeamMembershipUncheckedUpdateWithoutUserInput>
    create: XOR<TeamMembershipCreateWithoutUserInput, TeamMembershipUncheckedCreateWithoutUserInput>
  }

  export type TeamMembershipUpdateWithWhereUniqueWithoutUserInput = {
    where: TeamMembershipWhereUniqueInput
    data: XOR<TeamMembershipUpdateWithoutUserInput, TeamMembershipUncheckedUpdateWithoutUserInput>
  }

  export type TeamMembershipUpdateManyWithWhereWithoutUserInput = {
    where: TeamMembershipScalarWhereInput
    data: XOR<TeamMembershipUpdateManyMutationInput, TeamMembershipUncheckedUpdateManyWithoutUserInput>
  }

  export type TeamMembershipScalarWhereInput = {
    AND?: TeamMembershipScalarWhereInput | TeamMembershipScalarWhereInput[]
    OR?: TeamMembershipScalarWhereInput[]
    NOT?: TeamMembershipScalarWhereInput | TeamMembershipScalarWhereInput[]
    id?: StringFilter<"TeamMembership"> | string
    userId?: StringFilter<"TeamMembership"> | string
    teamId?: StringFilter<"TeamMembership"> | string
    roleId?: StringNullableFilter<"TeamMembership"> | string | null
    joinedAt?: DateTimeFilter<"TeamMembership"> | Date | string
    leftAt?: DateTimeNullableFilter<"TeamMembership"> | Date | string | null
  }

  export type ProjectUpsertWithWhereUniqueWithoutLeadUserInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutLeadUserInput, ProjectUncheckedUpdateWithoutLeadUserInput>
    create: XOR<ProjectCreateWithoutLeadUserInput, ProjectUncheckedCreateWithoutLeadUserInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutLeadUserInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutLeadUserInput, ProjectUncheckedUpdateWithoutLeadUserInput>
  }

  export type ProjectUpdateManyWithWhereWithoutLeadUserInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutLeadUserInput>
  }

  export type ProjectScalarWhereInput = {
    AND?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    OR?: ProjectScalarWhereInput[]
    NOT?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    id?: StringFilter<"Project"> | string
    key?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    projectType?: StringFilter<"Project"> | string
    riskScore?: FloatFilter<"Project"> | number
    startDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    settings?: JsonFilter<"Project">
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    portfolioId?: StringNullableFilter<"Project"> | string | null
    organizationId?: StringFilter<"Project"> | string
    leadUserId?: StringNullableFilter<"Project"> | string | null
  }

  export type WorkItemUpsertWithWhereUniqueWithoutAssigneeInput = {
    where: WorkItemWhereUniqueInput
    update: XOR<WorkItemUpdateWithoutAssigneeInput, WorkItemUncheckedUpdateWithoutAssigneeInput>
    create: XOR<WorkItemCreateWithoutAssigneeInput, WorkItemUncheckedCreateWithoutAssigneeInput>
  }

  export type WorkItemUpdateWithWhereUniqueWithoutAssigneeInput = {
    where: WorkItemWhereUniqueInput
    data: XOR<WorkItemUpdateWithoutAssigneeInput, WorkItemUncheckedUpdateWithoutAssigneeInput>
  }

  export type WorkItemUpdateManyWithWhereWithoutAssigneeInput = {
    where: WorkItemScalarWhereInput
    data: XOR<WorkItemUpdateManyMutationInput, WorkItemUncheckedUpdateManyWithoutAssigneeInput>
  }

  export type WorkItemScalarWhereInput = {
    AND?: WorkItemScalarWhereInput | WorkItemScalarWhereInput[]
    OR?: WorkItemScalarWhereInput[]
    NOT?: WorkItemScalarWhereInput | WorkItemScalarWhereInput[]
    id?: StringFilter<"WorkItem"> | string
    title?: StringFilter<"WorkItem"> | string
    description?: StringNullableFilter<"WorkItem"> | string | null
    type?: EnumWorkItemTypeFilter<"WorkItem"> | $Enums.WorkItemType
    priority?: EnumPriorityFilter<"WorkItem"> | $Enums.Priority
    storyPoints?: FloatNullableFilter<"WorkItem"> | number | null
    estimatedHours?: FloatNullableFilter<"WorkItem"> | number | null
    remainingHours?: FloatNullableFilter<"WorkItem"> | number | null
    order?: IntFilter<"WorkItem"> | number
    dueDate?: DateTimeNullableFilter<"WorkItem"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"WorkItem"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"WorkItem"> | Date | string | null
    createdAt?: DateTimeFilter<"WorkItem"> | Date | string
    updatedAt?: DateTimeFilter<"WorkItem"> | Date | string
    parentId?: StringNullableFilter<"WorkItem"> | string | null
    epicId?: StringNullableFilter<"WorkItem"> | string | null
    projectId?: StringFilter<"WorkItem"> | string
    stateId?: StringNullableFilter<"WorkItem"> | string | null
    assigneeId?: StringNullableFilter<"WorkItem"> | string | null
    creatorId?: StringFilter<"WorkItem"> | string
    sprintId?: StringNullableFilter<"WorkItem"> | string | null
  }

  export type WorkItemUpsertWithWhereUniqueWithoutCreatorInput = {
    where: WorkItemWhereUniqueInput
    update: XOR<WorkItemUpdateWithoutCreatorInput, WorkItemUncheckedUpdateWithoutCreatorInput>
    create: XOR<WorkItemCreateWithoutCreatorInput, WorkItemUncheckedCreateWithoutCreatorInput>
  }

  export type WorkItemUpdateWithWhereUniqueWithoutCreatorInput = {
    where: WorkItemWhereUniqueInput
    data: XOR<WorkItemUpdateWithoutCreatorInput, WorkItemUncheckedUpdateWithoutCreatorInput>
  }

  export type WorkItemUpdateManyWithWhereWithoutCreatorInput = {
    where: WorkItemScalarWhereInput
    data: XOR<WorkItemUpdateManyMutationInput, WorkItemUncheckedUpdateManyWithoutCreatorInput>
  }

  export type CommentUpsertWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
  }

  export type CommentUpdateManyWithWhereWithoutUserInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutUserInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: StringFilter<"Comment"> | string
    body?: StringFilter<"Comment"> | string
    sentimentScore?: FloatNullableFilter<"Comment"> | number | null
    sentimentLabel?: StringNullableFilter<"Comment"> | string | null
    isInternal?: BoolFilter<"Comment"> | boolean
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    workItemId?: StringFilter<"Comment"> | string
    userId?: StringFilter<"Comment"> | string
  }

  export type TimeLogUpsertWithWhereUniqueWithoutUserInput = {
    where: TimeLogWhereUniqueInput
    update: XOR<TimeLogUpdateWithoutUserInput, TimeLogUncheckedUpdateWithoutUserInput>
    create: XOR<TimeLogCreateWithoutUserInput, TimeLogUncheckedCreateWithoutUserInput>
  }

  export type TimeLogUpdateWithWhereUniqueWithoutUserInput = {
    where: TimeLogWhereUniqueInput
    data: XOR<TimeLogUpdateWithoutUserInput, TimeLogUncheckedUpdateWithoutUserInput>
  }

  export type TimeLogUpdateManyWithWhereWithoutUserInput = {
    where: TimeLogScalarWhereInput
    data: XOR<TimeLogUpdateManyMutationInput, TimeLogUncheckedUpdateManyWithoutUserInput>
  }

  export type TimeLogScalarWhereInput = {
    AND?: TimeLogScalarWhereInput | TimeLogScalarWhereInput[]
    OR?: TimeLogScalarWhereInput[]
    NOT?: TimeLogScalarWhereInput | TimeLogScalarWhereInput[]
    id?: StringFilter<"TimeLog"> | string
    duration?: IntFilter<"TimeLog"> | number
    description?: StringNullableFilter<"TimeLog"> | string | null
    billable?: BoolFilter<"TimeLog"> | boolean
    logDate?: DateTimeFilter<"TimeLog"> | Date | string
    startedAt?: DateTimeNullableFilter<"TimeLog"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"TimeLog"> | Date | string | null
    createdAt?: DateTimeFilter<"TimeLog"> | Date | string
    updatedAt?: DateTimeFilter<"TimeLog"> | Date | string
    workItemId?: StringFilter<"TimeLog"> | string
    userId?: StringFilter<"TimeLog"> | string
    sprintId?: StringNullableFilter<"TimeLog"> | string | null
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    body?: StringNullableFilter<"Notification"> | string | null
    targetUrl?: StringNullableFilter<"Notification"> | string | null
    priorityScore?: FloatFilter<"Notification"> | number
    isRead?: BoolFilter<"Notification"> | boolean
    metadata?: JsonFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    userId?: StringFilter<"Notification"> | string
  }

  export type UserSkillProfileUpsertWithoutUserInput = {
    update: XOR<UserSkillProfileUpdateWithoutUserInput, UserSkillProfileUncheckedUpdateWithoutUserInput>
    create: XOR<UserSkillProfileCreateWithoutUserInput, UserSkillProfileUncheckedCreateWithoutUserInput>
    where?: UserSkillProfileWhereInput
  }

  export type UserSkillProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: UserSkillProfileWhereInput
    data: XOR<UserSkillProfileUpdateWithoutUserInput, UserSkillProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserSkillProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    skills?: UserSkillProfileUpdateskillsInput | string[]
    proficiencyScores?: JsonNullValueInput | InputJsonValue
    certifiedSkills?: UserSkillProfileUpdatecertifiedSkillsInput | string[]
    overallProficiency?: FloatFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneWithoutSkillProfilesNestedInput
  }

  export type UserSkillProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    skills?: UserSkillProfileUpdateskillsInput | string[]
    proficiencyScores?: JsonNullValueInput | InputJsonValue
    certifiedSkills?: UserSkillProfileUpdatecertifiedSkillsInput | string[]
    overallProficiency?: FloatFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    passwordHash?: string | null
    firstName: string
    lastName: string
    avatarUrl?: string | null
    timezone?: string
    availabilityHours?: number
    isActive?: boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    organizationMemberships?: OrganizationMembershipCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMembershipCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectCreateNestedManyWithoutLeadUserInput
    assignedWorkItems?: WorkItemCreateNestedManyWithoutAssigneeInput
    createdWorkItems?: WorkItemCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    timeLogs?: TimeLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    skillProfile?: UserSkillProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    passwordHash?: string | null
    firstName: string
    lastName: string
    avatarUrl?: string | null
    timezone?: string
    availabilityHours?: number
    isActive?: boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    organizationMemberships?: OrganizationMembershipUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMembershipUncheckedCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutLeadUserInput
    assignedWorkItems?: WorkItemUncheckedCreateNestedManyWithoutAssigneeInput
    createdWorkItems?: WorkItemUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    skillProfile?: UserSkillProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    availabilityHours?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    organizationMemberships?: OrganizationMembershipUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMembershipUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUpdateManyWithoutLeadUserNestedInput
    assignedWorkItems?: WorkItemUpdateManyWithoutAssigneeNestedInput
    createdWorkItems?: WorkItemUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    timeLogs?: TimeLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    skillProfile?: UserSkillProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    availabilityHours?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    organizationMemberships?: OrganizationMembershipUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMembershipUncheckedUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutLeadUserNestedInput
    assignedWorkItems?: WorkItemUncheckedUpdateManyWithoutAssigneeNestedInput
    createdWorkItems?: WorkItemUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    skillProfile?: UserSkillProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    passwordHash?: string | null
    firstName: string
    lastName: string
    avatarUrl?: string | null
    timezone?: string
    availabilityHours?: number
    isActive?: boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    organizationMemberships?: OrganizationMembershipCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMembershipCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectCreateNestedManyWithoutLeadUserInput
    assignedWorkItems?: WorkItemCreateNestedManyWithoutAssigneeInput
    createdWorkItems?: WorkItemCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    timeLogs?: TimeLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    skillProfile?: UserSkillProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    passwordHash?: string | null
    firstName: string
    lastName: string
    avatarUrl?: string | null
    timezone?: string
    availabilityHours?: number
    isActive?: boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    organizationMemberships?: OrganizationMembershipUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMembershipUncheckedCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutLeadUserInput
    assignedWorkItems?: WorkItemUncheckedCreateNestedManyWithoutAssigneeInput
    createdWorkItems?: WorkItemUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    skillProfile?: UserSkillProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    availabilityHours?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    organizationMemberships?: OrganizationMembershipUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMembershipUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUpdateManyWithoutLeadUserNestedInput
    assignedWorkItems?: WorkItemUpdateManyWithoutAssigneeNestedInput
    createdWorkItems?: WorkItemUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    timeLogs?: TimeLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    skillProfile?: UserSkillProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    availabilityHours?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    organizationMemberships?: OrganizationMembershipUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMembershipUncheckedUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutLeadUserNestedInput
    assignedWorkItems?: WorkItemUncheckedUpdateManyWithoutAssigneeNestedInput
    createdWorkItems?: WorkItemUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    skillProfile?: UserSkillProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type OrganizationMembershipCreateWithoutOrganizationInput = {
    id?: string
    role?: string
    joinedAt?: Date | string
    user: UserCreateNestedOneWithoutOrganizationMembershipsInput
  }

  export type OrganizationMembershipUncheckedCreateWithoutOrganizationInput = {
    id?: string
    userId: string
    role?: string
    joinedAt?: Date | string
  }

  export type OrganizationMembershipCreateOrConnectWithoutOrganizationInput = {
    where: OrganizationMembershipWhereUniqueInput
    create: XOR<OrganizationMembershipCreateWithoutOrganizationInput, OrganizationMembershipUncheckedCreateWithoutOrganizationInput>
  }

  export type OrganizationMembershipCreateManyOrganizationInputEnvelope = {
    data: OrganizationMembershipCreateManyOrganizationInput | OrganizationMembershipCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type PortfolioCreateWithoutOrganizationInput = {
    id?: string
    name: string
    description?: string | null
    strategicGoal?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectCreateNestedManyWithoutPortfolioInput
  }

  export type PortfolioUncheckedCreateWithoutOrganizationInput = {
    id?: string
    name: string
    description?: string | null
    strategicGoal?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutPortfolioInput
  }

  export type PortfolioCreateOrConnectWithoutOrganizationInput = {
    where: PortfolioWhereUniqueInput
    create: XOR<PortfolioCreateWithoutOrganizationInput, PortfolioUncheckedCreateWithoutOrganizationInput>
  }

  export type PortfolioCreateManyOrganizationInputEnvelope = {
    data: PortfolioCreateManyOrganizationInput | PortfolioCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type TeamCreateWithoutOrganizationInput = {
    id?: string
    name: string
    description?: string | null
    velocityHistory?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TeamMembershipCreateNestedManyWithoutTeamInput
    projects?: ProjectCreateNestedManyWithoutTeamsInput
    skillProfiles?: UserSkillProfileCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutOrganizationInput = {
    id?: string
    name: string
    description?: string | null
    velocityHistory?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TeamMembershipUncheckedCreateNestedManyWithoutTeamInput
    projects?: ProjectUncheckedCreateNestedManyWithoutTeamsInput
    skillProfiles?: UserSkillProfileUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutOrganizationInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutOrganizationInput, TeamUncheckedCreateWithoutOrganizationInput>
  }

  export type TeamCreateManyOrganizationInputEnvelope = {
    data: TeamCreateManyOrganizationInput | TeamCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutOrganizationInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    projectType?: string
    riskScore?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    portfolio?: PortfolioCreateNestedOneWithoutProjectsInput
    leadUser?: UserCreateNestedOneWithoutOwnedProjectsInput
    workItems?: WorkItemCreateNestedManyWithoutProjectInput
    sprints?: SprintCreateNestedManyWithoutProjectInput
    milestones?: MilestoneCreateNestedManyWithoutProjectInput
    boards?: BoardCreateNestedManyWithoutProjectInput
    workflowRules?: WorkflowRuleCreateNestedManyWithoutProjectInput
    workItemStates?: WorkItemStateCreateNestedManyWithoutProjectInput
    components?: ComponentCreateNestedManyWithoutProjectInput
    teams?: TeamCreateNestedManyWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutOrganizationInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    projectType?: string
    riskScore?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    portfolioId?: string | null
    leadUserId?: string | null
    workItems?: WorkItemUncheckedCreateNestedManyWithoutProjectInput
    sprints?: SprintUncheckedCreateNestedManyWithoutProjectInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutProjectInput
    boards?: BoardUncheckedCreateNestedManyWithoutProjectInput
    workflowRules?: WorkflowRuleUncheckedCreateNestedManyWithoutProjectInput
    workItemStates?: WorkItemStateUncheckedCreateNestedManyWithoutProjectInput
    components?: ComponentUncheckedCreateNestedManyWithoutProjectInput
    teams?: TeamUncheckedCreateNestedManyWithoutProjectsInput
  }

  export type ProjectCreateOrConnectWithoutOrganizationInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutOrganizationInput, ProjectUncheckedCreateWithoutOrganizationInput>
  }

  export type ProjectCreateManyOrganizationInputEnvelope = {
    data: ProjectCreateManyOrganizationInput | ProjectCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationMembershipUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: OrganizationMembershipWhereUniqueInput
    update: XOR<OrganizationMembershipUpdateWithoutOrganizationInput, OrganizationMembershipUncheckedUpdateWithoutOrganizationInput>
    create: XOR<OrganizationMembershipCreateWithoutOrganizationInput, OrganizationMembershipUncheckedCreateWithoutOrganizationInput>
  }

  export type OrganizationMembershipUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: OrganizationMembershipWhereUniqueInput
    data: XOR<OrganizationMembershipUpdateWithoutOrganizationInput, OrganizationMembershipUncheckedUpdateWithoutOrganizationInput>
  }

  export type OrganizationMembershipUpdateManyWithWhereWithoutOrganizationInput = {
    where: OrganizationMembershipScalarWhereInput
    data: XOR<OrganizationMembershipUpdateManyMutationInput, OrganizationMembershipUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type PortfolioUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: PortfolioWhereUniqueInput
    update: XOR<PortfolioUpdateWithoutOrganizationInput, PortfolioUncheckedUpdateWithoutOrganizationInput>
    create: XOR<PortfolioCreateWithoutOrganizationInput, PortfolioUncheckedCreateWithoutOrganizationInput>
  }

  export type PortfolioUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: PortfolioWhereUniqueInput
    data: XOR<PortfolioUpdateWithoutOrganizationInput, PortfolioUncheckedUpdateWithoutOrganizationInput>
  }

  export type PortfolioUpdateManyWithWhereWithoutOrganizationInput = {
    where: PortfolioScalarWhereInput
    data: XOR<PortfolioUpdateManyMutationInput, PortfolioUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type PortfolioScalarWhereInput = {
    AND?: PortfolioScalarWhereInput | PortfolioScalarWhereInput[]
    OR?: PortfolioScalarWhereInput[]
    NOT?: PortfolioScalarWhereInput | PortfolioScalarWhereInput[]
    id?: StringFilter<"Portfolio"> | string
    name?: StringFilter<"Portfolio"> | string
    description?: StringNullableFilter<"Portfolio"> | string | null
    strategicGoal?: StringNullableFilter<"Portfolio"> | string | null
    startDate?: DateTimeNullableFilter<"Portfolio"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Portfolio"> | Date | string | null
    createdAt?: DateTimeFilter<"Portfolio"> | Date | string
    updatedAt?: DateTimeFilter<"Portfolio"> | Date | string
    organizationId?: StringFilter<"Portfolio"> | string
  }

  export type TeamUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: TeamWhereUniqueInput
    update: XOR<TeamUpdateWithoutOrganizationInput, TeamUncheckedUpdateWithoutOrganizationInput>
    create: XOR<TeamCreateWithoutOrganizationInput, TeamUncheckedCreateWithoutOrganizationInput>
  }

  export type TeamUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: TeamWhereUniqueInput
    data: XOR<TeamUpdateWithoutOrganizationInput, TeamUncheckedUpdateWithoutOrganizationInput>
  }

  export type TeamUpdateManyWithWhereWithoutOrganizationInput = {
    where: TeamScalarWhereInput
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type TeamScalarWhereInput = {
    AND?: TeamScalarWhereInput | TeamScalarWhereInput[]
    OR?: TeamScalarWhereInput[]
    NOT?: TeamScalarWhereInput | TeamScalarWhereInput[]
    id?: StringFilter<"Team"> | string
    name?: StringFilter<"Team"> | string
    description?: StringNullableFilter<"Team"> | string | null
    velocityHistory?: JsonFilter<"Team">
    settings?: JsonFilter<"Team">
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    organizationId?: StringFilter<"Team"> | string
  }

  export type ProjectUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutOrganizationInput, ProjectUncheckedUpdateWithoutOrganizationInput>
    create: XOR<ProjectCreateWithoutOrganizationInput, ProjectUncheckedCreateWithoutOrganizationInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutOrganizationInput, ProjectUncheckedUpdateWithoutOrganizationInput>
  }

  export type ProjectUpdateManyWithWhereWithoutOrganizationInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type OrganizationCreateWithoutTeamsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    planTier?: string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: OrganizationMembershipCreateNestedManyWithoutOrganizationInput
    portfolios?: PortfolioCreateNestedManyWithoutOrganizationInput
    projects?: ProjectCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutTeamsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    planTier?: string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: OrganizationMembershipUncheckedCreateNestedManyWithoutOrganizationInput
    portfolios?: PortfolioUncheckedCreateNestedManyWithoutOrganizationInput
    projects?: ProjectUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutTeamsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutTeamsInput, OrganizationUncheckedCreateWithoutTeamsInput>
  }

  export type TeamMembershipCreateWithoutTeamInput = {
    id?: string
    joinedAt?: Date | string
    leftAt?: Date | string | null
    user: UserCreateNestedOneWithoutTeamMembershipsInput
    role?: RoleCreateNestedOneWithoutTeamMembershipsInput
  }

  export type TeamMembershipUncheckedCreateWithoutTeamInput = {
    id?: string
    userId: string
    roleId?: string | null
    joinedAt?: Date | string
    leftAt?: Date | string | null
  }

  export type TeamMembershipCreateOrConnectWithoutTeamInput = {
    where: TeamMembershipWhereUniqueInput
    create: XOR<TeamMembershipCreateWithoutTeamInput, TeamMembershipUncheckedCreateWithoutTeamInput>
  }

  export type TeamMembershipCreateManyTeamInputEnvelope = {
    data: TeamMembershipCreateManyTeamInput | TeamMembershipCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutTeamsInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    projectType?: string
    riskScore?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    portfolio?: PortfolioCreateNestedOneWithoutProjectsInput
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    leadUser?: UserCreateNestedOneWithoutOwnedProjectsInput
    workItems?: WorkItemCreateNestedManyWithoutProjectInput
    sprints?: SprintCreateNestedManyWithoutProjectInput
    milestones?: MilestoneCreateNestedManyWithoutProjectInput
    boards?: BoardCreateNestedManyWithoutProjectInput
    workflowRules?: WorkflowRuleCreateNestedManyWithoutProjectInput
    workItemStates?: WorkItemStateCreateNestedManyWithoutProjectInput
    components?: ComponentCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutTeamsInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    projectType?: string
    riskScore?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    portfolioId?: string | null
    organizationId: string
    leadUserId?: string | null
    workItems?: WorkItemUncheckedCreateNestedManyWithoutProjectInput
    sprints?: SprintUncheckedCreateNestedManyWithoutProjectInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutProjectInput
    boards?: BoardUncheckedCreateNestedManyWithoutProjectInput
    workflowRules?: WorkflowRuleUncheckedCreateNestedManyWithoutProjectInput
    workItemStates?: WorkItemStateUncheckedCreateNestedManyWithoutProjectInput
    components?: ComponentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutTeamsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutTeamsInput, ProjectUncheckedCreateWithoutTeamsInput>
  }

  export type UserSkillProfileCreateWithoutTeamInput = {
    id?: string
    skills?: UserSkillProfileCreateskillsInput | string[]
    proficiencyScores?: JsonNullValueInput | InputJsonValue
    certifiedSkills?: UserSkillProfileCreatecertifiedSkillsInput | string[]
    overallProficiency?: number
    lastUpdated?: Date | string
    user: UserCreateNestedOneWithoutSkillProfileInput
  }

  export type UserSkillProfileUncheckedCreateWithoutTeamInput = {
    id?: string
    skills?: UserSkillProfileCreateskillsInput | string[]
    proficiencyScores?: JsonNullValueInput | InputJsonValue
    certifiedSkills?: UserSkillProfileCreatecertifiedSkillsInput | string[]
    overallProficiency?: number
    lastUpdated?: Date | string
    userId: string
  }

  export type UserSkillProfileCreateOrConnectWithoutTeamInput = {
    where: UserSkillProfileWhereUniqueInput
    create: XOR<UserSkillProfileCreateWithoutTeamInput, UserSkillProfileUncheckedCreateWithoutTeamInput>
  }

  export type UserSkillProfileCreateManyTeamInputEnvelope = {
    data: UserSkillProfileCreateManyTeamInput | UserSkillProfileCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutTeamsInput = {
    update: XOR<OrganizationUpdateWithoutTeamsInput, OrganizationUncheckedUpdateWithoutTeamsInput>
    create: XOR<OrganizationCreateWithoutTeamsInput, OrganizationUncheckedCreateWithoutTeamsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutTeamsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutTeamsInput, OrganizationUncheckedUpdateWithoutTeamsInput>
  }

  export type OrganizationUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    planTier?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: OrganizationMembershipUpdateManyWithoutOrganizationNestedInput
    portfolios?: PortfolioUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    planTier?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: OrganizationMembershipUncheckedUpdateManyWithoutOrganizationNestedInput
    portfolios?: PortfolioUncheckedUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type TeamMembershipUpsertWithWhereUniqueWithoutTeamInput = {
    where: TeamMembershipWhereUniqueInput
    update: XOR<TeamMembershipUpdateWithoutTeamInput, TeamMembershipUncheckedUpdateWithoutTeamInput>
    create: XOR<TeamMembershipCreateWithoutTeamInput, TeamMembershipUncheckedCreateWithoutTeamInput>
  }

  export type TeamMembershipUpdateWithWhereUniqueWithoutTeamInput = {
    where: TeamMembershipWhereUniqueInput
    data: XOR<TeamMembershipUpdateWithoutTeamInput, TeamMembershipUncheckedUpdateWithoutTeamInput>
  }

  export type TeamMembershipUpdateManyWithWhereWithoutTeamInput = {
    where: TeamMembershipScalarWhereInput
    data: XOR<TeamMembershipUpdateManyMutationInput, TeamMembershipUncheckedUpdateManyWithoutTeamInput>
  }

  export type ProjectUpsertWithWhereUniqueWithoutTeamsInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutTeamsInput, ProjectUncheckedUpdateWithoutTeamsInput>
    create: XOR<ProjectCreateWithoutTeamsInput, ProjectUncheckedCreateWithoutTeamsInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutTeamsInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutTeamsInput, ProjectUncheckedUpdateWithoutTeamsInput>
  }

  export type ProjectUpdateManyWithWhereWithoutTeamsInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutTeamsInput>
  }

  export type UserSkillProfileUpsertWithWhereUniqueWithoutTeamInput = {
    where: UserSkillProfileWhereUniqueInput
    update: XOR<UserSkillProfileUpdateWithoutTeamInput, UserSkillProfileUncheckedUpdateWithoutTeamInput>
    create: XOR<UserSkillProfileCreateWithoutTeamInput, UserSkillProfileUncheckedCreateWithoutTeamInput>
  }

  export type UserSkillProfileUpdateWithWhereUniqueWithoutTeamInput = {
    where: UserSkillProfileWhereUniqueInput
    data: XOR<UserSkillProfileUpdateWithoutTeamInput, UserSkillProfileUncheckedUpdateWithoutTeamInput>
  }

  export type UserSkillProfileUpdateManyWithWhereWithoutTeamInput = {
    where: UserSkillProfileScalarWhereInput
    data: XOR<UserSkillProfileUpdateManyMutationInput, UserSkillProfileUncheckedUpdateManyWithoutTeamInput>
  }

  export type UserSkillProfileScalarWhereInput = {
    AND?: UserSkillProfileScalarWhereInput | UserSkillProfileScalarWhereInput[]
    OR?: UserSkillProfileScalarWhereInput[]
    NOT?: UserSkillProfileScalarWhereInput | UserSkillProfileScalarWhereInput[]
    id?: StringFilter<"UserSkillProfile"> | string
    skills?: StringNullableListFilter<"UserSkillProfile">
    proficiencyScores?: JsonFilter<"UserSkillProfile">
    certifiedSkills?: StringNullableListFilter<"UserSkillProfile">
    overallProficiency?: FloatFilter<"UserSkillProfile"> | number
    lastUpdated?: DateTimeFilter<"UserSkillProfile"> | Date | string
    userId?: StringFilter<"UserSkillProfile"> | string
    teamId?: StringNullableFilter<"UserSkillProfile"> | string | null
  }

  export type TeamMembershipCreateWithoutRoleInput = {
    id?: string
    joinedAt?: Date | string
    leftAt?: Date | string | null
    user: UserCreateNestedOneWithoutTeamMembershipsInput
    team: TeamCreateNestedOneWithoutMembersInput
  }

  export type TeamMembershipUncheckedCreateWithoutRoleInput = {
    id?: string
    userId: string
    teamId: string
    joinedAt?: Date | string
    leftAt?: Date | string | null
  }

  export type TeamMembershipCreateOrConnectWithoutRoleInput = {
    where: TeamMembershipWhereUniqueInput
    create: XOR<TeamMembershipCreateWithoutRoleInput, TeamMembershipUncheckedCreateWithoutRoleInput>
  }

  export type TeamMembershipCreateManyRoleInputEnvelope = {
    data: TeamMembershipCreateManyRoleInput | TeamMembershipCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type TeamMembershipUpsertWithWhereUniqueWithoutRoleInput = {
    where: TeamMembershipWhereUniqueInput
    update: XOR<TeamMembershipUpdateWithoutRoleInput, TeamMembershipUncheckedUpdateWithoutRoleInput>
    create: XOR<TeamMembershipCreateWithoutRoleInput, TeamMembershipUncheckedCreateWithoutRoleInput>
  }

  export type TeamMembershipUpdateWithWhereUniqueWithoutRoleInput = {
    where: TeamMembershipWhereUniqueInput
    data: XOR<TeamMembershipUpdateWithoutRoleInput, TeamMembershipUncheckedUpdateWithoutRoleInput>
  }

  export type TeamMembershipUpdateManyWithWhereWithoutRoleInput = {
    where: TeamMembershipScalarWhereInput
    data: XOR<TeamMembershipUpdateManyMutationInput, TeamMembershipUncheckedUpdateManyWithoutRoleInput>
  }

  export type UserCreateWithoutOrganizationMembershipsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    passwordHash?: string | null
    firstName: string
    lastName: string
    avatarUrl?: string | null
    timezone?: string
    availabilityHours?: number
    isActive?: boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMembershipCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectCreateNestedManyWithoutLeadUserInput
    assignedWorkItems?: WorkItemCreateNestedManyWithoutAssigneeInput
    createdWorkItems?: WorkItemCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    timeLogs?: TimeLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    skillProfile?: UserSkillProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrganizationMembershipsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    passwordHash?: string | null
    firstName: string
    lastName: string
    avatarUrl?: string | null
    timezone?: string
    availabilityHours?: number
    isActive?: boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMembershipUncheckedCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutLeadUserInput
    assignedWorkItems?: WorkItemUncheckedCreateNestedManyWithoutAssigneeInput
    createdWorkItems?: WorkItemUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    skillProfile?: UserSkillProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrganizationMembershipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrganizationMembershipsInput, UserUncheckedCreateWithoutOrganizationMembershipsInput>
  }

  export type OrganizationCreateWithoutUsersInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    planTier?: string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    portfolios?: PortfolioCreateNestedManyWithoutOrganizationInput
    teams?: TeamCreateNestedManyWithoutOrganizationInput
    projects?: ProjectCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    planTier?: string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    portfolios?: PortfolioUncheckedCreateNestedManyWithoutOrganizationInput
    teams?: TeamUncheckedCreateNestedManyWithoutOrganizationInput
    projects?: ProjectUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutUsersInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
  }

  export type UserUpsertWithoutOrganizationMembershipsInput = {
    update: XOR<UserUpdateWithoutOrganizationMembershipsInput, UserUncheckedUpdateWithoutOrganizationMembershipsInput>
    create: XOR<UserCreateWithoutOrganizationMembershipsInput, UserUncheckedCreateWithoutOrganizationMembershipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrganizationMembershipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrganizationMembershipsInput, UserUncheckedUpdateWithoutOrganizationMembershipsInput>
  }

  export type UserUpdateWithoutOrganizationMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    availabilityHours?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMembershipUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUpdateManyWithoutLeadUserNestedInput
    assignedWorkItems?: WorkItemUpdateManyWithoutAssigneeNestedInput
    createdWorkItems?: WorkItemUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    timeLogs?: TimeLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    skillProfile?: UserSkillProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrganizationMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    availabilityHours?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMembershipUncheckedUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutLeadUserNestedInput
    assignedWorkItems?: WorkItemUncheckedUpdateManyWithoutAssigneeNestedInput
    createdWorkItems?: WorkItemUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    skillProfile?: UserSkillProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type OrganizationUpsertWithoutUsersInput = {
    update: XOR<OrganizationUpdateWithoutUsersInput, OrganizationUncheckedUpdateWithoutUsersInput>
    create: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutUsersInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutUsersInput, OrganizationUncheckedUpdateWithoutUsersInput>
  }

  export type OrganizationUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    planTier?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolios?: PortfolioUpdateManyWithoutOrganizationNestedInput
    teams?: TeamUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    planTier?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolios?: PortfolioUncheckedUpdateManyWithoutOrganizationNestedInput
    teams?: TeamUncheckedUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type UserCreateWithoutTeamMembershipsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    passwordHash?: string | null
    firstName: string
    lastName: string
    avatarUrl?: string | null
    timezone?: string
    availabilityHours?: number
    isActive?: boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    organizationMemberships?: OrganizationMembershipCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectCreateNestedManyWithoutLeadUserInput
    assignedWorkItems?: WorkItemCreateNestedManyWithoutAssigneeInput
    createdWorkItems?: WorkItemCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    timeLogs?: TimeLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    skillProfile?: UserSkillProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTeamMembershipsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    passwordHash?: string | null
    firstName: string
    lastName: string
    avatarUrl?: string | null
    timezone?: string
    availabilityHours?: number
    isActive?: boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    organizationMemberships?: OrganizationMembershipUncheckedCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutLeadUserInput
    assignedWorkItems?: WorkItemUncheckedCreateNestedManyWithoutAssigneeInput
    createdWorkItems?: WorkItemUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    skillProfile?: UserSkillProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTeamMembershipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeamMembershipsInput, UserUncheckedCreateWithoutTeamMembershipsInput>
  }

  export type TeamCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    velocityHistory?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutTeamsInput
    projects?: ProjectCreateNestedManyWithoutTeamsInput
    skillProfiles?: UserSkillProfileCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    velocityHistory?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    organizationId: string
    projects?: ProjectUncheckedCreateNestedManyWithoutTeamsInput
    skillProfiles?: UserSkillProfileUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutMembersInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
  }

  export type RoleCreateWithoutTeamMembershipsInput = {
    id?: string
    name: string
    description?: string | null
    permissions: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type RoleUncheckedCreateWithoutTeamMembershipsInput = {
    id?: string
    name: string
    description?: string | null
    permissions: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type RoleCreateOrConnectWithoutTeamMembershipsInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutTeamMembershipsInput, RoleUncheckedCreateWithoutTeamMembershipsInput>
  }

  export type UserUpsertWithoutTeamMembershipsInput = {
    update: XOR<UserUpdateWithoutTeamMembershipsInput, UserUncheckedUpdateWithoutTeamMembershipsInput>
    create: XOR<UserCreateWithoutTeamMembershipsInput, UserUncheckedCreateWithoutTeamMembershipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTeamMembershipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTeamMembershipsInput, UserUncheckedUpdateWithoutTeamMembershipsInput>
  }

  export type UserUpdateWithoutTeamMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    availabilityHours?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    organizationMemberships?: OrganizationMembershipUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUpdateManyWithoutLeadUserNestedInput
    assignedWorkItems?: WorkItemUpdateManyWithoutAssigneeNestedInput
    createdWorkItems?: WorkItemUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    timeLogs?: TimeLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    skillProfile?: UserSkillProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTeamMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    availabilityHours?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    organizationMemberships?: OrganizationMembershipUncheckedUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutLeadUserNestedInput
    assignedWorkItems?: WorkItemUncheckedUpdateManyWithoutAssigneeNestedInput
    createdWorkItems?: WorkItemUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    skillProfile?: UserSkillProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type TeamUpsertWithoutMembersInput = {
    update: XOR<TeamUpdateWithoutMembersInput, TeamUncheckedUpdateWithoutMembersInput>
    create: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutMembersInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutMembersInput, TeamUncheckedUpdateWithoutMembersInput>
  }

  export type TeamUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    velocityHistory?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutTeamsNestedInput
    projects?: ProjectUpdateManyWithoutTeamsNestedInput
    skillProfiles?: UserSkillProfileUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    velocityHistory?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: StringFieldUpdateOperationsInput | string
    projects?: ProjectUncheckedUpdateManyWithoutTeamsNestedInput
    skillProfiles?: UserSkillProfileUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type RoleUpsertWithoutTeamMembershipsInput = {
    update: XOR<RoleUpdateWithoutTeamMembershipsInput, RoleUncheckedUpdateWithoutTeamMembershipsInput>
    create: XOR<RoleCreateWithoutTeamMembershipsInput, RoleUncheckedCreateWithoutTeamMembershipsInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutTeamMembershipsInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutTeamMembershipsInput, RoleUncheckedUpdateWithoutTeamMembershipsInput>
  }

  export type RoleUpdateWithoutTeamMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateWithoutTeamMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationCreateWithoutPortfoliosInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    planTier?: string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: OrganizationMembershipCreateNestedManyWithoutOrganizationInput
    teams?: TeamCreateNestedManyWithoutOrganizationInput
    projects?: ProjectCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutPortfoliosInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    planTier?: string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: OrganizationMembershipUncheckedCreateNestedManyWithoutOrganizationInput
    teams?: TeamUncheckedCreateNestedManyWithoutOrganizationInput
    projects?: ProjectUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutPortfoliosInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutPortfoliosInput, OrganizationUncheckedCreateWithoutPortfoliosInput>
  }

  export type ProjectCreateWithoutPortfolioInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    projectType?: string
    riskScore?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    leadUser?: UserCreateNestedOneWithoutOwnedProjectsInput
    workItems?: WorkItemCreateNestedManyWithoutProjectInput
    sprints?: SprintCreateNestedManyWithoutProjectInput
    milestones?: MilestoneCreateNestedManyWithoutProjectInput
    boards?: BoardCreateNestedManyWithoutProjectInput
    workflowRules?: WorkflowRuleCreateNestedManyWithoutProjectInput
    workItemStates?: WorkItemStateCreateNestedManyWithoutProjectInput
    components?: ComponentCreateNestedManyWithoutProjectInput
    teams?: TeamCreateNestedManyWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutPortfolioInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    projectType?: string
    riskScore?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    organizationId: string
    leadUserId?: string | null
    workItems?: WorkItemUncheckedCreateNestedManyWithoutProjectInput
    sprints?: SprintUncheckedCreateNestedManyWithoutProjectInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutProjectInput
    boards?: BoardUncheckedCreateNestedManyWithoutProjectInput
    workflowRules?: WorkflowRuleUncheckedCreateNestedManyWithoutProjectInput
    workItemStates?: WorkItemStateUncheckedCreateNestedManyWithoutProjectInput
    components?: ComponentUncheckedCreateNestedManyWithoutProjectInput
    teams?: TeamUncheckedCreateNestedManyWithoutProjectsInput
  }

  export type ProjectCreateOrConnectWithoutPortfolioInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutPortfolioInput, ProjectUncheckedCreateWithoutPortfolioInput>
  }

  export type ProjectCreateManyPortfolioInputEnvelope = {
    data: ProjectCreateManyPortfolioInput | ProjectCreateManyPortfolioInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutPortfoliosInput = {
    update: XOR<OrganizationUpdateWithoutPortfoliosInput, OrganizationUncheckedUpdateWithoutPortfoliosInput>
    create: XOR<OrganizationCreateWithoutPortfoliosInput, OrganizationUncheckedCreateWithoutPortfoliosInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutPortfoliosInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutPortfoliosInput, OrganizationUncheckedUpdateWithoutPortfoliosInput>
  }

  export type OrganizationUpdateWithoutPortfoliosInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    planTier?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: OrganizationMembershipUpdateManyWithoutOrganizationNestedInput
    teams?: TeamUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutPortfoliosInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    planTier?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: OrganizationMembershipUncheckedUpdateManyWithoutOrganizationNestedInput
    teams?: TeamUncheckedUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type ProjectUpsertWithWhereUniqueWithoutPortfolioInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutPortfolioInput, ProjectUncheckedUpdateWithoutPortfolioInput>
    create: XOR<ProjectCreateWithoutPortfolioInput, ProjectUncheckedCreateWithoutPortfolioInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutPortfolioInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutPortfolioInput, ProjectUncheckedUpdateWithoutPortfolioInput>
  }

  export type ProjectUpdateManyWithWhereWithoutPortfolioInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutPortfolioInput>
  }

  export type PortfolioCreateWithoutProjectsInput = {
    id?: string
    name: string
    description?: string | null
    strategicGoal?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutPortfoliosInput
  }

  export type PortfolioUncheckedCreateWithoutProjectsInput = {
    id?: string
    name: string
    description?: string | null
    strategicGoal?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organizationId: string
  }

  export type PortfolioCreateOrConnectWithoutProjectsInput = {
    where: PortfolioWhereUniqueInput
    create: XOR<PortfolioCreateWithoutProjectsInput, PortfolioUncheckedCreateWithoutProjectsInput>
  }

  export type OrganizationCreateWithoutProjectsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    planTier?: string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: OrganizationMembershipCreateNestedManyWithoutOrganizationInput
    portfolios?: PortfolioCreateNestedManyWithoutOrganizationInput
    teams?: TeamCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutProjectsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    planTier?: string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: OrganizationMembershipUncheckedCreateNestedManyWithoutOrganizationInput
    portfolios?: PortfolioUncheckedCreateNestedManyWithoutOrganizationInput
    teams?: TeamUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutProjectsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutProjectsInput, OrganizationUncheckedCreateWithoutProjectsInput>
  }

  export type UserCreateWithoutOwnedProjectsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    passwordHash?: string | null
    firstName: string
    lastName: string
    avatarUrl?: string | null
    timezone?: string
    availabilityHours?: number
    isActive?: boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    organizationMemberships?: OrganizationMembershipCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMembershipCreateNestedManyWithoutUserInput
    assignedWorkItems?: WorkItemCreateNestedManyWithoutAssigneeInput
    createdWorkItems?: WorkItemCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    timeLogs?: TimeLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    skillProfile?: UserSkillProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOwnedProjectsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    passwordHash?: string | null
    firstName: string
    lastName: string
    avatarUrl?: string | null
    timezone?: string
    availabilityHours?: number
    isActive?: boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    organizationMemberships?: OrganizationMembershipUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMembershipUncheckedCreateNestedManyWithoutUserInput
    assignedWorkItems?: WorkItemUncheckedCreateNestedManyWithoutAssigneeInput
    createdWorkItems?: WorkItemUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    skillProfile?: UserSkillProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOwnedProjectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwnedProjectsInput, UserUncheckedCreateWithoutOwnedProjectsInput>
  }

  export type WorkItemCreateWithoutProjectInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.WorkItemType
    priority?: $Enums.Priority
    storyPoints?: number | null
    estimatedHours?: number | null
    remainingHours?: number | null
    order?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: WorkItemCreateNestedOneWithoutChildrenInput
    children?: WorkItemCreateNestedManyWithoutParentInput
    epic?: WorkItemCreateNestedOneWithoutStoriesInput
    stories?: WorkItemCreateNestedManyWithoutEpicInput
    state?: WorkItemStateCreateNestedOneWithoutWorkItemsInput
    assignee?: UserCreateNestedOneWithoutAssignedWorkItemsInput
    creator: UserCreateNestedOneWithoutCreatedWorkItemsInput
    sprint?: SprintCreateNestedOneWithoutWorkItemsInput
    details?: WorkItemDetailCreateNestedOneWithoutWorkItemInput
    dependenciesAsSource?: DependencyCreateNestedManyWithoutSourceItemInput
    dependenciesAsTarget?: DependencyCreateNestedManyWithoutTargetItemInput
    comments?: CommentCreateNestedManyWithoutWorkItemInput
    attachments?: AttachmentCreateNestedManyWithoutWorkItemInput
    timeLogs?: TimeLogCreateNestedManyWithoutWorkItemInput
    snapshots?: WorkItemSnapshotCreateNestedManyWithoutWorkItemInput
    tags?: TagOnWorkItemCreateNestedManyWithoutWorkItemInput
    components?: ComponentOnWorkItemCreateNestedManyWithoutWorkItemInput
    embedding?: WorkItemEmbeddingCreateNestedOneWithoutWorkItemInput
  }

  export type WorkItemUncheckedCreateWithoutProjectInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.WorkItemType
    priority?: $Enums.Priority
    storyPoints?: number | null
    estimatedHours?: number | null
    remainingHours?: number | null
    order?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    epicId?: string | null
    stateId?: string | null
    assigneeId?: string | null
    creatorId: string
    sprintId?: string | null
    children?: WorkItemUncheckedCreateNestedManyWithoutParentInput
    stories?: WorkItemUncheckedCreateNestedManyWithoutEpicInput
    details?: WorkItemDetailUncheckedCreateNestedOneWithoutWorkItemInput
    dependenciesAsSource?: DependencyUncheckedCreateNestedManyWithoutSourceItemInput
    dependenciesAsTarget?: DependencyUncheckedCreateNestedManyWithoutTargetItemInput
    comments?: CommentUncheckedCreateNestedManyWithoutWorkItemInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutWorkItemInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutWorkItemInput
    snapshots?: WorkItemSnapshotUncheckedCreateNestedManyWithoutWorkItemInput
    tags?: TagOnWorkItemUncheckedCreateNestedManyWithoutWorkItemInput
    components?: ComponentOnWorkItemUncheckedCreateNestedManyWithoutWorkItemInput
    embedding?: WorkItemEmbeddingUncheckedCreateNestedOneWithoutWorkItemInput
  }

  export type WorkItemCreateOrConnectWithoutProjectInput = {
    where: WorkItemWhereUniqueInput
    create: XOR<WorkItemCreateWithoutProjectInput, WorkItemUncheckedCreateWithoutProjectInput>
  }

  export type WorkItemCreateManyProjectInputEnvelope = {
    data: WorkItemCreateManyProjectInput | WorkItemCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type SprintCreateWithoutProjectInput = {
    id?: string
    name: string
    goal?: string | null
    startDate: Date | string
    endDate: Date | string
    state?: string
    committedPoints?: number
    completedPoints?: number
    velocity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workItems?: WorkItemCreateNestedManyWithoutSprintInput
    snapshots?: WorkItemSnapshotCreateNestedManyWithoutSprintInput
    retrospective?: RetrospectiveCreateNestedOneWithoutSprintInput
    timeLogs?: TimeLogCreateNestedManyWithoutSprintInput
    boards?: BoardCreateNestedManyWithoutSprintInput
  }

  export type SprintUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    goal?: string | null
    startDate: Date | string
    endDate: Date | string
    state?: string
    committedPoints?: number
    completedPoints?: number
    velocity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workItems?: WorkItemUncheckedCreateNestedManyWithoutSprintInput
    snapshots?: WorkItemSnapshotUncheckedCreateNestedManyWithoutSprintInput
    retrospective?: RetrospectiveUncheckedCreateNestedOneWithoutSprintInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutSprintInput
    boards?: BoardUncheckedCreateNestedManyWithoutSprintInput
  }

  export type SprintCreateOrConnectWithoutProjectInput = {
    where: SprintWhereUniqueInput
    create: XOR<SprintCreateWithoutProjectInput, SprintUncheckedCreateWithoutProjectInput>
  }

  export type SprintCreateManyProjectInputEnvelope = {
    data: SprintCreateManyProjectInput | SprintCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type MilestoneCreateWithoutProjectInput = {
    id?: string
    name: string
    description?: string | null
    dueDate: Date | string
    completed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MilestoneUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    description?: string | null
    dueDate: Date | string
    completed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MilestoneCreateOrConnectWithoutProjectInput = {
    where: MilestoneWhereUniqueInput
    create: XOR<MilestoneCreateWithoutProjectInput, MilestoneUncheckedCreateWithoutProjectInput>
  }

  export type MilestoneCreateManyProjectInputEnvelope = {
    data: MilestoneCreateManyProjectInput | MilestoneCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type BoardCreateWithoutProjectInput = {
    id?: string
    name: string
    boardType?: string
    filterQuery?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sprint?: SprintCreateNestedOneWithoutBoardsInput
    lanes?: BoardLaneCreateNestedManyWithoutBoardInput
  }

  export type BoardUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    boardType?: string
    filterQuery?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sprintId?: string | null
    lanes?: BoardLaneUncheckedCreateNestedManyWithoutBoardInput
  }

  export type BoardCreateOrConnectWithoutProjectInput = {
    where: BoardWhereUniqueInput
    create: XOR<BoardCreateWithoutProjectInput, BoardUncheckedCreateWithoutProjectInput>
  }

  export type BoardCreateManyProjectInputEnvelope = {
    data: BoardCreateManyProjectInput | BoardCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowRuleCreateWithoutProjectInput = {
    id?: string
    name: string
    description?: string | null
    trigger: string
    action: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowRuleUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    description?: string | null
    trigger: string
    action: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkflowRuleCreateOrConnectWithoutProjectInput = {
    where: WorkflowRuleWhereUniqueInput
    create: XOR<WorkflowRuleCreateWithoutProjectInput, WorkflowRuleUncheckedCreateWithoutProjectInput>
  }

  export type WorkflowRuleCreateManyProjectInputEnvelope = {
    data: WorkflowRuleCreateManyProjectInput | WorkflowRuleCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type WorkItemStateCreateWithoutProjectInput = {
    id?: string
    name: string
    category: $Enums.WorkItemStateCategory
    position: number
    wipLimit?: number | null
    color?: string
    icon?: string | null
    isInitial?: boolean
    isFinal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workItems?: WorkItemCreateNestedManyWithoutStateInput
  }

  export type WorkItemStateUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    category: $Enums.WorkItemStateCategory
    position: number
    wipLimit?: number | null
    color?: string
    icon?: string | null
    isInitial?: boolean
    isFinal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workItems?: WorkItemUncheckedCreateNestedManyWithoutStateInput
  }

  export type WorkItemStateCreateOrConnectWithoutProjectInput = {
    where: WorkItemStateWhereUniqueInput
    create: XOR<WorkItemStateCreateWithoutProjectInput, WorkItemStateUncheckedCreateWithoutProjectInput>
  }

  export type WorkItemStateCreateManyProjectInputEnvelope = {
    data: WorkItemStateCreateManyProjectInput | WorkItemStateCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ComponentCreateWithoutProjectInput = {
    id?: string
    name: string
    description?: string | null
    color?: string
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    workItems?: ComponentOnWorkItemCreateNestedManyWithoutComponentInput
  }

  export type ComponentUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    description?: string | null
    color?: string
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    workItems?: ComponentOnWorkItemUncheckedCreateNestedManyWithoutComponentInput
  }

  export type ComponentCreateOrConnectWithoutProjectInput = {
    where: ComponentWhereUniqueInput
    create: XOR<ComponentCreateWithoutProjectInput, ComponentUncheckedCreateWithoutProjectInput>
  }

  export type ComponentCreateManyProjectInputEnvelope = {
    data: ComponentCreateManyProjectInput | ComponentCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type TeamCreateWithoutProjectsInput = {
    id?: string
    name: string
    description?: string | null
    velocityHistory?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutTeamsInput
    members?: TeamMembershipCreateNestedManyWithoutTeamInput
    skillProfiles?: UserSkillProfileCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutProjectsInput = {
    id?: string
    name: string
    description?: string | null
    velocityHistory?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    organizationId: string
    members?: TeamMembershipUncheckedCreateNestedManyWithoutTeamInput
    skillProfiles?: UserSkillProfileUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutProjectsInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutProjectsInput, TeamUncheckedCreateWithoutProjectsInput>
  }

  export type PortfolioUpsertWithoutProjectsInput = {
    update: XOR<PortfolioUpdateWithoutProjectsInput, PortfolioUncheckedUpdateWithoutProjectsInput>
    create: XOR<PortfolioCreateWithoutProjectsInput, PortfolioUncheckedCreateWithoutProjectsInput>
    where?: PortfolioWhereInput
  }

  export type PortfolioUpdateToOneWithWhereWithoutProjectsInput = {
    where?: PortfolioWhereInput
    data: XOR<PortfolioUpdateWithoutProjectsInput, PortfolioUncheckedUpdateWithoutProjectsInput>
  }

  export type PortfolioUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    strategicGoal?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutPortfoliosNestedInput
  }

  export type PortfolioUncheckedUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    strategicGoal?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: StringFieldUpdateOperationsInput | string
  }

  export type OrganizationUpsertWithoutProjectsInput = {
    update: XOR<OrganizationUpdateWithoutProjectsInput, OrganizationUncheckedUpdateWithoutProjectsInput>
    create: XOR<OrganizationCreateWithoutProjectsInput, OrganizationUncheckedCreateWithoutProjectsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutProjectsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutProjectsInput, OrganizationUncheckedUpdateWithoutProjectsInput>
  }

  export type OrganizationUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    planTier?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: OrganizationMembershipUpdateManyWithoutOrganizationNestedInput
    portfolios?: PortfolioUpdateManyWithoutOrganizationNestedInput
    teams?: TeamUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    planTier?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: OrganizationMembershipUncheckedUpdateManyWithoutOrganizationNestedInput
    portfolios?: PortfolioUncheckedUpdateManyWithoutOrganizationNestedInput
    teams?: TeamUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type UserUpsertWithoutOwnedProjectsInput = {
    update: XOR<UserUpdateWithoutOwnedProjectsInput, UserUncheckedUpdateWithoutOwnedProjectsInput>
    create: XOR<UserCreateWithoutOwnedProjectsInput, UserUncheckedCreateWithoutOwnedProjectsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOwnedProjectsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOwnedProjectsInput, UserUncheckedUpdateWithoutOwnedProjectsInput>
  }

  export type UserUpdateWithoutOwnedProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    availabilityHours?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    organizationMemberships?: OrganizationMembershipUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMembershipUpdateManyWithoutUserNestedInput
    assignedWorkItems?: WorkItemUpdateManyWithoutAssigneeNestedInput
    createdWorkItems?: WorkItemUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    timeLogs?: TimeLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    skillProfile?: UserSkillProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOwnedProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    availabilityHours?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    organizationMemberships?: OrganizationMembershipUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMembershipUncheckedUpdateManyWithoutUserNestedInput
    assignedWorkItems?: WorkItemUncheckedUpdateManyWithoutAssigneeNestedInput
    createdWorkItems?: WorkItemUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    skillProfile?: UserSkillProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type WorkItemUpsertWithWhereUniqueWithoutProjectInput = {
    where: WorkItemWhereUniqueInput
    update: XOR<WorkItemUpdateWithoutProjectInput, WorkItemUncheckedUpdateWithoutProjectInput>
    create: XOR<WorkItemCreateWithoutProjectInput, WorkItemUncheckedCreateWithoutProjectInput>
  }

  export type WorkItemUpdateWithWhereUniqueWithoutProjectInput = {
    where: WorkItemWhereUniqueInput
    data: XOR<WorkItemUpdateWithoutProjectInput, WorkItemUncheckedUpdateWithoutProjectInput>
  }

  export type WorkItemUpdateManyWithWhereWithoutProjectInput = {
    where: WorkItemScalarWhereInput
    data: XOR<WorkItemUpdateManyMutationInput, WorkItemUncheckedUpdateManyWithoutProjectInput>
  }

  export type SprintUpsertWithWhereUniqueWithoutProjectInput = {
    where: SprintWhereUniqueInput
    update: XOR<SprintUpdateWithoutProjectInput, SprintUncheckedUpdateWithoutProjectInput>
    create: XOR<SprintCreateWithoutProjectInput, SprintUncheckedCreateWithoutProjectInput>
  }

  export type SprintUpdateWithWhereUniqueWithoutProjectInput = {
    where: SprintWhereUniqueInput
    data: XOR<SprintUpdateWithoutProjectInput, SprintUncheckedUpdateWithoutProjectInput>
  }

  export type SprintUpdateManyWithWhereWithoutProjectInput = {
    where: SprintScalarWhereInput
    data: XOR<SprintUpdateManyMutationInput, SprintUncheckedUpdateManyWithoutProjectInput>
  }

  export type SprintScalarWhereInput = {
    AND?: SprintScalarWhereInput | SprintScalarWhereInput[]
    OR?: SprintScalarWhereInput[]
    NOT?: SprintScalarWhereInput | SprintScalarWhereInput[]
    id?: StringFilter<"Sprint"> | string
    name?: StringFilter<"Sprint"> | string
    goal?: StringNullableFilter<"Sprint"> | string | null
    startDate?: DateTimeFilter<"Sprint"> | Date | string
    endDate?: DateTimeFilter<"Sprint"> | Date | string
    state?: StringFilter<"Sprint"> | string
    committedPoints?: FloatFilter<"Sprint"> | number
    completedPoints?: FloatFilter<"Sprint"> | number
    velocity?: FloatNullableFilter<"Sprint"> | number | null
    createdAt?: DateTimeFilter<"Sprint"> | Date | string
    updatedAt?: DateTimeFilter<"Sprint"> | Date | string
    projectId?: StringFilter<"Sprint"> | string
  }

  export type MilestoneUpsertWithWhereUniqueWithoutProjectInput = {
    where: MilestoneWhereUniqueInput
    update: XOR<MilestoneUpdateWithoutProjectInput, MilestoneUncheckedUpdateWithoutProjectInput>
    create: XOR<MilestoneCreateWithoutProjectInput, MilestoneUncheckedCreateWithoutProjectInput>
  }

  export type MilestoneUpdateWithWhereUniqueWithoutProjectInput = {
    where: MilestoneWhereUniqueInput
    data: XOR<MilestoneUpdateWithoutProjectInput, MilestoneUncheckedUpdateWithoutProjectInput>
  }

  export type MilestoneUpdateManyWithWhereWithoutProjectInput = {
    where: MilestoneScalarWhereInput
    data: XOR<MilestoneUpdateManyMutationInput, MilestoneUncheckedUpdateManyWithoutProjectInput>
  }

  export type MilestoneScalarWhereInput = {
    AND?: MilestoneScalarWhereInput | MilestoneScalarWhereInput[]
    OR?: MilestoneScalarWhereInput[]
    NOT?: MilestoneScalarWhereInput | MilestoneScalarWhereInput[]
    id?: StringFilter<"Milestone"> | string
    name?: StringFilter<"Milestone"> | string
    description?: StringNullableFilter<"Milestone"> | string | null
    dueDate?: DateTimeFilter<"Milestone"> | Date | string
    completed?: BoolFilter<"Milestone"> | boolean
    createdAt?: DateTimeFilter<"Milestone"> | Date | string
    updatedAt?: DateTimeFilter<"Milestone"> | Date | string
    projectId?: StringFilter<"Milestone"> | string
  }

  export type BoardUpsertWithWhereUniqueWithoutProjectInput = {
    where: BoardWhereUniqueInput
    update: XOR<BoardUpdateWithoutProjectInput, BoardUncheckedUpdateWithoutProjectInput>
    create: XOR<BoardCreateWithoutProjectInput, BoardUncheckedCreateWithoutProjectInput>
  }

  export type BoardUpdateWithWhereUniqueWithoutProjectInput = {
    where: BoardWhereUniqueInput
    data: XOR<BoardUpdateWithoutProjectInput, BoardUncheckedUpdateWithoutProjectInput>
  }

  export type BoardUpdateManyWithWhereWithoutProjectInput = {
    where: BoardScalarWhereInput
    data: XOR<BoardUpdateManyMutationInput, BoardUncheckedUpdateManyWithoutProjectInput>
  }

  export type BoardScalarWhereInput = {
    AND?: BoardScalarWhereInput | BoardScalarWhereInput[]
    OR?: BoardScalarWhereInput[]
    NOT?: BoardScalarWhereInput | BoardScalarWhereInput[]
    id?: StringFilter<"Board"> | string
    name?: StringFilter<"Board"> | string
    boardType?: StringFilter<"Board"> | string
    filterQuery?: JsonFilter<"Board">
    settings?: JsonFilter<"Board">
    isDefault?: BoolFilter<"Board"> | boolean
    createdAt?: DateTimeFilter<"Board"> | Date | string
    updatedAt?: DateTimeFilter<"Board"> | Date | string
    projectId?: StringFilter<"Board"> | string
    sprintId?: StringNullableFilter<"Board"> | string | null
  }

  export type WorkflowRuleUpsertWithWhereUniqueWithoutProjectInput = {
    where: WorkflowRuleWhereUniqueInput
    update: XOR<WorkflowRuleUpdateWithoutProjectInput, WorkflowRuleUncheckedUpdateWithoutProjectInput>
    create: XOR<WorkflowRuleCreateWithoutProjectInput, WorkflowRuleUncheckedCreateWithoutProjectInput>
  }

  export type WorkflowRuleUpdateWithWhereUniqueWithoutProjectInput = {
    where: WorkflowRuleWhereUniqueInput
    data: XOR<WorkflowRuleUpdateWithoutProjectInput, WorkflowRuleUncheckedUpdateWithoutProjectInput>
  }

  export type WorkflowRuleUpdateManyWithWhereWithoutProjectInput = {
    where: WorkflowRuleScalarWhereInput
    data: XOR<WorkflowRuleUpdateManyMutationInput, WorkflowRuleUncheckedUpdateManyWithoutProjectInput>
  }

  export type WorkflowRuleScalarWhereInput = {
    AND?: WorkflowRuleScalarWhereInput | WorkflowRuleScalarWhereInput[]
    OR?: WorkflowRuleScalarWhereInput[]
    NOT?: WorkflowRuleScalarWhereInput | WorkflowRuleScalarWhereInput[]
    id?: StringFilter<"WorkflowRule"> | string
    name?: StringFilter<"WorkflowRule"> | string
    description?: StringNullableFilter<"WorkflowRule"> | string | null
    trigger?: StringFilter<"WorkflowRule"> | string
    action?: JsonFilter<"WorkflowRule">
    conditions?: JsonFilter<"WorkflowRule">
    isActive?: BoolFilter<"WorkflowRule"> | boolean
    priority?: IntFilter<"WorkflowRule"> | number
    createdAt?: DateTimeFilter<"WorkflowRule"> | Date | string
    updatedAt?: DateTimeFilter<"WorkflowRule"> | Date | string
    projectId?: StringFilter<"WorkflowRule"> | string
  }

  export type WorkItemStateUpsertWithWhereUniqueWithoutProjectInput = {
    where: WorkItemStateWhereUniqueInput
    update: XOR<WorkItemStateUpdateWithoutProjectInput, WorkItemStateUncheckedUpdateWithoutProjectInput>
    create: XOR<WorkItemStateCreateWithoutProjectInput, WorkItemStateUncheckedCreateWithoutProjectInput>
  }

  export type WorkItemStateUpdateWithWhereUniqueWithoutProjectInput = {
    where: WorkItemStateWhereUniqueInput
    data: XOR<WorkItemStateUpdateWithoutProjectInput, WorkItemStateUncheckedUpdateWithoutProjectInput>
  }

  export type WorkItemStateUpdateManyWithWhereWithoutProjectInput = {
    where: WorkItemStateScalarWhereInput
    data: XOR<WorkItemStateUpdateManyMutationInput, WorkItemStateUncheckedUpdateManyWithoutProjectInput>
  }

  export type WorkItemStateScalarWhereInput = {
    AND?: WorkItemStateScalarWhereInput | WorkItemStateScalarWhereInput[]
    OR?: WorkItemStateScalarWhereInput[]
    NOT?: WorkItemStateScalarWhereInput | WorkItemStateScalarWhereInput[]
    id?: StringFilter<"WorkItemState"> | string
    name?: StringFilter<"WorkItemState"> | string
    category?: EnumWorkItemStateCategoryFilter<"WorkItemState"> | $Enums.WorkItemStateCategory
    position?: IntFilter<"WorkItemState"> | number
    wipLimit?: IntNullableFilter<"WorkItemState"> | number | null
    color?: StringFilter<"WorkItemState"> | string
    icon?: StringNullableFilter<"WorkItemState"> | string | null
    isInitial?: BoolFilter<"WorkItemState"> | boolean
    isFinal?: BoolFilter<"WorkItemState"> | boolean
    createdAt?: DateTimeFilter<"WorkItemState"> | Date | string
    updatedAt?: DateTimeFilter<"WorkItemState"> | Date | string
    projectId?: StringFilter<"WorkItemState"> | string
  }

  export type ComponentUpsertWithWhereUniqueWithoutProjectInput = {
    where: ComponentWhereUniqueInput
    update: XOR<ComponentUpdateWithoutProjectInput, ComponentUncheckedUpdateWithoutProjectInput>
    create: XOR<ComponentCreateWithoutProjectInput, ComponentUncheckedCreateWithoutProjectInput>
  }

  export type ComponentUpdateWithWhereUniqueWithoutProjectInput = {
    where: ComponentWhereUniqueInput
    data: XOR<ComponentUpdateWithoutProjectInput, ComponentUncheckedUpdateWithoutProjectInput>
  }

  export type ComponentUpdateManyWithWhereWithoutProjectInput = {
    where: ComponentScalarWhereInput
    data: XOR<ComponentUpdateManyMutationInput, ComponentUncheckedUpdateManyWithoutProjectInput>
  }

  export type ComponentScalarWhereInput = {
    AND?: ComponentScalarWhereInput | ComponentScalarWhereInput[]
    OR?: ComponentScalarWhereInput[]
    NOT?: ComponentScalarWhereInput | ComponentScalarWhereInput[]
    id?: StringFilter<"Component"> | string
    name?: StringFilter<"Component"> | string
    description?: StringNullableFilter<"Component"> | string | null
    color?: StringFilter<"Component"> | string
    position?: IntFilter<"Component"> | number
    createdAt?: DateTimeFilter<"Component"> | Date | string
    updatedAt?: DateTimeFilter<"Component"> | Date | string
    projectId?: StringFilter<"Component"> | string
  }

  export type TeamUpsertWithWhereUniqueWithoutProjectsInput = {
    where: TeamWhereUniqueInput
    update: XOR<TeamUpdateWithoutProjectsInput, TeamUncheckedUpdateWithoutProjectsInput>
    create: XOR<TeamCreateWithoutProjectsInput, TeamUncheckedCreateWithoutProjectsInput>
  }

  export type TeamUpdateWithWhereUniqueWithoutProjectsInput = {
    where: TeamWhereUniqueInput
    data: XOR<TeamUpdateWithoutProjectsInput, TeamUncheckedUpdateWithoutProjectsInput>
  }

  export type TeamUpdateManyWithWhereWithoutProjectsInput = {
    where: TeamScalarWhereInput
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyWithoutProjectsInput>
  }

  export type ProjectCreateWithoutSprintsInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    projectType?: string
    riskScore?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    portfolio?: PortfolioCreateNestedOneWithoutProjectsInput
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    leadUser?: UserCreateNestedOneWithoutOwnedProjectsInput
    workItems?: WorkItemCreateNestedManyWithoutProjectInput
    milestones?: MilestoneCreateNestedManyWithoutProjectInput
    boards?: BoardCreateNestedManyWithoutProjectInput
    workflowRules?: WorkflowRuleCreateNestedManyWithoutProjectInput
    workItemStates?: WorkItemStateCreateNestedManyWithoutProjectInput
    components?: ComponentCreateNestedManyWithoutProjectInput
    teams?: TeamCreateNestedManyWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutSprintsInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    projectType?: string
    riskScore?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    portfolioId?: string | null
    organizationId: string
    leadUserId?: string | null
    workItems?: WorkItemUncheckedCreateNestedManyWithoutProjectInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutProjectInput
    boards?: BoardUncheckedCreateNestedManyWithoutProjectInput
    workflowRules?: WorkflowRuleUncheckedCreateNestedManyWithoutProjectInput
    workItemStates?: WorkItemStateUncheckedCreateNestedManyWithoutProjectInput
    components?: ComponentUncheckedCreateNestedManyWithoutProjectInput
    teams?: TeamUncheckedCreateNestedManyWithoutProjectsInput
  }

  export type ProjectCreateOrConnectWithoutSprintsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutSprintsInput, ProjectUncheckedCreateWithoutSprintsInput>
  }

  export type WorkItemCreateWithoutSprintInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.WorkItemType
    priority?: $Enums.Priority
    storyPoints?: number | null
    estimatedHours?: number | null
    remainingHours?: number | null
    order?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: WorkItemCreateNestedOneWithoutChildrenInput
    children?: WorkItemCreateNestedManyWithoutParentInput
    epic?: WorkItemCreateNestedOneWithoutStoriesInput
    stories?: WorkItemCreateNestedManyWithoutEpicInput
    project: ProjectCreateNestedOneWithoutWorkItemsInput
    state?: WorkItemStateCreateNestedOneWithoutWorkItemsInput
    assignee?: UserCreateNestedOneWithoutAssignedWorkItemsInput
    creator: UserCreateNestedOneWithoutCreatedWorkItemsInput
    details?: WorkItemDetailCreateNestedOneWithoutWorkItemInput
    dependenciesAsSource?: DependencyCreateNestedManyWithoutSourceItemInput
    dependenciesAsTarget?: DependencyCreateNestedManyWithoutTargetItemInput
    comments?: CommentCreateNestedManyWithoutWorkItemInput
    attachments?: AttachmentCreateNestedManyWithoutWorkItemInput
    timeLogs?: TimeLogCreateNestedManyWithoutWorkItemInput
    snapshots?: WorkItemSnapshotCreateNestedManyWithoutWorkItemInput
    tags?: TagOnWorkItemCreateNestedManyWithoutWorkItemInput
    components?: ComponentOnWorkItemCreateNestedManyWithoutWorkItemInput
    embedding?: WorkItemEmbeddingCreateNestedOneWithoutWorkItemInput
  }

  export type WorkItemUncheckedCreateWithoutSprintInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.WorkItemType
    priority?: $Enums.Priority
    storyPoints?: number | null
    estimatedHours?: number | null
    remainingHours?: number | null
    order?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    epicId?: string | null
    projectId: string
    stateId?: string | null
    assigneeId?: string | null
    creatorId: string
    children?: WorkItemUncheckedCreateNestedManyWithoutParentInput
    stories?: WorkItemUncheckedCreateNestedManyWithoutEpicInput
    details?: WorkItemDetailUncheckedCreateNestedOneWithoutWorkItemInput
    dependenciesAsSource?: DependencyUncheckedCreateNestedManyWithoutSourceItemInput
    dependenciesAsTarget?: DependencyUncheckedCreateNestedManyWithoutTargetItemInput
    comments?: CommentUncheckedCreateNestedManyWithoutWorkItemInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutWorkItemInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutWorkItemInput
    snapshots?: WorkItemSnapshotUncheckedCreateNestedManyWithoutWorkItemInput
    tags?: TagOnWorkItemUncheckedCreateNestedManyWithoutWorkItemInput
    components?: ComponentOnWorkItemUncheckedCreateNestedManyWithoutWorkItemInput
    embedding?: WorkItemEmbeddingUncheckedCreateNestedOneWithoutWorkItemInput
  }

  export type WorkItemCreateOrConnectWithoutSprintInput = {
    where: WorkItemWhereUniqueInput
    create: XOR<WorkItemCreateWithoutSprintInput, WorkItemUncheckedCreateWithoutSprintInput>
  }

  export type WorkItemCreateManySprintInputEnvelope = {
    data: WorkItemCreateManySprintInput | WorkItemCreateManySprintInput[]
    skipDuplicates?: boolean
  }

  export type WorkItemSnapshotCreateWithoutSprintInput = {
    id?: string
    stateId?: string | null
    pointsRemaining?: number | null
    hoursRemaining?: number | null
    hoursSpent?: number | null
    daysInCurrentState?: number
    blockerIds?: WorkItemSnapshotCreateblockerIdsInput | string[]
    snapshotDate?: Date | string
    workItem: WorkItemCreateNestedOneWithoutSnapshotsInput
  }

  export type WorkItemSnapshotUncheckedCreateWithoutSprintInput = {
    id?: string
    stateId?: string | null
    pointsRemaining?: number | null
    hoursRemaining?: number | null
    hoursSpent?: number | null
    daysInCurrentState?: number
    blockerIds?: WorkItemSnapshotCreateblockerIdsInput | string[]
    snapshotDate?: Date | string
    workItemId: string
  }

  export type WorkItemSnapshotCreateOrConnectWithoutSprintInput = {
    where: WorkItemSnapshotWhereUniqueInput
    create: XOR<WorkItemSnapshotCreateWithoutSprintInput, WorkItemSnapshotUncheckedCreateWithoutSprintInput>
  }

  export type WorkItemSnapshotCreateManySprintInputEnvelope = {
    data: WorkItemSnapshotCreateManySprintInput | WorkItemSnapshotCreateManySprintInput[]
    skipDuplicates?: boolean
  }

  export type RetrospectiveCreateWithoutSprintInput = {
    id?: string
    content?: JsonNullValueInput | InputJsonValue
    sentimentSummary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RetrospectiveUncheckedCreateWithoutSprintInput = {
    id?: string
    content?: JsonNullValueInput | InputJsonValue
    sentimentSummary?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RetrospectiveCreateOrConnectWithoutSprintInput = {
    where: RetrospectiveWhereUniqueInput
    create: XOR<RetrospectiveCreateWithoutSprintInput, RetrospectiveUncheckedCreateWithoutSprintInput>
  }

  export type TimeLogCreateWithoutSprintInput = {
    id?: string
    duration: number
    description?: string | null
    billable?: boolean
    logDate: Date | string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workItem: WorkItemCreateNestedOneWithoutTimeLogsInput
    user: UserCreateNestedOneWithoutTimeLogsInput
  }

  export type TimeLogUncheckedCreateWithoutSprintInput = {
    id?: string
    duration: number
    description?: string | null
    billable?: boolean
    logDate: Date | string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workItemId: string
    userId: string
  }

  export type TimeLogCreateOrConnectWithoutSprintInput = {
    where: TimeLogWhereUniqueInput
    create: XOR<TimeLogCreateWithoutSprintInput, TimeLogUncheckedCreateWithoutSprintInput>
  }

  export type TimeLogCreateManySprintInputEnvelope = {
    data: TimeLogCreateManySprintInput | TimeLogCreateManySprintInput[]
    skipDuplicates?: boolean
  }

  export type BoardCreateWithoutSprintInput = {
    id?: string
    name: string
    boardType?: string
    filterQuery?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutBoardsInput
    lanes?: BoardLaneCreateNestedManyWithoutBoardInput
  }

  export type BoardUncheckedCreateWithoutSprintInput = {
    id?: string
    name: string
    boardType?: string
    filterQuery?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    lanes?: BoardLaneUncheckedCreateNestedManyWithoutBoardInput
  }

  export type BoardCreateOrConnectWithoutSprintInput = {
    where: BoardWhereUniqueInput
    create: XOR<BoardCreateWithoutSprintInput, BoardUncheckedCreateWithoutSprintInput>
  }

  export type BoardCreateManySprintInputEnvelope = {
    data: BoardCreateManySprintInput | BoardCreateManySprintInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutSprintsInput = {
    update: XOR<ProjectUpdateWithoutSprintsInput, ProjectUncheckedUpdateWithoutSprintsInput>
    create: XOR<ProjectCreateWithoutSprintsInput, ProjectUncheckedCreateWithoutSprintsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutSprintsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutSprintsInput, ProjectUncheckedUpdateWithoutSprintsInput>
  }

  export type ProjectUpdateWithoutSprintsInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    projectType?: StringFieldUpdateOperationsInput | string
    riskScore?: FloatFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolio?: PortfolioUpdateOneWithoutProjectsNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    leadUser?: UserUpdateOneWithoutOwnedProjectsNestedInput
    workItems?: WorkItemUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUpdateManyWithoutProjectNestedInput
    boards?: BoardUpdateManyWithoutProjectNestedInput
    workflowRules?: WorkflowRuleUpdateManyWithoutProjectNestedInput
    workItemStates?: WorkItemStateUpdateManyWithoutProjectNestedInput
    components?: ComponentUpdateManyWithoutProjectNestedInput
    teams?: TeamUpdateManyWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutSprintsInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    projectType?: StringFieldUpdateOperationsInput | string
    riskScore?: FloatFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolioId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    leadUserId?: NullableStringFieldUpdateOperationsInput | string | null
    workItems?: WorkItemUncheckedUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutProjectNestedInput
    boards?: BoardUncheckedUpdateManyWithoutProjectNestedInput
    workflowRules?: WorkflowRuleUncheckedUpdateManyWithoutProjectNestedInput
    workItemStates?: WorkItemStateUncheckedUpdateManyWithoutProjectNestedInput
    components?: ComponentUncheckedUpdateManyWithoutProjectNestedInput
    teams?: TeamUncheckedUpdateManyWithoutProjectsNestedInput
  }

  export type WorkItemUpsertWithWhereUniqueWithoutSprintInput = {
    where: WorkItemWhereUniqueInput
    update: XOR<WorkItemUpdateWithoutSprintInput, WorkItemUncheckedUpdateWithoutSprintInput>
    create: XOR<WorkItemCreateWithoutSprintInput, WorkItemUncheckedCreateWithoutSprintInput>
  }

  export type WorkItemUpdateWithWhereUniqueWithoutSprintInput = {
    where: WorkItemWhereUniqueInput
    data: XOR<WorkItemUpdateWithoutSprintInput, WorkItemUncheckedUpdateWithoutSprintInput>
  }

  export type WorkItemUpdateManyWithWhereWithoutSprintInput = {
    where: WorkItemScalarWhereInput
    data: XOR<WorkItemUpdateManyMutationInput, WorkItemUncheckedUpdateManyWithoutSprintInput>
  }

  export type WorkItemSnapshotUpsertWithWhereUniqueWithoutSprintInput = {
    where: WorkItemSnapshotWhereUniqueInput
    update: XOR<WorkItemSnapshotUpdateWithoutSprintInput, WorkItemSnapshotUncheckedUpdateWithoutSprintInput>
    create: XOR<WorkItemSnapshotCreateWithoutSprintInput, WorkItemSnapshotUncheckedCreateWithoutSprintInput>
  }

  export type WorkItemSnapshotUpdateWithWhereUniqueWithoutSprintInput = {
    where: WorkItemSnapshotWhereUniqueInput
    data: XOR<WorkItemSnapshotUpdateWithoutSprintInput, WorkItemSnapshotUncheckedUpdateWithoutSprintInput>
  }

  export type WorkItemSnapshotUpdateManyWithWhereWithoutSprintInput = {
    where: WorkItemSnapshotScalarWhereInput
    data: XOR<WorkItemSnapshotUpdateManyMutationInput, WorkItemSnapshotUncheckedUpdateManyWithoutSprintInput>
  }

  export type WorkItemSnapshotScalarWhereInput = {
    AND?: WorkItemSnapshotScalarWhereInput | WorkItemSnapshotScalarWhereInput[]
    OR?: WorkItemSnapshotScalarWhereInput[]
    NOT?: WorkItemSnapshotScalarWhereInput | WorkItemSnapshotScalarWhereInput[]
    id?: StringFilter<"WorkItemSnapshot"> | string
    stateId?: StringNullableFilter<"WorkItemSnapshot"> | string | null
    pointsRemaining?: FloatNullableFilter<"WorkItemSnapshot"> | number | null
    hoursRemaining?: FloatNullableFilter<"WorkItemSnapshot"> | number | null
    hoursSpent?: FloatNullableFilter<"WorkItemSnapshot"> | number | null
    daysInCurrentState?: IntFilter<"WorkItemSnapshot"> | number
    blockerIds?: StringNullableListFilter<"WorkItemSnapshot">
    snapshotDate?: DateTimeFilter<"WorkItemSnapshot"> | Date | string
    workItemId?: StringFilter<"WorkItemSnapshot"> | string
    sprintId?: StringNullableFilter<"WorkItemSnapshot"> | string | null
  }

  export type RetrospectiveUpsertWithoutSprintInput = {
    update: XOR<RetrospectiveUpdateWithoutSprintInput, RetrospectiveUncheckedUpdateWithoutSprintInput>
    create: XOR<RetrospectiveCreateWithoutSprintInput, RetrospectiveUncheckedCreateWithoutSprintInput>
    where?: RetrospectiveWhereInput
  }

  export type RetrospectiveUpdateToOneWithWhereWithoutSprintInput = {
    where?: RetrospectiveWhereInput
    data: XOR<RetrospectiveUpdateWithoutSprintInput, RetrospectiveUncheckedUpdateWithoutSprintInput>
  }

  export type RetrospectiveUpdateWithoutSprintInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    sentimentSummary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RetrospectiveUncheckedUpdateWithoutSprintInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    sentimentSummary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeLogUpsertWithWhereUniqueWithoutSprintInput = {
    where: TimeLogWhereUniqueInput
    update: XOR<TimeLogUpdateWithoutSprintInput, TimeLogUncheckedUpdateWithoutSprintInput>
    create: XOR<TimeLogCreateWithoutSprintInput, TimeLogUncheckedCreateWithoutSprintInput>
  }

  export type TimeLogUpdateWithWhereUniqueWithoutSprintInput = {
    where: TimeLogWhereUniqueInput
    data: XOR<TimeLogUpdateWithoutSprintInput, TimeLogUncheckedUpdateWithoutSprintInput>
  }

  export type TimeLogUpdateManyWithWhereWithoutSprintInput = {
    where: TimeLogScalarWhereInput
    data: XOR<TimeLogUpdateManyMutationInput, TimeLogUncheckedUpdateManyWithoutSprintInput>
  }

  export type BoardUpsertWithWhereUniqueWithoutSprintInput = {
    where: BoardWhereUniqueInput
    update: XOR<BoardUpdateWithoutSprintInput, BoardUncheckedUpdateWithoutSprintInput>
    create: XOR<BoardCreateWithoutSprintInput, BoardUncheckedCreateWithoutSprintInput>
  }

  export type BoardUpdateWithWhereUniqueWithoutSprintInput = {
    where: BoardWhereUniqueInput
    data: XOR<BoardUpdateWithoutSprintInput, BoardUncheckedUpdateWithoutSprintInput>
  }

  export type BoardUpdateManyWithWhereWithoutSprintInput = {
    where: BoardScalarWhereInput
    data: XOR<BoardUpdateManyMutationInput, BoardUncheckedUpdateManyWithoutSprintInput>
  }

  export type ProjectCreateWithoutMilestonesInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    projectType?: string
    riskScore?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    portfolio?: PortfolioCreateNestedOneWithoutProjectsInput
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    leadUser?: UserCreateNestedOneWithoutOwnedProjectsInput
    workItems?: WorkItemCreateNestedManyWithoutProjectInput
    sprints?: SprintCreateNestedManyWithoutProjectInput
    boards?: BoardCreateNestedManyWithoutProjectInput
    workflowRules?: WorkflowRuleCreateNestedManyWithoutProjectInput
    workItemStates?: WorkItemStateCreateNestedManyWithoutProjectInput
    components?: ComponentCreateNestedManyWithoutProjectInput
    teams?: TeamCreateNestedManyWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutMilestonesInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    projectType?: string
    riskScore?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    portfolioId?: string | null
    organizationId: string
    leadUserId?: string | null
    workItems?: WorkItemUncheckedCreateNestedManyWithoutProjectInput
    sprints?: SprintUncheckedCreateNestedManyWithoutProjectInput
    boards?: BoardUncheckedCreateNestedManyWithoutProjectInput
    workflowRules?: WorkflowRuleUncheckedCreateNestedManyWithoutProjectInput
    workItemStates?: WorkItemStateUncheckedCreateNestedManyWithoutProjectInput
    components?: ComponentUncheckedCreateNestedManyWithoutProjectInput
    teams?: TeamUncheckedCreateNestedManyWithoutProjectsInput
  }

  export type ProjectCreateOrConnectWithoutMilestonesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutMilestonesInput, ProjectUncheckedCreateWithoutMilestonesInput>
  }

  export type ProjectUpsertWithoutMilestonesInput = {
    update: XOR<ProjectUpdateWithoutMilestonesInput, ProjectUncheckedUpdateWithoutMilestonesInput>
    create: XOR<ProjectCreateWithoutMilestonesInput, ProjectUncheckedCreateWithoutMilestonesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutMilestonesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutMilestonesInput, ProjectUncheckedUpdateWithoutMilestonesInput>
  }

  export type ProjectUpdateWithoutMilestonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    projectType?: StringFieldUpdateOperationsInput | string
    riskScore?: FloatFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolio?: PortfolioUpdateOneWithoutProjectsNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    leadUser?: UserUpdateOneWithoutOwnedProjectsNestedInput
    workItems?: WorkItemUpdateManyWithoutProjectNestedInput
    sprints?: SprintUpdateManyWithoutProjectNestedInput
    boards?: BoardUpdateManyWithoutProjectNestedInput
    workflowRules?: WorkflowRuleUpdateManyWithoutProjectNestedInput
    workItemStates?: WorkItemStateUpdateManyWithoutProjectNestedInput
    components?: ComponentUpdateManyWithoutProjectNestedInput
    teams?: TeamUpdateManyWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutMilestonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    projectType?: StringFieldUpdateOperationsInput | string
    riskScore?: FloatFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolioId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    leadUserId?: NullableStringFieldUpdateOperationsInput | string | null
    workItems?: WorkItemUncheckedUpdateManyWithoutProjectNestedInput
    sprints?: SprintUncheckedUpdateManyWithoutProjectNestedInput
    boards?: BoardUncheckedUpdateManyWithoutProjectNestedInput
    workflowRules?: WorkflowRuleUncheckedUpdateManyWithoutProjectNestedInput
    workItemStates?: WorkItemStateUncheckedUpdateManyWithoutProjectNestedInput
    components?: ComponentUncheckedUpdateManyWithoutProjectNestedInput
    teams?: TeamUncheckedUpdateManyWithoutProjectsNestedInput
  }

  export type SprintCreateWithoutRetrospectiveInput = {
    id?: string
    name: string
    goal?: string | null
    startDate: Date | string
    endDate: Date | string
    state?: string
    committedPoints?: number
    completedPoints?: number
    velocity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutSprintsInput
    workItems?: WorkItemCreateNestedManyWithoutSprintInput
    snapshots?: WorkItemSnapshotCreateNestedManyWithoutSprintInput
    timeLogs?: TimeLogCreateNestedManyWithoutSprintInput
    boards?: BoardCreateNestedManyWithoutSprintInput
  }

  export type SprintUncheckedCreateWithoutRetrospectiveInput = {
    id?: string
    name: string
    goal?: string | null
    startDate: Date | string
    endDate: Date | string
    state?: string
    committedPoints?: number
    completedPoints?: number
    velocity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    workItems?: WorkItemUncheckedCreateNestedManyWithoutSprintInput
    snapshots?: WorkItemSnapshotUncheckedCreateNestedManyWithoutSprintInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutSprintInput
    boards?: BoardUncheckedCreateNestedManyWithoutSprintInput
  }

  export type SprintCreateOrConnectWithoutRetrospectiveInput = {
    where: SprintWhereUniqueInput
    create: XOR<SprintCreateWithoutRetrospectiveInput, SprintUncheckedCreateWithoutRetrospectiveInput>
  }

  export type SprintUpsertWithoutRetrospectiveInput = {
    update: XOR<SprintUpdateWithoutRetrospectiveInput, SprintUncheckedUpdateWithoutRetrospectiveInput>
    create: XOR<SprintCreateWithoutRetrospectiveInput, SprintUncheckedCreateWithoutRetrospectiveInput>
    where?: SprintWhereInput
  }

  export type SprintUpdateToOneWithWhereWithoutRetrospectiveInput = {
    where?: SprintWhereInput
    data: XOR<SprintUpdateWithoutRetrospectiveInput, SprintUncheckedUpdateWithoutRetrospectiveInput>
  }

  export type SprintUpdateWithoutRetrospectiveInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    goal?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: StringFieldUpdateOperationsInput | string
    committedPoints?: FloatFieldUpdateOperationsInput | number
    completedPoints?: FloatFieldUpdateOperationsInput | number
    velocity?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutSprintsNestedInput
    workItems?: WorkItemUpdateManyWithoutSprintNestedInput
    snapshots?: WorkItemSnapshotUpdateManyWithoutSprintNestedInput
    timeLogs?: TimeLogUpdateManyWithoutSprintNestedInput
    boards?: BoardUpdateManyWithoutSprintNestedInput
  }

  export type SprintUncheckedUpdateWithoutRetrospectiveInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    goal?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: StringFieldUpdateOperationsInput | string
    committedPoints?: FloatFieldUpdateOperationsInput | number
    completedPoints?: FloatFieldUpdateOperationsInput | number
    velocity?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    workItems?: WorkItemUncheckedUpdateManyWithoutSprintNestedInput
    snapshots?: WorkItemSnapshotUncheckedUpdateManyWithoutSprintNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutSprintNestedInput
    boards?: BoardUncheckedUpdateManyWithoutSprintNestedInput
  }

  export type WorkItemCreateWithoutChildrenInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.WorkItemType
    priority?: $Enums.Priority
    storyPoints?: number | null
    estimatedHours?: number | null
    remainingHours?: number | null
    order?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: WorkItemCreateNestedOneWithoutChildrenInput
    epic?: WorkItemCreateNestedOneWithoutStoriesInput
    stories?: WorkItemCreateNestedManyWithoutEpicInput
    project: ProjectCreateNestedOneWithoutWorkItemsInput
    state?: WorkItemStateCreateNestedOneWithoutWorkItemsInput
    assignee?: UserCreateNestedOneWithoutAssignedWorkItemsInput
    creator: UserCreateNestedOneWithoutCreatedWorkItemsInput
    sprint?: SprintCreateNestedOneWithoutWorkItemsInput
    details?: WorkItemDetailCreateNestedOneWithoutWorkItemInput
    dependenciesAsSource?: DependencyCreateNestedManyWithoutSourceItemInput
    dependenciesAsTarget?: DependencyCreateNestedManyWithoutTargetItemInput
    comments?: CommentCreateNestedManyWithoutWorkItemInput
    attachments?: AttachmentCreateNestedManyWithoutWorkItemInput
    timeLogs?: TimeLogCreateNestedManyWithoutWorkItemInput
    snapshots?: WorkItemSnapshotCreateNestedManyWithoutWorkItemInput
    tags?: TagOnWorkItemCreateNestedManyWithoutWorkItemInput
    components?: ComponentOnWorkItemCreateNestedManyWithoutWorkItemInput
    embedding?: WorkItemEmbeddingCreateNestedOneWithoutWorkItemInput
  }

  export type WorkItemUncheckedCreateWithoutChildrenInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.WorkItemType
    priority?: $Enums.Priority
    storyPoints?: number | null
    estimatedHours?: number | null
    remainingHours?: number | null
    order?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    epicId?: string | null
    projectId: string
    stateId?: string | null
    assigneeId?: string | null
    creatorId: string
    sprintId?: string | null
    stories?: WorkItemUncheckedCreateNestedManyWithoutEpicInput
    details?: WorkItemDetailUncheckedCreateNestedOneWithoutWorkItemInput
    dependenciesAsSource?: DependencyUncheckedCreateNestedManyWithoutSourceItemInput
    dependenciesAsTarget?: DependencyUncheckedCreateNestedManyWithoutTargetItemInput
    comments?: CommentUncheckedCreateNestedManyWithoutWorkItemInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutWorkItemInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutWorkItemInput
    snapshots?: WorkItemSnapshotUncheckedCreateNestedManyWithoutWorkItemInput
    tags?: TagOnWorkItemUncheckedCreateNestedManyWithoutWorkItemInput
    components?: ComponentOnWorkItemUncheckedCreateNestedManyWithoutWorkItemInput
    embedding?: WorkItemEmbeddingUncheckedCreateNestedOneWithoutWorkItemInput
  }

  export type WorkItemCreateOrConnectWithoutChildrenInput = {
    where: WorkItemWhereUniqueInput
    create: XOR<WorkItemCreateWithoutChildrenInput, WorkItemUncheckedCreateWithoutChildrenInput>
  }

  export type WorkItemCreateWithoutParentInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.WorkItemType
    priority?: $Enums.Priority
    storyPoints?: number | null
    estimatedHours?: number | null
    remainingHours?: number | null
    order?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: WorkItemCreateNestedManyWithoutParentInput
    epic?: WorkItemCreateNestedOneWithoutStoriesInput
    stories?: WorkItemCreateNestedManyWithoutEpicInput
    project: ProjectCreateNestedOneWithoutWorkItemsInput
    state?: WorkItemStateCreateNestedOneWithoutWorkItemsInput
    assignee?: UserCreateNestedOneWithoutAssignedWorkItemsInput
    creator: UserCreateNestedOneWithoutCreatedWorkItemsInput
    sprint?: SprintCreateNestedOneWithoutWorkItemsInput
    details?: WorkItemDetailCreateNestedOneWithoutWorkItemInput
    dependenciesAsSource?: DependencyCreateNestedManyWithoutSourceItemInput
    dependenciesAsTarget?: DependencyCreateNestedManyWithoutTargetItemInput
    comments?: CommentCreateNestedManyWithoutWorkItemInput
    attachments?: AttachmentCreateNestedManyWithoutWorkItemInput
    timeLogs?: TimeLogCreateNestedManyWithoutWorkItemInput
    snapshots?: WorkItemSnapshotCreateNestedManyWithoutWorkItemInput
    tags?: TagOnWorkItemCreateNestedManyWithoutWorkItemInput
    components?: ComponentOnWorkItemCreateNestedManyWithoutWorkItemInput
    embedding?: WorkItemEmbeddingCreateNestedOneWithoutWorkItemInput
  }

  export type WorkItemUncheckedCreateWithoutParentInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.WorkItemType
    priority?: $Enums.Priority
    storyPoints?: number | null
    estimatedHours?: number | null
    remainingHours?: number | null
    order?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    epicId?: string | null
    projectId: string
    stateId?: string | null
    assigneeId?: string | null
    creatorId: string
    sprintId?: string | null
    children?: WorkItemUncheckedCreateNestedManyWithoutParentInput
    stories?: WorkItemUncheckedCreateNestedManyWithoutEpicInput
    details?: WorkItemDetailUncheckedCreateNestedOneWithoutWorkItemInput
    dependenciesAsSource?: DependencyUncheckedCreateNestedManyWithoutSourceItemInput
    dependenciesAsTarget?: DependencyUncheckedCreateNestedManyWithoutTargetItemInput
    comments?: CommentUncheckedCreateNestedManyWithoutWorkItemInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutWorkItemInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutWorkItemInput
    snapshots?: WorkItemSnapshotUncheckedCreateNestedManyWithoutWorkItemInput
    tags?: TagOnWorkItemUncheckedCreateNestedManyWithoutWorkItemInput
    components?: ComponentOnWorkItemUncheckedCreateNestedManyWithoutWorkItemInput
    embedding?: WorkItemEmbeddingUncheckedCreateNestedOneWithoutWorkItemInput
  }

  export type WorkItemCreateOrConnectWithoutParentInput = {
    where: WorkItemWhereUniqueInput
    create: XOR<WorkItemCreateWithoutParentInput, WorkItemUncheckedCreateWithoutParentInput>
  }

  export type WorkItemCreateManyParentInputEnvelope = {
    data: WorkItemCreateManyParentInput | WorkItemCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type WorkItemCreateWithoutStoriesInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.WorkItemType
    priority?: $Enums.Priority
    storyPoints?: number | null
    estimatedHours?: number | null
    remainingHours?: number | null
    order?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: WorkItemCreateNestedOneWithoutChildrenInput
    children?: WorkItemCreateNestedManyWithoutParentInput
    epic?: WorkItemCreateNestedOneWithoutStoriesInput
    project: ProjectCreateNestedOneWithoutWorkItemsInput
    state?: WorkItemStateCreateNestedOneWithoutWorkItemsInput
    assignee?: UserCreateNestedOneWithoutAssignedWorkItemsInput
    creator: UserCreateNestedOneWithoutCreatedWorkItemsInput
    sprint?: SprintCreateNestedOneWithoutWorkItemsInput
    details?: WorkItemDetailCreateNestedOneWithoutWorkItemInput
    dependenciesAsSource?: DependencyCreateNestedManyWithoutSourceItemInput
    dependenciesAsTarget?: DependencyCreateNestedManyWithoutTargetItemInput
    comments?: CommentCreateNestedManyWithoutWorkItemInput
    attachments?: AttachmentCreateNestedManyWithoutWorkItemInput
    timeLogs?: TimeLogCreateNestedManyWithoutWorkItemInput
    snapshots?: WorkItemSnapshotCreateNestedManyWithoutWorkItemInput
    tags?: TagOnWorkItemCreateNestedManyWithoutWorkItemInput
    components?: ComponentOnWorkItemCreateNestedManyWithoutWorkItemInput
    embedding?: WorkItemEmbeddingCreateNestedOneWithoutWorkItemInput
  }

  export type WorkItemUncheckedCreateWithoutStoriesInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.WorkItemType
    priority?: $Enums.Priority
    storyPoints?: number | null
    estimatedHours?: number | null
    remainingHours?: number | null
    order?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    epicId?: string | null
    projectId: string
    stateId?: string | null
    assigneeId?: string | null
    creatorId: string
    sprintId?: string | null
    children?: WorkItemUncheckedCreateNestedManyWithoutParentInput
    details?: WorkItemDetailUncheckedCreateNestedOneWithoutWorkItemInput
    dependenciesAsSource?: DependencyUncheckedCreateNestedManyWithoutSourceItemInput
    dependenciesAsTarget?: DependencyUncheckedCreateNestedManyWithoutTargetItemInput
    comments?: CommentUncheckedCreateNestedManyWithoutWorkItemInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutWorkItemInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutWorkItemInput
    snapshots?: WorkItemSnapshotUncheckedCreateNestedManyWithoutWorkItemInput
    tags?: TagOnWorkItemUncheckedCreateNestedManyWithoutWorkItemInput
    components?: ComponentOnWorkItemUncheckedCreateNestedManyWithoutWorkItemInput
    embedding?: WorkItemEmbeddingUncheckedCreateNestedOneWithoutWorkItemInput
  }

  export type WorkItemCreateOrConnectWithoutStoriesInput = {
    where: WorkItemWhereUniqueInput
    create: XOR<WorkItemCreateWithoutStoriesInput, WorkItemUncheckedCreateWithoutStoriesInput>
  }

  export type WorkItemCreateWithoutEpicInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.WorkItemType
    priority?: $Enums.Priority
    storyPoints?: number | null
    estimatedHours?: number | null
    remainingHours?: number | null
    order?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: WorkItemCreateNestedOneWithoutChildrenInput
    children?: WorkItemCreateNestedManyWithoutParentInput
    stories?: WorkItemCreateNestedManyWithoutEpicInput
    project: ProjectCreateNestedOneWithoutWorkItemsInput
    state?: WorkItemStateCreateNestedOneWithoutWorkItemsInput
    assignee?: UserCreateNestedOneWithoutAssignedWorkItemsInput
    creator: UserCreateNestedOneWithoutCreatedWorkItemsInput
    sprint?: SprintCreateNestedOneWithoutWorkItemsInput
    details?: WorkItemDetailCreateNestedOneWithoutWorkItemInput
    dependenciesAsSource?: DependencyCreateNestedManyWithoutSourceItemInput
    dependenciesAsTarget?: DependencyCreateNestedManyWithoutTargetItemInput
    comments?: CommentCreateNestedManyWithoutWorkItemInput
    attachments?: AttachmentCreateNestedManyWithoutWorkItemInput
    timeLogs?: TimeLogCreateNestedManyWithoutWorkItemInput
    snapshots?: WorkItemSnapshotCreateNestedManyWithoutWorkItemInput
    tags?: TagOnWorkItemCreateNestedManyWithoutWorkItemInput
    components?: ComponentOnWorkItemCreateNestedManyWithoutWorkItemInput
    embedding?: WorkItemEmbeddingCreateNestedOneWithoutWorkItemInput
  }

  export type WorkItemUncheckedCreateWithoutEpicInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.WorkItemType
    priority?: $Enums.Priority
    storyPoints?: number | null
    estimatedHours?: number | null
    remainingHours?: number | null
    order?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    projectId: string
    stateId?: string | null
    assigneeId?: string | null
    creatorId: string
    sprintId?: string | null
    children?: WorkItemUncheckedCreateNestedManyWithoutParentInput
    stories?: WorkItemUncheckedCreateNestedManyWithoutEpicInput
    details?: WorkItemDetailUncheckedCreateNestedOneWithoutWorkItemInput
    dependenciesAsSource?: DependencyUncheckedCreateNestedManyWithoutSourceItemInput
    dependenciesAsTarget?: DependencyUncheckedCreateNestedManyWithoutTargetItemInput
    comments?: CommentUncheckedCreateNestedManyWithoutWorkItemInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutWorkItemInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutWorkItemInput
    snapshots?: WorkItemSnapshotUncheckedCreateNestedManyWithoutWorkItemInput
    tags?: TagOnWorkItemUncheckedCreateNestedManyWithoutWorkItemInput
    components?: ComponentOnWorkItemUncheckedCreateNestedManyWithoutWorkItemInput
    embedding?: WorkItemEmbeddingUncheckedCreateNestedOneWithoutWorkItemInput
  }

  export type WorkItemCreateOrConnectWithoutEpicInput = {
    where: WorkItemWhereUniqueInput
    create: XOR<WorkItemCreateWithoutEpicInput, WorkItemUncheckedCreateWithoutEpicInput>
  }

  export type WorkItemCreateManyEpicInputEnvelope = {
    data: WorkItemCreateManyEpicInput | WorkItemCreateManyEpicInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutWorkItemsInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    projectType?: string
    riskScore?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    portfolio?: PortfolioCreateNestedOneWithoutProjectsInput
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    leadUser?: UserCreateNestedOneWithoutOwnedProjectsInput
    sprints?: SprintCreateNestedManyWithoutProjectInput
    milestones?: MilestoneCreateNestedManyWithoutProjectInput
    boards?: BoardCreateNestedManyWithoutProjectInput
    workflowRules?: WorkflowRuleCreateNestedManyWithoutProjectInput
    workItemStates?: WorkItemStateCreateNestedManyWithoutProjectInput
    components?: ComponentCreateNestedManyWithoutProjectInput
    teams?: TeamCreateNestedManyWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutWorkItemsInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    projectType?: string
    riskScore?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    portfolioId?: string | null
    organizationId: string
    leadUserId?: string | null
    sprints?: SprintUncheckedCreateNestedManyWithoutProjectInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutProjectInput
    boards?: BoardUncheckedCreateNestedManyWithoutProjectInput
    workflowRules?: WorkflowRuleUncheckedCreateNestedManyWithoutProjectInput
    workItemStates?: WorkItemStateUncheckedCreateNestedManyWithoutProjectInput
    components?: ComponentUncheckedCreateNestedManyWithoutProjectInput
    teams?: TeamUncheckedCreateNestedManyWithoutProjectsInput
  }

  export type ProjectCreateOrConnectWithoutWorkItemsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutWorkItemsInput, ProjectUncheckedCreateWithoutWorkItemsInput>
  }

  export type WorkItemStateCreateWithoutWorkItemsInput = {
    id?: string
    name: string
    category: $Enums.WorkItemStateCategory
    position: number
    wipLimit?: number | null
    color?: string
    icon?: string | null
    isInitial?: boolean
    isFinal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutWorkItemStatesInput
  }

  export type WorkItemStateUncheckedCreateWithoutWorkItemsInput = {
    id?: string
    name: string
    category: $Enums.WorkItemStateCategory
    position: number
    wipLimit?: number | null
    color?: string
    icon?: string | null
    isInitial?: boolean
    isFinal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type WorkItemStateCreateOrConnectWithoutWorkItemsInput = {
    where: WorkItemStateWhereUniqueInput
    create: XOR<WorkItemStateCreateWithoutWorkItemsInput, WorkItemStateUncheckedCreateWithoutWorkItemsInput>
  }

  export type UserCreateWithoutAssignedWorkItemsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    passwordHash?: string | null
    firstName: string
    lastName: string
    avatarUrl?: string | null
    timezone?: string
    availabilityHours?: number
    isActive?: boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    organizationMemberships?: OrganizationMembershipCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMembershipCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectCreateNestedManyWithoutLeadUserInput
    createdWorkItems?: WorkItemCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    timeLogs?: TimeLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    skillProfile?: UserSkillProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAssignedWorkItemsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    passwordHash?: string | null
    firstName: string
    lastName: string
    avatarUrl?: string | null
    timezone?: string
    availabilityHours?: number
    isActive?: boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    organizationMemberships?: OrganizationMembershipUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMembershipUncheckedCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutLeadUserInput
    createdWorkItems?: WorkItemUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    skillProfile?: UserSkillProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAssignedWorkItemsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedWorkItemsInput, UserUncheckedCreateWithoutAssignedWorkItemsInput>
  }

  export type UserCreateWithoutCreatedWorkItemsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    passwordHash?: string | null
    firstName: string
    lastName: string
    avatarUrl?: string | null
    timezone?: string
    availabilityHours?: number
    isActive?: boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    organizationMemberships?: OrganizationMembershipCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMembershipCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectCreateNestedManyWithoutLeadUserInput
    assignedWorkItems?: WorkItemCreateNestedManyWithoutAssigneeInput
    comments?: CommentCreateNestedManyWithoutUserInput
    timeLogs?: TimeLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    skillProfile?: UserSkillProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedWorkItemsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    passwordHash?: string | null
    firstName: string
    lastName: string
    avatarUrl?: string | null
    timezone?: string
    availabilityHours?: number
    isActive?: boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    organizationMemberships?: OrganizationMembershipUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMembershipUncheckedCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutLeadUserInput
    assignedWorkItems?: WorkItemUncheckedCreateNestedManyWithoutAssigneeInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    skillProfile?: UserSkillProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedWorkItemsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedWorkItemsInput, UserUncheckedCreateWithoutCreatedWorkItemsInput>
  }

  export type SprintCreateWithoutWorkItemsInput = {
    id?: string
    name: string
    goal?: string | null
    startDate: Date | string
    endDate: Date | string
    state?: string
    committedPoints?: number
    completedPoints?: number
    velocity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutSprintsInput
    snapshots?: WorkItemSnapshotCreateNestedManyWithoutSprintInput
    retrospective?: RetrospectiveCreateNestedOneWithoutSprintInput
    timeLogs?: TimeLogCreateNestedManyWithoutSprintInput
    boards?: BoardCreateNestedManyWithoutSprintInput
  }

  export type SprintUncheckedCreateWithoutWorkItemsInput = {
    id?: string
    name: string
    goal?: string | null
    startDate: Date | string
    endDate: Date | string
    state?: string
    committedPoints?: number
    completedPoints?: number
    velocity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    snapshots?: WorkItemSnapshotUncheckedCreateNestedManyWithoutSprintInput
    retrospective?: RetrospectiveUncheckedCreateNestedOneWithoutSprintInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutSprintInput
    boards?: BoardUncheckedCreateNestedManyWithoutSprintInput
  }

  export type SprintCreateOrConnectWithoutWorkItemsInput = {
    where: SprintWhereUniqueInput
    create: XOR<SprintCreateWithoutWorkItemsInput, SprintUncheckedCreateWithoutWorkItemsInput>
  }

  export type WorkItemDetailCreateWithoutWorkItemInput = {
    id?: string
    acceptanceCriteria?: string | null
    technicalNotes?: string | null
    reproSteps?: string | null
    businessValue?: string | null
    userPersona?: string | null
    customFields?: JsonNullValueInput | InputJsonValue
    externalReferences?: string | null
  }

  export type WorkItemDetailUncheckedCreateWithoutWorkItemInput = {
    id?: string
    acceptanceCriteria?: string | null
    technicalNotes?: string | null
    reproSteps?: string | null
    businessValue?: string | null
    userPersona?: string | null
    customFields?: JsonNullValueInput | InputJsonValue
    externalReferences?: string | null
  }

  export type WorkItemDetailCreateOrConnectWithoutWorkItemInput = {
    where: WorkItemDetailWhereUniqueInput
    create: XOR<WorkItemDetailCreateWithoutWorkItemInput, WorkItemDetailUncheckedCreateWithoutWorkItemInput>
  }

  export type DependencyCreateWithoutSourceItemInput = {
    id?: string
    dependencyType?: string
    description?: string | null
    createdAt?: Date | string
    targetItem: WorkItemCreateNestedOneWithoutDependenciesAsTargetInput
  }

  export type DependencyUncheckedCreateWithoutSourceItemInput = {
    id?: string
    dependencyType?: string
    description?: string | null
    createdAt?: Date | string
    targetItemId: string
  }

  export type DependencyCreateOrConnectWithoutSourceItemInput = {
    where: DependencyWhereUniqueInput
    create: XOR<DependencyCreateWithoutSourceItemInput, DependencyUncheckedCreateWithoutSourceItemInput>
  }

  export type DependencyCreateManySourceItemInputEnvelope = {
    data: DependencyCreateManySourceItemInput | DependencyCreateManySourceItemInput[]
    skipDuplicates?: boolean
  }

  export type DependencyCreateWithoutTargetItemInput = {
    id?: string
    dependencyType?: string
    description?: string | null
    createdAt?: Date | string
    sourceItem: WorkItemCreateNestedOneWithoutDependenciesAsSourceInput
  }

  export type DependencyUncheckedCreateWithoutTargetItemInput = {
    id?: string
    dependencyType?: string
    description?: string | null
    createdAt?: Date | string
    sourceItemId: string
  }

  export type DependencyCreateOrConnectWithoutTargetItemInput = {
    where: DependencyWhereUniqueInput
    create: XOR<DependencyCreateWithoutTargetItemInput, DependencyUncheckedCreateWithoutTargetItemInput>
  }

  export type DependencyCreateManyTargetItemInputEnvelope = {
    data: DependencyCreateManyTargetItemInput | DependencyCreateManyTargetItemInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutWorkItemInput = {
    id?: string
    body: string
    sentimentScore?: number | null
    sentimentLabel?: string | null
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutWorkItemInput = {
    id?: string
    body: string
    sentimentScore?: number | null
    sentimentLabel?: string | null
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type CommentCreateOrConnectWithoutWorkItemInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutWorkItemInput, CommentUncheckedCreateWithoutWorkItemInput>
  }

  export type CommentCreateManyWorkItemInputEnvelope = {
    data: CommentCreateManyWorkItemInput | CommentCreateManyWorkItemInput[]
    skipDuplicates?: boolean
  }

  export type AttachmentCreateWithoutWorkItemInput = {
    id?: string
    fileName: string
    fileType: string
    fileSize: number
    storagePath: string
    fileUrl: string
    ocrContent?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    uploadedBy: string
  }

  export type AttachmentUncheckedCreateWithoutWorkItemInput = {
    id?: string
    fileName: string
    fileType: string
    fileSize: number
    storagePath: string
    fileUrl: string
    ocrContent?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    uploadedBy: string
  }

  export type AttachmentCreateOrConnectWithoutWorkItemInput = {
    where: AttachmentWhereUniqueInput
    create: XOR<AttachmentCreateWithoutWorkItemInput, AttachmentUncheckedCreateWithoutWorkItemInput>
  }

  export type AttachmentCreateManyWorkItemInputEnvelope = {
    data: AttachmentCreateManyWorkItemInput | AttachmentCreateManyWorkItemInput[]
    skipDuplicates?: boolean
  }

  export type TimeLogCreateWithoutWorkItemInput = {
    id?: string
    duration: number
    description?: string | null
    billable?: boolean
    logDate: Date | string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTimeLogsInput
    sprint?: SprintCreateNestedOneWithoutTimeLogsInput
  }

  export type TimeLogUncheckedCreateWithoutWorkItemInput = {
    id?: string
    duration: number
    description?: string | null
    billable?: boolean
    logDate: Date | string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    sprintId?: string | null
  }

  export type TimeLogCreateOrConnectWithoutWorkItemInput = {
    where: TimeLogWhereUniqueInput
    create: XOR<TimeLogCreateWithoutWorkItemInput, TimeLogUncheckedCreateWithoutWorkItemInput>
  }

  export type TimeLogCreateManyWorkItemInputEnvelope = {
    data: TimeLogCreateManyWorkItemInput | TimeLogCreateManyWorkItemInput[]
    skipDuplicates?: boolean
  }

  export type WorkItemSnapshotCreateWithoutWorkItemInput = {
    id?: string
    stateId?: string | null
    pointsRemaining?: number | null
    hoursRemaining?: number | null
    hoursSpent?: number | null
    daysInCurrentState?: number
    blockerIds?: WorkItemSnapshotCreateblockerIdsInput | string[]
    snapshotDate?: Date | string
    sprint?: SprintCreateNestedOneWithoutSnapshotsInput
  }

  export type WorkItemSnapshotUncheckedCreateWithoutWorkItemInput = {
    id?: string
    stateId?: string | null
    pointsRemaining?: number | null
    hoursRemaining?: number | null
    hoursSpent?: number | null
    daysInCurrentState?: number
    blockerIds?: WorkItemSnapshotCreateblockerIdsInput | string[]
    snapshotDate?: Date | string
    sprintId?: string | null
  }

  export type WorkItemSnapshotCreateOrConnectWithoutWorkItemInput = {
    where: WorkItemSnapshotWhereUniqueInput
    create: XOR<WorkItemSnapshotCreateWithoutWorkItemInput, WorkItemSnapshotUncheckedCreateWithoutWorkItemInput>
  }

  export type WorkItemSnapshotCreateManyWorkItemInputEnvelope = {
    data: WorkItemSnapshotCreateManyWorkItemInput | WorkItemSnapshotCreateManyWorkItemInput[]
    skipDuplicates?: boolean
  }

  export type TagOnWorkItemCreateWithoutWorkItemInput = {
    tag: TagCreateNestedOneWithoutWorkItemsInput
  }

  export type TagOnWorkItemUncheckedCreateWithoutWorkItemInput = {
    tagId: string
  }

  export type TagOnWorkItemCreateOrConnectWithoutWorkItemInput = {
    where: TagOnWorkItemWhereUniqueInput
    create: XOR<TagOnWorkItemCreateWithoutWorkItemInput, TagOnWorkItemUncheckedCreateWithoutWorkItemInput>
  }

  export type TagOnWorkItemCreateManyWorkItemInputEnvelope = {
    data: TagOnWorkItemCreateManyWorkItemInput | TagOnWorkItemCreateManyWorkItemInput[]
    skipDuplicates?: boolean
  }

  export type ComponentOnWorkItemCreateWithoutWorkItemInput = {
    assignedAt?: Date | string
    component: ComponentCreateNestedOneWithoutWorkItemsInput
  }

  export type ComponentOnWorkItemUncheckedCreateWithoutWorkItemInput = {
    componentId: string
    assignedAt?: Date | string
  }

  export type ComponentOnWorkItemCreateOrConnectWithoutWorkItemInput = {
    where: ComponentOnWorkItemWhereUniqueInput
    create: XOR<ComponentOnWorkItemCreateWithoutWorkItemInput, ComponentOnWorkItemUncheckedCreateWithoutWorkItemInput>
  }

  export type ComponentOnWorkItemCreateManyWorkItemInputEnvelope = {
    data: ComponentOnWorkItemCreateManyWorkItemInput | ComponentOnWorkItemCreateManyWorkItemInput[]
    skipDuplicates?: boolean
  }

  export type WorkItemUpsertWithoutChildrenInput = {
    update: XOR<WorkItemUpdateWithoutChildrenInput, WorkItemUncheckedUpdateWithoutChildrenInput>
    create: XOR<WorkItemCreateWithoutChildrenInput, WorkItemUncheckedCreateWithoutChildrenInput>
    where?: WorkItemWhereInput
  }

  export type WorkItemUpdateToOneWithWhereWithoutChildrenInput = {
    where?: WorkItemWhereInput
    data: XOR<WorkItemUpdateWithoutChildrenInput, WorkItemUncheckedUpdateWithoutChildrenInput>
  }

  export type WorkItemUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWorkItemTypeFieldUpdateOperationsInput | $Enums.WorkItemType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    storyPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: WorkItemUpdateOneWithoutChildrenNestedInput
    epic?: WorkItemUpdateOneWithoutStoriesNestedInput
    stories?: WorkItemUpdateManyWithoutEpicNestedInput
    project?: ProjectUpdateOneRequiredWithoutWorkItemsNestedInput
    state?: WorkItemStateUpdateOneWithoutWorkItemsNestedInput
    assignee?: UserUpdateOneWithoutAssignedWorkItemsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedWorkItemsNestedInput
    sprint?: SprintUpdateOneWithoutWorkItemsNestedInput
    details?: WorkItemDetailUpdateOneWithoutWorkItemNestedInput
    dependenciesAsSource?: DependencyUpdateManyWithoutSourceItemNestedInput
    dependenciesAsTarget?: DependencyUpdateManyWithoutTargetItemNestedInput
    comments?: CommentUpdateManyWithoutWorkItemNestedInput
    attachments?: AttachmentUpdateManyWithoutWorkItemNestedInput
    timeLogs?: TimeLogUpdateManyWithoutWorkItemNestedInput
    snapshots?: WorkItemSnapshotUpdateManyWithoutWorkItemNestedInput
    tags?: TagOnWorkItemUpdateManyWithoutWorkItemNestedInput
    components?: ComponentOnWorkItemUpdateManyWithoutWorkItemNestedInput
    embedding?: WorkItemEmbeddingUpdateOneWithoutWorkItemNestedInput
  }

  export type WorkItemUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWorkItemTypeFieldUpdateOperationsInput | $Enums.WorkItemType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    storyPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    epicId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    stories?: WorkItemUncheckedUpdateManyWithoutEpicNestedInput
    details?: WorkItemDetailUncheckedUpdateOneWithoutWorkItemNestedInput
    dependenciesAsSource?: DependencyUncheckedUpdateManyWithoutSourceItemNestedInput
    dependenciesAsTarget?: DependencyUncheckedUpdateManyWithoutTargetItemNestedInput
    comments?: CommentUncheckedUpdateManyWithoutWorkItemNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutWorkItemNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutWorkItemNestedInput
    snapshots?: WorkItemSnapshotUncheckedUpdateManyWithoutWorkItemNestedInput
    tags?: TagOnWorkItemUncheckedUpdateManyWithoutWorkItemNestedInput
    components?: ComponentOnWorkItemUncheckedUpdateManyWithoutWorkItemNestedInput
    embedding?: WorkItemEmbeddingUncheckedUpdateOneWithoutWorkItemNestedInput
  }

  export type WorkItemUpsertWithWhereUniqueWithoutParentInput = {
    where: WorkItemWhereUniqueInput
    update: XOR<WorkItemUpdateWithoutParentInput, WorkItemUncheckedUpdateWithoutParentInput>
    create: XOR<WorkItemCreateWithoutParentInput, WorkItemUncheckedCreateWithoutParentInput>
  }

  export type WorkItemUpdateWithWhereUniqueWithoutParentInput = {
    where: WorkItemWhereUniqueInput
    data: XOR<WorkItemUpdateWithoutParentInput, WorkItemUncheckedUpdateWithoutParentInput>
  }

  export type WorkItemUpdateManyWithWhereWithoutParentInput = {
    where: WorkItemScalarWhereInput
    data: XOR<WorkItemUpdateManyMutationInput, WorkItemUncheckedUpdateManyWithoutParentInput>
  }

  export type WorkItemUpsertWithoutStoriesInput = {
    update: XOR<WorkItemUpdateWithoutStoriesInput, WorkItemUncheckedUpdateWithoutStoriesInput>
    create: XOR<WorkItemCreateWithoutStoriesInput, WorkItemUncheckedCreateWithoutStoriesInput>
    where?: WorkItemWhereInput
  }

  export type WorkItemUpdateToOneWithWhereWithoutStoriesInput = {
    where?: WorkItemWhereInput
    data: XOR<WorkItemUpdateWithoutStoriesInput, WorkItemUncheckedUpdateWithoutStoriesInput>
  }

  export type WorkItemUpdateWithoutStoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWorkItemTypeFieldUpdateOperationsInput | $Enums.WorkItemType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    storyPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: WorkItemUpdateOneWithoutChildrenNestedInput
    children?: WorkItemUpdateManyWithoutParentNestedInput
    epic?: WorkItemUpdateOneWithoutStoriesNestedInput
    project?: ProjectUpdateOneRequiredWithoutWorkItemsNestedInput
    state?: WorkItemStateUpdateOneWithoutWorkItemsNestedInput
    assignee?: UserUpdateOneWithoutAssignedWorkItemsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedWorkItemsNestedInput
    sprint?: SprintUpdateOneWithoutWorkItemsNestedInput
    details?: WorkItemDetailUpdateOneWithoutWorkItemNestedInput
    dependenciesAsSource?: DependencyUpdateManyWithoutSourceItemNestedInput
    dependenciesAsTarget?: DependencyUpdateManyWithoutTargetItemNestedInput
    comments?: CommentUpdateManyWithoutWorkItemNestedInput
    attachments?: AttachmentUpdateManyWithoutWorkItemNestedInput
    timeLogs?: TimeLogUpdateManyWithoutWorkItemNestedInput
    snapshots?: WorkItemSnapshotUpdateManyWithoutWorkItemNestedInput
    tags?: TagOnWorkItemUpdateManyWithoutWorkItemNestedInput
    components?: ComponentOnWorkItemUpdateManyWithoutWorkItemNestedInput
    embedding?: WorkItemEmbeddingUpdateOneWithoutWorkItemNestedInput
  }

  export type WorkItemUncheckedUpdateWithoutStoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWorkItemTypeFieldUpdateOperationsInput | $Enums.WorkItemType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    storyPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    epicId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: WorkItemUncheckedUpdateManyWithoutParentNestedInput
    details?: WorkItemDetailUncheckedUpdateOneWithoutWorkItemNestedInput
    dependenciesAsSource?: DependencyUncheckedUpdateManyWithoutSourceItemNestedInput
    dependenciesAsTarget?: DependencyUncheckedUpdateManyWithoutTargetItemNestedInput
    comments?: CommentUncheckedUpdateManyWithoutWorkItemNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutWorkItemNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutWorkItemNestedInput
    snapshots?: WorkItemSnapshotUncheckedUpdateManyWithoutWorkItemNestedInput
    tags?: TagOnWorkItemUncheckedUpdateManyWithoutWorkItemNestedInput
    components?: ComponentOnWorkItemUncheckedUpdateManyWithoutWorkItemNestedInput
    embedding?: WorkItemEmbeddingUncheckedUpdateOneWithoutWorkItemNestedInput
  }

  export type WorkItemUpsertWithWhereUniqueWithoutEpicInput = {
    where: WorkItemWhereUniqueInput
    update: XOR<WorkItemUpdateWithoutEpicInput, WorkItemUncheckedUpdateWithoutEpicInput>
    create: XOR<WorkItemCreateWithoutEpicInput, WorkItemUncheckedCreateWithoutEpicInput>
  }

  export type WorkItemUpdateWithWhereUniqueWithoutEpicInput = {
    where: WorkItemWhereUniqueInput
    data: XOR<WorkItemUpdateWithoutEpicInput, WorkItemUncheckedUpdateWithoutEpicInput>
  }

  export type WorkItemUpdateManyWithWhereWithoutEpicInput = {
    where: WorkItemScalarWhereInput
    data: XOR<WorkItemUpdateManyMutationInput, WorkItemUncheckedUpdateManyWithoutEpicInput>
  }

  export type ProjectUpsertWithoutWorkItemsInput = {
    update: XOR<ProjectUpdateWithoutWorkItemsInput, ProjectUncheckedUpdateWithoutWorkItemsInput>
    create: XOR<ProjectCreateWithoutWorkItemsInput, ProjectUncheckedCreateWithoutWorkItemsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutWorkItemsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutWorkItemsInput, ProjectUncheckedUpdateWithoutWorkItemsInput>
  }

  export type ProjectUpdateWithoutWorkItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    projectType?: StringFieldUpdateOperationsInput | string
    riskScore?: FloatFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolio?: PortfolioUpdateOneWithoutProjectsNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    leadUser?: UserUpdateOneWithoutOwnedProjectsNestedInput
    sprints?: SprintUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUpdateManyWithoutProjectNestedInput
    boards?: BoardUpdateManyWithoutProjectNestedInput
    workflowRules?: WorkflowRuleUpdateManyWithoutProjectNestedInput
    workItemStates?: WorkItemStateUpdateManyWithoutProjectNestedInput
    components?: ComponentUpdateManyWithoutProjectNestedInput
    teams?: TeamUpdateManyWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutWorkItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    projectType?: StringFieldUpdateOperationsInput | string
    riskScore?: FloatFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolioId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    leadUserId?: NullableStringFieldUpdateOperationsInput | string | null
    sprints?: SprintUncheckedUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutProjectNestedInput
    boards?: BoardUncheckedUpdateManyWithoutProjectNestedInput
    workflowRules?: WorkflowRuleUncheckedUpdateManyWithoutProjectNestedInput
    workItemStates?: WorkItemStateUncheckedUpdateManyWithoutProjectNestedInput
    components?: ComponentUncheckedUpdateManyWithoutProjectNestedInput
    teams?: TeamUncheckedUpdateManyWithoutProjectsNestedInput
  }

  export type WorkItemStateUpsertWithoutWorkItemsInput = {
    update: XOR<WorkItemStateUpdateWithoutWorkItemsInput, WorkItemStateUncheckedUpdateWithoutWorkItemsInput>
    create: XOR<WorkItemStateCreateWithoutWorkItemsInput, WorkItemStateUncheckedCreateWithoutWorkItemsInput>
    where?: WorkItemStateWhereInput
  }

  export type WorkItemStateUpdateToOneWithWhereWithoutWorkItemsInput = {
    where?: WorkItemStateWhereInput
    data: XOR<WorkItemStateUpdateWithoutWorkItemsInput, WorkItemStateUncheckedUpdateWithoutWorkItemsInput>
  }

  export type WorkItemStateUpdateWithoutWorkItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumWorkItemStateCategoryFieldUpdateOperationsInput | $Enums.WorkItemStateCategory
    position?: IntFieldUpdateOperationsInput | number
    wipLimit?: NullableIntFieldUpdateOperationsInput | number | null
    color?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isInitial?: BoolFieldUpdateOperationsInput | boolean
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutWorkItemStatesNestedInput
  }

  export type WorkItemStateUncheckedUpdateWithoutWorkItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumWorkItemStateCategoryFieldUpdateOperationsInput | $Enums.WorkItemStateCategory
    position?: IntFieldUpdateOperationsInput | number
    wipLimit?: NullableIntFieldUpdateOperationsInput | number | null
    color?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isInitial?: BoolFieldUpdateOperationsInput | boolean
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type UserUpsertWithoutAssignedWorkItemsInput = {
    update: XOR<UserUpdateWithoutAssignedWorkItemsInput, UserUncheckedUpdateWithoutAssignedWorkItemsInput>
    create: XOR<UserCreateWithoutAssignedWorkItemsInput, UserUncheckedCreateWithoutAssignedWorkItemsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedWorkItemsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedWorkItemsInput, UserUncheckedUpdateWithoutAssignedWorkItemsInput>
  }

  export type UserUpdateWithoutAssignedWorkItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    availabilityHours?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    organizationMemberships?: OrganizationMembershipUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMembershipUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUpdateManyWithoutLeadUserNestedInput
    createdWorkItems?: WorkItemUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    timeLogs?: TimeLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    skillProfile?: UserSkillProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedWorkItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    availabilityHours?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    organizationMemberships?: OrganizationMembershipUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMembershipUncheckedUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutLeadUserNestedInput
    createdWorkItems?: WorkItemUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    skillProfile?: UserSkillProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserUpsertWithoutCreatedWorkItemsInput = {
    update: XOR<UserUpdateWithoutCreatedWorkItemsInput, UserUncheckedUpdateWithoutCreatedWorkItemsInput>
    create: XOR<UserCreateWithoutCreatedWorkItemsInput, UserUncheckedCreateWithoutCreatedWorkItemsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedWorkItemsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedWorkItemsInput, UserUncheckedUpdateWithoutCreatedWorkItemsInput>
  }

  export type UserUpdateWithoutCreatedWorkItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    availabilityHours?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    organizationMemberships?: OrganizationMembershipUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMembershipUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUpdateManyWithoutLeadUserNestedInput
    assignedWorkItems?: WorkItemUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    timeLogs?: TimeLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    skillProfile?: UserSkillProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedWorkItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    availabilityHours?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    organizationMemberships?: OrganizationMembershipUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMembershipUncheckedUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutLeadUserNestedInput
    assignedWorkItems?: WorkItemUncheckedUpdateManyWithoutAssigneeNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    skillProfile?: UserSkillProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type SprintUpsertWithoutWorkItemsInput = {
    update: XOR<SprintUpdateWithoutWorkItemsInput, SprintUncheckedUpdateWithoutWorkItemsInput>
    create: XOR<SprintCreateWithoutWorkItemsInput, SprintUncheckedCreateWithoutWorkItemsInput>
    where?: SprintWhereInput
  }

  export type SprintUpdateToOneWithWhereWithoutWorkItemsInput = {
    where?: SprintWhereInput
    data: XOR<SprintUpdateWithoutWorkItemsInput, SprintUncheckedUpdateWithoutWorkItemsInput>
  }

  export type SprintUpdateWithoutWorkItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    goal?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: StringFieldUpdateOperationsInput | string
    committedPoints?: FloatFieldUpdateOperationsInput | number
    completedPoints?: FloatFieldUpdateOperationsInput | number
    velocity?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutSprintsNestedInput
    snapshots?: WorkItemSnapshotUpdateManyWithoutSprintNestedInput
    retrospective?: RetrospectiveUpdateOneWithoutSprintNestedInput
    timeLogs?: TimeLogUpdateManyWithoutSprintNestedInput
    boards?: BoardUpdateManyWithoutSprintNestedInput
  }

  export type SprintUncheckedUpdateWithoutWorkItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    goal?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: StringFieldUpdateOperationsInput | string
    committedPoints?: FloatFieldUpdateOperationsInput | number
    completedPoints?: FloatFieldUpdateOperationsInput | number
    velocity?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    snapshots?: WorkItemSnapshotUncheckedUpdateManyWithoutSprintNestedInput
    retrospective?: RetrospectiveUncheckedUpdateOneWithoutSprintNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutSprintNestedInput
    boards?: BoardUncheckedUpdateManyWithoutSprintNestedInput
  }

  export type WorkItemDetailUpsertWithoutWorkItemInput = {
    update: XOR<WorkItemDetailUpdateWithoutWorkItemInput, WorkItemDetailUncheckedUpdateWithoutWorkItemInput>
    create: XOR<WorkItemDetailCreateWithoutWorkItemInput, WorkItemDetailUncheckedCreateWithoutWorkItemInput>
    where?: WorkItemDetailWhereInput
  }

  export type WorkItemDetailUpdateToOneWithWhereWithoutWorkItemInput = {
    where?: WorkItemDetailWhereInput
    data: XOR<WorkItemDetailUpdateWithoutWorkItemInput, WorkItemDetailUncheckedUpdateWithoutWorkItemInput>
  }

  export type WorkItemDetailUpdateWithoutWorkItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    acceptanceCriteria?: NullableStringFieldUpdateOperationsInput | string | null
    technicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    reproSteps?: NullableStringFieldUpdateOperationsInput | string | null
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    userPersona?: NullableStringFieldUpdateOperationsInput | string | null
    customFields?: JsonNullValueInput | InputJsonValue
    externalReferences?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkItemDetailUncheckedUpdateWithoutWorkItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    acceptanceCriteria?: NullableStringFieldUpdateOperationsInput | string | null
    technicalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    reproSteps?: NullableStringFieldUpdateOperationsInput | string | null
    businessValue?: NullableStringFieldUpdateOperationsInput | string | null
    userPersona?: NullableStringFieldUpdateOperationsInput | string | null
    customFields?: JsonNullValueInput | InputJsonValue
    externalReferences?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DependencyUpsertWithWhereUniqueWithoutSourceItemInput = {
    where: DependencyWhereUniqueInput
    update: XOR<DependencyUpdateWithoutSourceItemInput, DependencyUncheckedUpdateWithoutSourceItemInput>
    create: XOR<DependencyCreateWithoutSourceItemInput, DependencyUncheckedCreateWithoutSourceItemInput>
  }

  export type DependencyUpdateWithWhereUniqueWithoutSourceItemInput = {
    where: DependencyWhereUniqueInput
    data: XOR<DependencyUpdateWithoutSourceItemInput, DependencyUncheckedUpdateWithoutSourceItemInput>
  }

  export type DependencyUpdateManyWithWhereWithoutSourceItemInput = {
    where: DependencyScalarWhereInput
    data: XOR<DependencyUpdateManyMutationInput, DependencyUncheckedUpdateManyWithoutSourceItemInput>
  }

  export type DependencyScalarWhereInput = {
    AND?: DependencyScalarWhereInput | DependencyScalarWhereInput[]
    OR?: DependencyScalarWhereInput[]
    NOT?: DependencyScalarWhereInput | DependencyScalarWhereInput[]
    id?: StringFilter<"Dependency"> | string
    dependencyType?: StringFilter<"Dependency"> | string
    description?: StringNullableFilter<"Dependency"> | string | null
    createdAt?: DateTimeFilter<"Dependency"> | Date | string
    sourceItemId?: StringFilter<"Dependency"> | string
    targetItemId?: StringFilter<"Dependency"> | string
  }

  export type DependencyUpsertWithWhereUniqueWithoutTargetItemInput = {
    where: DependencyWhereUniqueInput
    update: XOR<DependencyUpdateWithoutTargetItemInput, DependencyUncheckedUpdateWithoutTargetItemInput>
    create: XOR<DependencyCreateWithoutTargetItemInput, DependencyUncheckedCreateWithoutTargetItemInput>
  }

  export type DependencyUpdateWithWhereUniqueWithoutTargetItemInput = {
    where: DependencyWhereUniqueInput
    data: XOR<DependencyUpdateWithoutTargetItemInput, DependencyUncheckedUpdateWithoutTargetItemInput>
  }

  export type DependencyUpdateManyWithWhereWithoutTargetItemInput = {
    where: DependencyScalarWhereInput
    data: XOR<DependencyUpdateManyMutationInput, DependencyUncheckedUpdateManyWithoutTargetItemInput>
  }

  export type CommentUpsertWithWhereUniqueWithoutWorkItemInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutWorkItemInput, CommentUncheckedUpdateWithoutWorkItemInput>
    create: XOR<CommentCreateWithoutWorkItemInput, CommentUncheckedCreateWithoutWorkItemInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutWorkItemInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutWorkItemInput, CommentUncheckedUpdateWithoutWorkItemInput>
  }

  export type CommentUpdateManyWithWhereWithoutWorkItemInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutWorkItemInput>
  }

  export type AttachmentUpsertWithWhereUniqueWithoutWorkItemInput = {
    where: AttachmentWhereUniqueInput
    update: XOR<AttachmentUpdateWithoutWorkItemInput, AttachmentUncheckedUpdateWithoutWorkItemInput>
    create: XOR<AttachmentCreateWithoutWorkItemInput, AttachmentUncheckedCreateWithoutWorkItemInput>
  }

  export type AttachmentUpdateWithWhereUniqueWithoutWorkItemInput = {
    where: AttachmentWhereUniqueInput
    data: XOR<AttachmentUpdateWithoutWorkItemInput, AttachmentUncheckedUpdateWithoutWorkItemInput>
  }

  export type AttachmentUpdateManyWithWhereWithoutWorkItemInput = {
    where: AttachmentScalarWhereInput
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyWithoutWorkItemInput>
  }

  export type AttachmentScalarWhereInput = {
    AND?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
    OR?: AttachmentScalarWhereInput[]
    NOT?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
    id?: StringFilter<"Attachment"> | string
    fileName?: StringFilter<"Attachment"> | string
    fileType?: StringFilter<"Attachment"> | string
    fileSize?: IntFilter<"Attachment"> | number
    storagePath?: StringFilter<"Attachment"> | string
    fileUrl?: StringFilter<"Attachment"> | string
    ocrContent?: StringNullableFilter<"Attachment"> | string | null
    metadata?: JsonFilter<"Attachment">
    createdAt?: DateTimeFilter<"Attachment"> | Date | string
    workItemId?: StringFilter<"Attachment"> | string
    uploadedBy?: StringFilter<"Attachment"> | string
  }

  export type TimeLogUpsertWithWhereUniqueWithoutWorkItemInput = {
    where: TimeLogWhereUniqueInput
    update: XOR<TimeLogUpdateWithoutWorkItemInput, TimeLogUncheckedUpdateWithoutWorkItemInput>
    create: XOR<TimeLogCreateWithoutWorkItemInput, TimeLogUncheckedCreateWithoutWorkItemInput>
  }

  export type TimeLogUpdateWithWhereUniqueWithoutWorkItemInput = {
    where: TimeLogWhereUniqueInput
    data: XOR<TimeLogUpdateWithoutWorkItemInput, TimeLogUncheckedUpdateWithoutWorkItemInput>
  }

  export type TimeLogUpdateManyWithWhereWithoutWorkItemInput = {
    where: TimeLogScalarWhereInput
    data: XOR<TimeLogUpdateManyMutationInput, TimeLogUncheckedUpdateManyWithoutWorkItemInput>
  }

  export type WorkItemSnapshotUpsertWithWhereUniqueWithoutWorkItemInput = {
    where: WorkItemSnapshotWhereUniqueInput
    update: XOR<WorkItemSnapshotUpdateWithoutWorkItemInput, WorkItemSnapshotUncheckedUpdateWithoutWorkItemInput>
    create: XOR<WorkItemSnapshotCreateWithoutWorkItemInput, WorkItemSnapshotUncheckedCreateWithoutWorkItemInput>
  }

  export type WorkItemSnapshotUpdateWithWhereUniqueWithoutWorkItemInput = {
    where: WorkItemSnapshotWhereUniqueInput
    data: XOR<WorkItemSnapshotUpdateWithoutWorkItemInput, WorkItemSnapshotUncheckedUpdateWithoutWorkItemInput>
  }

  export type WorkItemSnapshotUpdateManyWithWhereWithoutWorkItemInput = {
    where: WorkItemSnapshotScalarWhereInput
    data: XOR<WorkItemSnapshotUpdateManyMutationInput, WorkItemSnapshotUncheckedUpdateManyWithoutWorkItemInput>
  }

  export type TagOnWorkItemUpsertWithWhereUniqueWithoutWorkItemInput = {
    where: TagOnWorkItemWhereUniqueInput
    update: XOR<TagOnWorkItemUpdateWithoutWorkItemInput, TagOnWorkItemUncheckedUpdateWithoutWorkItemInput>
    create: XOR<TagOnWorkItemCreateWithoutWorkItemInput, TagOnWorkItemUncheckedCreateWithoutWorkItemInput>
  }

  export type TagOnWorkItemUpdateWithWhereUniqueWithoutWorkItemInput = {
    where: TagOnWorkItemWhereUniqueInput
    data: XOR<TagOnWorkItemUpdateWithoutWorkItemInput, TagOnWorkItemUncheckedUpdateWithoutWorkItemInput>
  }

  export type TagOnWorkItemUpdateManyWithWhereWithoutWorkItemInput = {
    where: TagOnWorkItemScalarWhereInput
    data: XOR<TagOnWorkItemUpdateManyMutationInput, TagOnWorkItemUncheckedUpdateManyWithoutWorkItemInput>
  }

  export type TagOnWorkItemScalarWhereInput = {
    AND?: TagOnWorkItemScalarWhereInput | TagOnWorkItemScalarWhereInput[]
    OR?: TagOnWorkItemScalarWhereInput[]
    NOT?: TagOnWorkItemScalarWhereInput | TagOnWorkItemScalarWhereInput[]
    workItemId?: StringFilter<"TagOnWorkItem"> | string
    tagId?: StringFilter<"TagOnWorkItem"> | string
  }

  export type ComponentOnWorkItemUpsertWithWhereUniqueWithoutWorkItemInput = {
    where: ComponentOnWorkItemWhereUniqueInput
    update: XOR<ComponentOnWorkItemUpdateWithoutWorkItemInput, ComponentOnWorkItemUncheckedUpdateWithoutWorkItemInput>
    create: XOR<ComponentOnWorkItemCreateWithoutWorkItemInput, ComponentOnWorkItemUncheckedCreateWithoutWorkItemInput>
  }

  export type ComponentOnWorkItemUpdateWithWhereUniqueWithoutWorkItemInput = {
    where: ComponentOnWorkItemWhereUniqueInput
    data: XOR<ComponentOnWorkItemUpdateWithoutWorkItemInput, ComponentOnWorkItemUncheckedUpdateWithoutWorkItemInput>
  }

  export type ComponentOnWorkItemUpdateManyWithWhereWithoutWorkItemInput = {
    where: ComponentOnWorkItemScalarWhereInput
    data: XOR<ComponentOnWorkItemUpdateManyMutationInput, ComponentOnWorkItemUncheckedUpdateManyWithoutWorkItemInput>
  }

  export type ComponentOnWorkItemScalarWhereInput = {
    AND?: ComponentOnWorkItemScalarWhereInput | ComponentOnWorkItemScalarWhereInput[]
    OR?: ComponentOnWorkItemScalarWhereInput[]
    NOT?: ComponentOnWorkItemScalarWhereInput | ComponentOnWorkItemScalarWhereInput[]
    workItemId?: StringFilter<"ComponentOnWorkItem"> | string
    componentId?: StringFilter<"ComponentOnWorkItem"> | string
    assignedAt?: DateTimeFilter<"ComponentOnWorkItem"> | Date | string
  }

  export type WorkItemEmbeddingUpdateToOneWithWhereWithoutWorkItemInput = {
    where?: WorkItemEmbeddingWhereInput
    data: XOR<WorkItemEmbeddingUpdateWithoutWorkItemInput, WorkItemEmbeddingUncheckedUpdateWithoutWorkItemInput>
  }

  export type WorkItemEmbeddingUpdateWithoutWorkItemInput = {
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkItemEmbeddingUncheckedUpdateWithoutWorkItemInput = {
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkItemCreateWithoutDetailsInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.WorkItemType
    priority?: $Enums.Priority
    storyPoints?: number | null
    estimatedHours?: number | null
    remainingHours?: number | null
    order?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: WorkItemCreateNestedOneWithoutChildrenInput
    children?: WorkItemCreateNestedManyWithoutParentInput
    epic?: WorkItemCreateNestedOneWithoutStoriesInput
    stories?: WorkItemCreateNestedManyWithoutEpicInput
    project: ProjectCreateNestedOneWithoutWorkItemsInput
    state?: WorkItemStateCreateNestedOneWithoutWorkItemsInput
    assignee?: UserCreateNestedOneWithoutAssignedWorkItemsInput
    creator: UserCreateNestedOneWithoutCreatedWorkItemsInput
    sprint?: SprintCreateNestedOneWithoutWorkItemsInput
    dependenciesAsSource?: DependencyCreateNestedManyWithoutSourceItemInput
    dependenciesAsTarget?: DependencyCreateNestedManyWithoutTargetItemInput
    comments?: CommentCreateNestedManyWithoutWorkItemInput
    attachments?: AttachmentCreateNestedManyWithoutWorkItemInput
    timeLogs?: TimeLogCreateNestedManyWithoutWorkItemInput
    snapshots?: WorkItemSnapshotCreateNestedManyWithoutWorkItemInput
    tags?: TagOnWorkItemCreateNestedManyWithoutWorkItemInput
    components?: ComponentOnWorkItemCreateNestedManyWithoutWorkItemInput
    embedding?: WorkItemEmbeddingCreateNestedOneWithoutWorkItemInput
  }

  export type WorkItemUncheckedCreateWithoutDetailsInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.WorkItemType
    priority?: $Enums.Priority
    storyPoints?: number | null
    estimatedHours?: number | null
    remainingHours?: number | null
    order?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    epicId?: string | null
    projectId: string
    stateId?: string | null
    assigneeId?: string | null
    creatorId: string
    sprintId?: string | null
    children?: WorkItemUncheckedCreateNestedManyWithoutParentInput
    stories?: WorkItemUncheckedCreateNestedManyWithoutEpicInput
    dependenciesAsSource?: DependencyUncheckedCreateNestedManyWithoutSourceItemInput
    dependenciesAsTarget?: DependencyUncheckedCreateNestedManyWithoutTargetItemInput
    comments?: CommentUncheckedCreateNestedManyWithoutWorkItemInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutWorkItemInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutWorkItemInput
    snapshots?: WorkItemSnapshotUncheckedCreateNestedManyWithoutWorkItemInput
    tags?: TagOnWorkItemUncheckedCreateNestedManyWithoutWorkItemInput
    components?: ComponentOnWorkItemUncheckedCreateNestedManyWithoutWorkItemInput
    embedding?: WorkItemEmbeddingUncheckedCreateNestedOneWithoutWorkItemInput
  }

  export type WorkItemCreateOrConnectWithoutDetailsInput = {
    where: WorkItemWhereUniqueInput
    create: XOR<WorkItemCreateWithoutDetailsInput, WorkItemUncheckedCreateWithoutDetailsInput>
  }

  export type WorkItemUpsertWithoutDetailsInput = {
    update: XOR<WorkItemUpdateWithoutDetailsInput, WorkItemUncheckedUpdateWithoutDetailsInput>
    create: XOR<WorkItemCreateWithoutDetailsInput, WorkItemUncheckedCreateWithoutDetailsInput>
    where?: WorkItemWhereInput
  }

  export type WorkItemUpdateToOneWithWhereWithoutDetailsInput = {
    where?: WorkItemWhereInput
    data: XOR<WorkItemUpdateWithoutDetailsInput, WorkItemUncheckedUpdateWithoutDetailsInput>
  }

  export type WorkItemUpdateWithoutDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWorkItemTypeFieldUpdateOperationsInput | $Enums.WorkItemType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    storyPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: WorkItemUpdateOneWithoutChildrenNestedInput
    children?: WorkItemUpdateManyWithoutParentNestedInput
    epic?: WorkItemUpdateOneWithoutStoriesNestedInput
    stories?: WorkItemUpdateManyWithoutEpicNestedInput
    project?: ProjectUpdateOneRequiredWithoutWorkItemsNestedInput
    state?: WorkItemStateUpdateOneWithoutWorkItemsNestedInput
    assignee?: UserUpdateOneWithoutAssignedWorkItemsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedWorkItemsNestedInput
    sprint?: SprintUpdateOneWithoutWorkItemsNestedInput
    dependenciesAsSource?: DependencyUpdateManyWithoutSourceItemNestedInput
    dependenciesAsTarget?: DependencyUpdateManyWithoutTargetItemNestedInput
    comments?: CommentUpdateManyWithoutWorkItemNestedInput
    attachments?: AttachmentUpdateManyWithoutWorkItemNestedInput
    timeLogs?: TimeLogUpdateManyWithoutWorkItemNestedInput
    snapshots?: WorkItemSnapshotUpdateManyWithoutWorkItemNestedInput
    tags?: TagOnWorkItemUpdateManyWithoutWorkItemNestedInput
    components?: ComponentOnWorkItemUpdateManyWithoutWorkItemNestedInput
    embedding?: WorkItemEmbeddingUpdateOneWithoutWorkItemNestedInput
  }

  export type WorkItemUncheckedUpdateWithoutDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWorkItemTypeFieldUpdateOperationsInput | $Enums.WorkItemType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    storyPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    epicId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: WorkItemUncheckedUpdateManyWithoutParentNestedInput
    stories?: WorkItemUncheckedUpdateManyWithoutEpicNestedInput
    dependenciesAsSource?: DependencyUncheckedUpdateManyWithoutSourceItemNestedInput
    dependenciesAsTarget?: DependencyUncheckedUpdateManyWithoutTargetItemNestedInput
    comments?: CommentUncheckedUpdateManyWithoutWorkItemNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutWorkItemNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutWorkItemNestedInput
    snapshots?: WorkItemSnapshotUncheckedUpdateManyWithoutWorkItemNestedInput
    tags?: TagOnWorkItemUncheckedUpdateManyWithoutWorkItemNestedInput
    components?: ComponentOnWorkItemUncheckedUpdateManyWithoutWorkItemNestedInput
    embedding?: WorkItemEmbeddingUncheckedUpdateOneWithoutWorkItemNestedInput
  }

  export type ProjectCreateWithoutWorkItemStatesInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    projectType?: string
    riskScore?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    portfolio?: PortfolioCreateNestedOneWithoutProjectsInput
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    leadUser?: UserCreateNestedOneWithoutOwnedProjectsInput
    workItems?: WorkItemCreateNestedManyWithoutProjectInput
    sprints?: SprintCreateNestedManyWithoutProjectInput
    milestones?: MilestoneCreateNestedManyWithoutProjectInput
    boards?: BoardCreateNestedManyWithoutProjectInput
    workflowRules?: WorkflowRuleCreateNestedManyWithoutProjectInput
    components?: ComponentCreateNestedManyWithoutProjectInput
    teams?: TeamCreateNestedManyWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutWorkItemStatesInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    projectType?: string
    riskScore?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    portfolioId?: string | null
    organizationId: string
    leadUserId?: string | null
    workItems?: WorkItemUncheckedCreateNestedManyWithoutProjectInput
    sprints?: SprintUncheckedCreateNestedManyWithoutProjectInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutProjectInput
    boards?: BoardUncheckedCreateNestedManyWithoutProjectInput
    workflowRules?: WorkflowRuleUncheckedCreateNestedManyWithoutProjectInput
    components?: ComponentUncheckedCreateNestedManyWithoutProjectInput
    teams?: TeamUncheckedCreateNestedManyWithoutProjectsInput
  }

  export type ProjectCreateOrConnectWithoutWorkItemStatesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutWorkItemStatesInput, ProjectUncheckedCreateWithoutWorkItemStatesInput>
  }

  export type WorkItemCreateWithoutStateInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.WorkItemType
    priority?: $Enums.Priority
    storyPoints?: number | null
    estimatedHours?: number | null
    remainingHours?: number | null
    order?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: WorkItemCreateNestedOneWithoutChildrenInput
    children?: WorkItemCreateNestedManyWithoutParentInput
    epic?: WorkItemCreateNestedOneWithoutStoriesInput
    stories?: WorkItemCreateNestedManyWithoutEpicInput
    project: ProjectCreateNestedOneWithoutWorkItemsInput
    assignee?: UserCreateNestedOneWithoutAssignedWorkItemsInput
    creator: UserCreateNestedOneWithoutCreatedWorkItemsInput
    sprint?: SprintCreateNestedOneWithoutWorkItemsInput
    details?: WorkItemDetailCreateNestedOneWithoutWorkItemInput
    dependenciesAsSource?: DependencyCreateNestedManyWithoutSourceItemInput
    dependenciesAsTarget?: DependencyCreateNestedManyWithoutTargetItemInput
    comments?: CommentCreateNestedManyWithoutWorkItemInput
    attachments?: AttachmentCreateNestedManyWithoutWorkItemInput
    timeLogs?: TimeLogCreateNestedManyWithoutWorkItemInput
    snapshots?: WorkItemSnapshotCreateNestedManyWithoutWorkItemInput
    tags?: TagOnWorkItemCreateNestedManyWithoutWorkItemInput
    components?: ComponentOnWorkItemCreateNestedManyWithoutWorkItemInput
    embedding?: WorkItemEmbeddingCreateNestedOneWithoutWorkItemInput
  }

  export type WorkItemUncheckedCreateWithoutStateInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.WorkItemType
    priority?: $Enums.Priority
    storyPoints?: number | null
    estimatedHours?: number | null
    remainingHours?: number | null
    order?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    epicId?: string | null
    projectId: string
    assigneeId?: string | null
    creatorId: string
    sprintId?: string | null
    children?: WorkItemUncheckedCreateNestedManyWithoutParentInput
    stories?: WorkItemUncheckedCreateNestedManyWithoutEpicInput
    details?: WorkItemDetailUncheckedCreateNestedOneWithoutWorkItemInput
    dependenciesAsSource?: DependencyUncheckedCreateNestedManyWithoutSourceItemInput
    dependenciesAsTarget?: DependencyUncheckedCreateNestedManyWithoutTargetItemInput
    comments?: CommentUncheckedCreateNestedManyWithoutWorkItemInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutWorkItemInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutWorkItemInput
    snapshots?: WorkItemSnapshotUncheckedCreateNestedManyWithoutWorkItemInput
    tags?: TagOnWorkItemUncheckedCreateNestedManyWithoutWorkItemInput
    components?: ComponentOnWorkItemUncheckedCreateNestedManyWithoutWorkItemInput
    embedding?: WorkItemEmbeddingUncheckedCreateNestedOneWithoutWorkItemInput
  }

  export type WorkItemCreateOrConnectWithoutStateInput = {
    where: WorkItemWhereUniqueInput
    create: XOR<WorkItemCreateWithoutStateInput, WorkItemUncheckedCreateWithoutStateInput>
  }

  export type WorkItemCreateManyStateInputEnvelope = {
    data: WorkItemCreateManyStateInput | WorkItemCreateManyStateInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutWorkItemStatesInput = {
    update: XOR<ProjectUpdateWithoutWorkItemStatesInput, ProjectUncheckedUpdateWithoutWorkItemStatesInput>
    create: XOR<ProjectCreateWithoutWorkItemStatesInput, ProjectUncheckedCreateWithoutWorkItemStatesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutWorkItemStatesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutWorkItemStatesInput, ProjectUncheckedUpdateWithoutWorkItemStatesInput>
  }

  export type ProjectUpdateWithoutWorkItemStatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    projectType?: StringFieldUpdateOperationsInput | string
    riskScore?: FloatFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolio?: PortfolioUpdateOneWithoutProjectsNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    leadUser?: UserUpdateOneWithoutOwnedProjectsNestedInput
    workItems?: WorkItemUpdateManyWithoutProjectNestedInput
    sprints?: SprintUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUpdateManyWithoutProjectNestedInput
    boards?: BoardUpdateManyWithoutProjectNestedInput
    workflowRules?: WorkflowRuleUpdateManyWithoutProjectNestedInput
    components?: ComponentUpdateManyWithoutProjectNestedInput
    teams?: TeamUpdateManyWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutWorkItemStatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    projectType?: StringFieldUpdateOperationsInput | string
    riskScore?: FloatFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolioId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    leadUserId?: NullableStringFieldUpdateOperationsInput | string | null
    workItems?: WorkItemUncheckedUpdateManyWithoutProjectNestedInput
    sprints?: SprintUncheckedUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutProjectNestedInput
    boards?: BoardUncheckedUpdateManyWithoutProjectNestedInput
    workflowRules?: WorkflowRuleUncheckedUpdateManyWithoutProjectNestedInput
    components?: ComponentUncheckedUpdateManyWithoutProjectNestedInput
    teams?: TeamUncheckedUpdateManyWithoutProjectsNestedInput
  }

  export type WorkItemUpsertWithWhereUniqueWithoutStateInput = {
    where: WorkItemWhereUniqueInput
    update: XOR<WorkItemUpdateWithoutStateInput, WorkItemUncheckedUpdateWithoutStateInput>
    create: XOR<WorkItemCreateWithoutStateInput, WorkItemUncheckedCreateWithoutStateInput>
  }

  export type WorkItemUpdateWithWhereUniqueWithoutStateInput = {
    where: WorkItemWhereUniqueInput
    data: XOR<WorkItemUpdateWithoutStateInput, WorkItemUncheckedUpdateWithoutStateInput>
  }

  export type WorkItemUpdateManyWithWhereWithoutStateInput = {
    where: WorkItemScalarWhereInput
    data: XOR<WorkItemUpdateManyMutationInput, WorkItemUncheckedUpdateManyWithoutStateInput>
  }

  export type ProjectCreateWithoutBoardsInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    projectType?: string
    riskScore?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    portfolio?: PortfolioCreateNestedOneWithoutProjectsInput
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    leadUser?: UserCreateNestedOneWithoutOwnedProjectsInput
    workItems?: WorkItemCreateNestedManyWithoutProjectInput
    sprints?: SprintCreateNestedManyWithoutProjectInput
    milestones?: MilestoneCreateNestedManyWithoutProjectInput
    workflowRules?: WorkflowRuleCreateNestedManyWithoutProjectInput
    workItemStates?: WorkItemStateCreateNestedManyWithoutProjectInput
    components?: ComponentCreateNestedManyWithoutProjectInput
    teams?: TeamCreateNestedManyWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutBoardsInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    projectType?: string
    riskScore?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    portfolioId?: string | null
    organizationId: string
    leadUserId?: string | null
    workItems?: WorkItemUncheckedCreateNestedManyWithoutProjectInput
    sprints?: SprintUncheckedCreateNestedManyWithoutProjectInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutProjectInput
    workflowRules?: WorkflowRuleUncheckedCreateNestedManyWithoutProjectInput
    workItemStates?: WorkItemStateUncheckedCreateNestedManyWithoutProjectInput
    components?: ComponentUncheckedCreateNestedManyWithoutProjectInput
    teams?: TeamUncheckedCreateNestedManyWithoutProjectsInput
  }

  export type ProjectCreateOrConnectWithoutBoardsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutBoardsInput, ProjectUncheckedCreateWithoutBoardsInput>
  }

  export type SprintCreateWithoutBoardsInput = {
    id?: string
    name: string
    goal?: string | null
    startDate: Date | string
    endDate: Date | string
    state?: string
    committedPoints?: number
    completedPoints?: number
    velocity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutSprintsInput
    workItems?: WorkItemCreateNestedManyWithoutSprintInput
    snapshots?: WorkItemSnapshotCreateNestedManyWithoutSprintInput
    retrospective?: RetrospectiveCreateNestedOneWithoutSprintInput
    timeLogs?: TimeLogCreateNestedManyWithoutSprintInput
  }

  export type SprintUncheckedCreateWithoutBoardsInput = {
    id?: string
    name: string
    goal?: string | null
    startDate: Date | string
    endDate: Date | string
    state?: string
    committedPoints?: number
    completedPoints?: number
    velocity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    workItems?: WorkItemUncheckedCreateNestedManyWithoutSprintInput
    snapshots?: WorkItemSnapshotUncheckedCreateNestedManyWithoutSprintInput
    retrospective?: RetrospectiveUncheckedCreateNestedOneWithoutSprintInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutSprintInput
  }

  export type SprintCreateOrConnectWithoutBoardsInput = {
    where: SprintWhereUniqueInput
    create: XOR<SprintCreateWithoutBoardsInput, SprintUncheckedCreateWithoutBoardsInput>
  }

  export type BoardLaneCreateWithoutBoardInput = {
    id?: string
    name: string
    position: number
    wipLimit?: number | null
    colorConfig?: JsonNullValueInput | InputJsonValue
    mappedStates?: BoardLaneCreatemappedStatesInput | string[]
    isCollapsed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BoardLaneUncheckedCreateWithoutBoardInput = {
    id?: string
    name: string
    position: number
    wipLimit?: number | null
    colorConfig?: JsonNullValueInput | InputJsonValue
    mappedStates?: BoardLaneCreatemappedStatesInput | string[]
    isCollapsed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BoardLaneCreateOrConnectWithoutBoardInput = {
    where: BoardLaneWhereUniqueInput
    create: XOR<BoardLaneCreateWithoutBoardInput, BoardLaneUncheckedCreateWithoutBoardInput>
  }

  export type BoardLaneCreateManyBoardInputEnvelope = {
    data: BoardLaneCreateManyBoardInput | BoardLaneCreateManyBoardInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutBoardsInput = {
    update: XOR<ProjectUpdateWithoutBoardsInput, ProjectUncheckedUpdateWithoutBoardsInput>
    create: XOR<ProjectCreateWithoutBoardsInput, ProjectUncheckedCreateWithoutBoardsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutBoardsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutBoardsInput, ProjectUncheckedUpdateWithoutBoardsInput>
  }

  export type ProjectUpdateWithoutBoardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    projectType?: StringFieldUpdateOperationsInput | string
    riskScore?: FloatFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolio?: PortfolioUpdateOneWithoutProjectsNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    leadUser?: UserUpdateOneWithoutOwnedProjectsNestedInput
    workItems?: WorkItemUpdateManyWithoutProjectNestedInput
    sprints?: SprintUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUpdateManyWithoutProjectNestedInput
    workflowRules?: WorkflowRuleUpdateManyWithoutProjectNestedInput
    workItemStates?: WorkItemStateUpdateManyWithoutProjectNestedInput
    components?: ComponentUpdateManyWithoutProjectNestedInput
    teams?: TeamUpdateManyWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutBoardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    projectType?: StringFieldUpdateOperationsInput | string
    riskScore?: FloatFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolioId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    leadUserId?: NullableStringFieldUpdateOperationsInput | string | null
    workItems?: WorkItemUncheckedUpdateManyWithoutProjectNestedInput
    sprints?: SprintUncheckedUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutProjectNestedInput
    workflowRules?: WorkflowRuleUncheckedUpdateManyWithoutProjectNestedInput
    workItemStates?: WorkItemStateUncheckedUpdateManyWithoutProjectNestedInput
    components?: ComponentUncheckedUpdateManyWithoutProjectNestedInput
    teams?: TeamUncheckedUpdateManyWithoutProjectsNestedInput
  }

  export type SprintUpsertWithoutBoardsInput = {
    update: XOR<SprintUpdateWithoutBoardsInput, SprintUncheckedUpdateWithoutBoardsInput>
    create: XOR<SprintCreateWithoutBoardsInput, SprintUncheckedCreateWithoutBoardsInput>
    where?: SprintWhereInput
  }

  export type SprintUpdateToOneWithWhereWithoutBoardsInput = {
    where?: SprintWhereInput
    data: XOR<SprintUpdateWithoutBoardsInput, SprintUncheckedUpdateWithoutBoardsInput>
  }

  export type SprintUpdateWithoutBoardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    goal?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: StringFieldUpdateOperationsInput | string
    committedPoints?: FloatFieldUpdateOperationsInput | number
    completedPoints?: FloatFieldUpdateOperationsInput | number
    velocity?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutSprintsNestedInput
    workItems?: WorkItemUpdateManyWithoutSprintNestedInput
    snapshots?: WorkItemSnapshotUpdateManyWithoutSprintNestedInput
    retrospective?: RetrospectiveUpdateOneWithoutSprintNestedInput
    timeLogs?: TimeLogUpdateManyWithoutSprintNestedInput
  }

  export type SprintUncheckedUpdateWithoutBoardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    goal?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: StringFieldUpdateOperationsInput | string
    committedPoints?: FloatFieldUpdateOperationsInput | number
    completedPoints?: FloatFieldUpdateOperationsInput | number
    velocity?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    workItems?: WorkItemUncheckedUpdateManyWithoutSprintNestedInput
    snapshots?: WorkItemSnapshotUncheckedUpdateManyWithoutSprintNestedInput
    retrospective?: RetrospectiveUncheckedUpdateOneWithoutSprintNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutSprintNestedInput
  }

  export type BoardLaneUpsertWithWhereUniqueWithoutBoardInput = {
    where: BoardLaneWhereUniqueInput
    update: XOR<BoardLaneUpdateWithoutBoardInput, BoardLaneUncheckedUpdateWithoutBoardInput>
    create: XOR<BoardLaneCreateWithoutBoardInput, BoardLaneUncheckedCreateWithoutBoardInput>
  }

  export type BoardLaneUpdateWithWhereUniqueWithoutBoardInput = {
    where: BoardLaneWhereUniqueInput
    data: XOR<BoardLaneUpdateWithoutBoardInput, BoardLaneUncheckedUpdateWithoutBoardInput>
  }

  export type BoardLaneUpdateManyWithWhereWithoutBoardInput = {
    where: BoardLaneScalarWhereInput
    data: XOR<BoardLaneUpdateManyMutationInput, BoardLaneUncheckedUpdateManyWithoutBoardInput>
  }

  export type BoardLaneScalarWhereInput = {
    AND?: BoardLaneScalarWhereInput | BoardLaneScalarWhereInput[]
    OR?: BoardLaneScalarWhereInput[]
    NOT?: BoardLaneScalarWhereInput | BoardLaneScalarWhereInput[]
    id?: StringFilter<"BoardLane"> | string
    name?: StringFilter<"BoardLane"> | string
    position?: IntFilter<"BoardLane"> | number
    wipLimit?: IntNullableFilter<"BoardLane"> | number | null
    colorConfig?: JsonFilter<"BoardLane">
    mappedStates?: StringNullableListFilter<"BoardLane">
    isCollapsed?: BoolFilter<"BoardLane"> | boolean
    createdAt?: DateTimeFilter<"BoardLane"> | Date | string
    updatedAt?: DateTimeFilter<"BoardLane"> | Date | string
    boardId?: StringFilter<"BoardLane"> | string
  }

  export type BoardCreateWithoutLanesInput = {
    id?: string
    name: string
    boardType?: string
    filterQuery?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutBoardsInput
    sprint?: SprintCreateNestedOneWithoutBoardsInput
  }

  export type BoardUncheckedCreateWithoutLanesInput = {
    id?: string
    name: string
    boardType?: string
    filterQuery?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    sprintId?: string | null
  }

  export type BoardCreateOrConnectWithoutLanesInput = {
    where: BoardWhereUniqueInput
    create: XOR<BoardCreateWithoutLanesInput, BoardUncheckedCreateWithoutLanesInput>
  }

  export type BoardUpsertWithoutLanesInput = {
    update: XOR<BoardUpdateWithoutLanesInput, BoardUncheckedUpdateWithoutLanesInput>
    create: XOR<BoardCreateWithoutLanesInput, BoardUncheckedCreateWithoutLanesInput>
    where?: BoardWhereInput
  }

  export type BoardUpdateToOneWithWhereWithoutLanesInput = {
    where?: BoardWhereInput
    data: XOR<BoardUpdateWithoutLanesInput, BoardUncheckedUpdateWithoutLanesInput>
  }

  export type BoardUpdateWithoutLanesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    boardType?: StringFieldUpdateOperationsInput | string
    filterQuery?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutBoardsNestedInput
    sprint?: SprintUpdateOneWithoutBoardsNestedInput
  }

  export type BoardUncheckedUpdateWithoutLanesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    boardType?: StringFieldUpdateOperationsInput | string
    filterQuery?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TagOnWorkItemCreateWithoutTagInput = {
    workItem: WorkItemCreateNestedOneWithoutTagsInput
  }

  export type TagOnWorkItemUncheckedCreateWithoutTagInput = {
    workItemId: string
  }

  export type TagOnWorkItemCreateOrConnectWithoutTagInput = {
    where: TagOnWorkItemWhereUniqueInput
    create: XOR<TagOnWorkItemCreateWithoutTagInput, TagOnWorkItemUncheckedCreateWithoutTagInput>
  }

  export type TagOnWorkItemCreateManyTagInputEnvelope = {
    data: TagOnWorkItemCreateManyTagInput | TagOnWorkItemCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type TagOnWorkItemUpsertWithWhereUniqueWithoutTagInput = {
    where: TagOnWorkItemWhereUniqueInput
    update: XOR<TagOnWorkItemUpdateWithoutTagInput, TagOnWorkItemUncheckedUpdateWithoutTagInput>
    create: XOR<TagOnWorkItemCreateWithoutTagInput, TagOnWorkItemUncheckedCreateWithoutTagInput>
  }

  export type TagOnWorkItemUpdateWithWhereUniqueWithoutTagInput = {
    where: TagOnWorkItemWhereUniqueInput
    data: XOR<TagOnWorkItemUpdateWithoutTagInput, TagOnWorkItemUncheckedUpdateWithoutTagInput>
  }

  export type TagOnWorkItemUpdateManyWithWhereWithoutTagInput = {
    where: TagOnWorkItemScalarWhereInput
    data: XOR<TagOnWorkItemUpdateManyMutationInput, TagOnWorkItemUncheckedUpdateManyWithoutTagInput>
  }

  export type WorkItemCreateWithoutTagsInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.WorkItemType
    priority?: $Enums.Priority
    storyPoints?: number | null
    estimatedHours?: number | null
    remainingHours?: number | null
    order?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: WorkItemCreateNestedOneWithoutChildrenInput
    children?: WorkItemCreateNestedManyWithoutParentInput
    epic?: WorkItemCreateNestedOneWithoutStoriesInput
    stories?: WorkItemCreateNestedManyWithoutEpicInput
    project: ProjectCreateNestedOneWithoutWorkItemsInput
    state?: WorkItemStateCreateNestedOneWithoutWorkItemsInput
    assignee?: UserCreateNestedOneWithoutAssignedWorkItemsInput
    creator: UserCreateNestedOneWithoutCreatedWorkItemsInput
    sprint?: SprintCreateNestedOneWithoutWorkItemsInput
    details?: WorkItemDetailCreateNestedOneWithoutWorkItemInput
    dependenciesAsSource?: DependencyCreateNestedManyWithoutSourceItemInput
    dependenciesAsTarget?: DependencyCreateNestedManyWithoutTargetItemInput
    comments?: CommentCreateNestedManyWithoutWorkItemInput
    attachments?: AttachmentCreateNestedManyWithoutWorkItemInput
    timeLogs?: TimeLogCreateNestedManyWithoutWorkItemInput
    snapshots?: WorkItemSnapshotCreateNestedManyWithoutWorkItemInput
    components?: ComponentOnWorkItemCreateNestedManyWithoutWorkItemInput
    embedding?: WorkItemEmbeddingCreateNestedOneWithoutWorkItemInput
  }

  export type WorkItemUncheckedCreateWithoutTagsInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.WorkItemType
    priority?: $Enums.Priority
    storyPoints?: number | null
    estimatedHours?: number | null
    remainingHours?: number | null
    order?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    epicId?: string | null
    projectId: string
    stateId?: string | null
    assigneeId?: string | null
    creatorId: string
    sprintId?: string | null
    children?: WorkItemUncheckedCreateNestedManyWithoutParentInput
    stories?: WorkItemUncheckedCreateNestedManyWithoutEpicInput
    details?: WorkItemDetailUncheckedCreateNestedOneWithoutWorkItemInput
    dependenciesAsSource?: DependencyUncheckedCreateNestedManyWithoutSourceItemInput
    dependenciesAsTarget?: DependencyUncheckedCreateNestedManyWithoutTargetItemInput
    comments?: CommentUncheckedCreateNestedManyWithoutWorkItemInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutWorkItemInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutWorkItemInput
    snapshots?: WorkItemSnapshotUncheckedCreateNestedManyWithoutWorkItemInput
    components?: ComponentOnWorkItemUncheckedCreateNestedManyWithoutWorkItemInput
    embedding?: WorkItemEmbeddingUncheckedCreateNestedOneWithoutWorkItemInput
  }

  export type WorkItemCreateOrConnectWithoutTagsInput = {
    where: WorkItemWhereUniqueInput
    create: XOR<WorkItemCreateWithoutTagsInput, WorkItemUncheckedCreateWithoutTagsInput>
  }

  export type TagCreateWithoutWorkItemsInput = {
    id?: string
    name: string
    color?: string
    description?: string | null
    createdAt?: Date | string
  }

  export type TagUncheckedCreateWithoutWorkItemsInput = {
    id?: string
    name: string
    color?: string
    description?: string | null
    createdAt?: Date | string
  }

  export type TagCreateOrConnectWithoutWorkItemsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutWorkItemsInput, TagUncheckedCreateWithoutWorkItemsInput>
  }

  export type WorkItemUpsertWithoutTagsInput = {
    update: XOR<WorkItemUpdateWithoutTagsInput, WorkItemUncheckedUpdateWithoutTagsInput>
    create: XOR<WorkItemCreateWithoutTagsInput, WorkItemUncheckedCreateWithoutTagsInput>
    where?: WorkItemWhereInput
  }

  export type WorkItemUpdateToOneWithWhereWithoutTagsInput = {
    where?: WorkItemWhereInput
    data: XOR<WorkItemUpdateWithoutTagsInput, WorkItemUncheckedUpdateWithoutTagsInput>
  }

  export type WorkItemUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWorkItemTypeFieldUpdateOperationsInput | $Enums.WorkItemType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    storyPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: WorkItemUpdateOneWithoutChildrenNestedInput
    children?: WorkItemUpdateManyWithoutParentNestedInput
    epic?: WorkItemUpdateOneWithoutStoriesNestedInput
    stories?: WorkItemUpdateManyWithoutEpicNestedInput
    project?: ProjectUpdateOneRequiredWithoutWorkItemsNestedInput
    state?: WorkItemStateUpdateOneWithoutWorkItemsNestedInput
    assignee?: UserUpdateOneWithoutAssignedWorkItemsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedWorkItemsNestedInput
    sprint?: SprintUpdateOneWithoutWorkItemsNestedInput
    details?: WorkItemDetailUpdateOneWithoutWorkItemNestedInput
    dependenciesAsSource?: DependencyUpdateManyWithoutSourceItemNestedInput
    dependenciesAsTarget?: DependencyUpdateManyWithoutTargetItemNestedInput
    comments?: CommentUpdateManyWithoutWorkItemNestedInput
    attachments?: AttachmentUpdateManyWithoutWorkItemNestedInput
    timeLogs?: TimeLogUpdateManyWithoutWorkItemNestedInput
    snapshots?: WorkItemSnapshotUpdateManyWithoutWorkItemNestedInput
    components?: ComponentOnWorkItemUpdateManyWithoutWorkItemNestedInput
    embedding?: WorkItemEmbeddingUpdateOneWithoutWorkItemNestedInput
  }

  export type WorkItemUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWorkItemTypeFieldUpdateOperationsInput | $Enums.WorkItemType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    storyPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    epicId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: WorkItemUncheckedUpdateManyWithoutParentNestedInput
    stories?: WorkItemUncheckedUpdateManyWithoutEpicNestedInput
    details?: WorkItemDetailUncheckedUpdateOneWithoutWorkItemNestedInput
    dependenciesAsSource?: DependencyUncheckedUpdateManyWithoutSourceItemNestedInput
    dependenciesAsTarget?: DependencyUncheckedUpdateManyWithoutTargetItemNestedInput
    comments?: CommentUncheckedUpdateManyWithoutWorkItemNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutWorkItemNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutWorkItemNestedInput
    snapshots?: WorkItemSnapshotUncheckedUpdateManyWithoutWorkItemNestedInput
    components?: ComponentOnWorkItemUncheckedUpdateManyWithoutWorkItemNestedInput
    embedding?: WorkItemEmbeddingUncheckedUpdateOneWithoutWorkItemNestedInput
  }

  export type TagUpsertWithoutWorkItemsInput = {
    update: XOR<TagUpdateWithoutWorkItemsInput, TagUncheckedUpdateWithoutWorkItemsInput>
    create: XOR<TagCreateWithoutWorkItemsInput, TagUncheckedCreateWithoutWorkItemsInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutWorkItemsInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutWorkItemsInput, TagUncheckedUpdateWithoutWorkItemsInput>
  }

  export type TagUpdateWithoutWorkItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateWithoutWorkItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateWithoutComponentsInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    projectType?: string
    riskScore?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    portfolio?: PortfolioCreateNestedOneWithoutProjectsInput
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    leadUser?: UserCreateNestedOneWithoutOwnedProjectsInput
    workItems?: WorkItemCreateNestedManyWithoutProjectInput
    sprints?: SprintCreateNestedManyWithoutProjectInput
    milestones?: MilestoneCreateNestedManyWithoutProjectInput
    boards?: BoardCreateNestedManyWithoutProjectInput
    workflowRules?: WorkflowRuleCreateNestedManyWithoutProjectInput
    workItemStates?: WorkItemStateCreateNestedManyWithoutProjectInput
    teams?: TeamCreateNestedManyWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutComponentsInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    projectType?: string
    riskScore?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    portfolioId?: string | null
    organizationId: string
    leadUserId?: string | null
    workItems?: WorkItemUncheckedCreateNestedManyWithoutProjectInput
    sprints?: SprintUncheckedCreateNestedManyWithoutProjectInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutProjectInput
    boards?: BoardUncheckedCreateNestedManyWithoutProjectInput
    workflowRules?: WorkflowRuleUncheckedCreateNestedManyWithoutProjectInput
    workItemStates?: WorkItemStateUncheckedCreateNestedManyWithoutProjectInput
    teams?: TeamUncheckedCreateNestedManyWithoutProjectsInput
  }

  export type ProjectCreateOrConnectWithoutComponentsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutComponentsInput, ProjectUncheckedCreateWithoutComponentsInput>
  }

  export type ComponentOnWorkItemCreateWithoutComponentInput = {
    assignedAt?: Date | string
    workItem: WorkItemCreateNestedOneWithoutComponentsInput
  }

  export type ComponentOnWorkItemUncheckedCreateWithoutComponentInput = {
    workItemId: string
    assignedAt?: Date | string
  }

  export type ComponentOnWorkItemCreateOrConnectWithoutComponentInput = {
    where: ComponentOnWorkItemWhereUniqueInput
    create: XOR<ComponentOnWorkItemCreateWithoutComponentInput, ComponentOnWorkItemUncheckedCreateWithoutComponentInput>
  }

  export type ComponentOnWorkItemCreateManyComponentInputEnvelope = {
    data: ComponentOnWorkItemCreateManyComponentInput | ComponentOnWorkItemCreateManyComponentInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutComponentsInput = {
    update: XOR<ProjectUpdateWithoutComponentsInput, ProjectUncheckedUpdateWithoutComponentsInput>
    create: XOR<ProjectCreateWithoutComponentsInput, ProjectUncheckedCreateWithoutComponentsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutComponentsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutComponentsInput, ProjectUncheckedUpdateWithoutComponentsInput>
  }

  export type ProjectUpdateWithoutComponentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    projectType?: StringFieldUpdateOperationsInput | string
    riskScore?: FloatFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolio?: PortfolioUpdateOneWithoutProjectsNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    leadUser?: UserUpdateOneWithoutOwnedProjectsNestedInput
    workItems?: WorkItemUpdateManyWithoutProjectNestedInput
    sprints?: SprintUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUpdateManyWithoutProjectNestedInput
    boards?: BoardUpdateManyWithoutProjectNestedInput
    workflowRules?: WorkflowRuleUpdateManyWithoutProjectNestedInput
    workItemStates?: WorkItemStateUpdateManyWithoutProjectNestedInput
    teams?: TeamUpdateManyWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutComponentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    projectType?: StringFieldUpdateOperationsInput | string
    riskScore?: FloatFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolioId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    leadUserId?: NullableStringFieldUpdateOperationsInput | string | null
    workItems?: WorkItemUncheckedUpdateManyWithoutProjectNestedInput
    sprints?: SprintUncheckedUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutProjectNestedInput
    boards?: BoardUncheckedUpdateManyWithoutProjectNestedInput
    workflowRules?: WorkflowRuleUncheckedUpdateManyWithoutProjectNestedInput
    workItemStates?: WorkItemStateUncheckedUpdateManyWithoutProjectNestedInput
    teams?: TeamUncheckedUpdateManyWithoutProjectsNestedInput
  }

  export type ComponentOnWorkItemUpsertWithWhereUniqueWithoutComponentInput = {
    where: ComponentOnWorkItemWhereUniqueInput
    update: XOR<ComponentOnWorkItemUpdateWithoutComponentInput, ComponentOnWorkItemUncheckedUpdateWithoutComponentInput>
    create: XOR<ComponentOnWorkItemCreateWithoutComponentInput, ComponentOnWorkItemUncheckedCreateWithoutComponentInput>
  }

  export type ComponentOnWorkItemUpdateWithWhereUniqueWithoutComponentInput = {
    where: ComponentOnWorkItemWhereUniqueInput
    data: XOR<ComponentOnWorkItemUpdateWithoutComponentInput, ComponentOnWorkItemUncheckedUpdateWithoutComponentInput>
  }

  export type ComponentOnWorkItemUpdateManyWithWhereWithoutComponentInput = {
    where: ComponentOnWorkItemScalarWhereInput
    data: XOR<ComponentOnWorkItemUpdateManyMutationInput, ComponentOnWorkItemUncheckedUpdateManyWithoutComponentInput>
  }

  export type WorkItemCreateWithoutComponentsInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.WorkItemType
    priority?: $Enums.Priority
    storyPoints?: number | null
    estimatedHours?: number | null
    remainingHours?: number | null
    order?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: WorkItemCreateNestedOneWithoutChildrenInput
    children?: WorkItemCreateNestedManyWithoutParentInput
    epic?: WorkItemCreateNestedOneWithoutStoriesInput
    stories?: WorkItemCreateNestedManyWithoutEpicInput
    project: ProjectCreateNestedOneWithoutWorkItemsInput
    state?: WorkItemStateCreateNestedOneWithoutWorkItemsInput
    assignee?: UserCreateNestedOneWithoutAssignedWorkItemsInput
    creator: UserCreateNestedOneWithoutCreatedWorkItemsInput
    sprint?: SprintCreateNestedOneWithoutWorkItemsInput
    details?: WorkItemDetailCreateNestedOneWithoutWorkItemInput
    dependenciesAsSource?: DependencyCreateNestedManyWithoutSourceItemInput
    dependenciesAsTarget?: DependencyCreateNestedManyWithoutTargetItemInput
    comments?: CommentCreateNestedManyWithoutWorkItemInput
    attachments?: AttachmentCreateNestedManyWithoutWorkItemInput
    timeLogs?: TimeLogCreateNestedManyWithoutWorkItemInput
    snapshots?: WorkItemSnapshotCreateNestedManyWithoutWorkItemInput
    tags?: TagOnWorkItemCreateNestedManyWithoutWorkItemInput
    embedding?: WorkItemEmbeddingCreateNestedOneWithoutWorkItemInput
  }

  export type WorkItemUncheckedCreateWithoutComponentsInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.WorkItemType
    priority?: $Enums.Priority
    storyPoints?: number | null
    estimatedHours?: number | null
    remainingHours?: number | null
    order?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    epicId?: string | null
    projectId: string
    stateId?: string | null
    assigneeId?: string | null
    creatorId: string
    sprintId?: string | null
    children?: WorkItemUncheckedCreateNestedManyWithoutParentInput
    stories?: WorkItemUncheckedCreateNestedManyWithoutEpicInput
    details?: WorkItemDetailUncheckedCreateNestedOneWithoutWorkItemInput
    dependenciesAsSource?: DependencyUncheckedCreateNestedManyWithoutSourceItemInput
    dependenciesAsTarget?: DependencyUncheckedCreateNestedManyWithoutTargetItemInput
    comments?: CommentUncheckedCreateNestedManyWithoutWorkItemInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutWorkItemInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutWorkItemInput
    snapshots?: WorkItemSnapshotUncheckedCreateNestedManyWithoutWorkItemInput
    tags?: TagOnWorkItemUncheckedCreateNestedManyWithoutWorkItemInput
    embedding?: WorkItemEmbeddingUncheckedCreateNestedOneWithoutWorkItemInput
  }

  export type WorkItemCreateOrConnectWithoutComponentsInput = {
    where: WorkItemWhereUniqueInput
    create: XOR<WorkItemCreateWithoutComponentsInput, WorkItemUncheckedCreateWithoutComponentsInput>
  }

  export type ComponentCreateWithoutWorkItemsInput = {
    id?: string
    name: string
    description?: string | null
    color?: string
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutComponentsInput
  }

  export type ComponentUncheckedCreateWithoutWorkItemsInput = {
    id?: string
    name: string
    description?: string | null
    color?: string
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type ComponentCreateOrConnectWithoutWorkItemsInput = {
    where: ComponentWhereUniqueInput
    create: XOR<ComponentCreateWithoutWorkItemsInput, ComponentUncheckedCreateWithoutWorkItemsInput>
  }

  export type WorkItemUpsertWithoutComponentsInput = {
    update: XOR<WorkItemUpdateWithoutComponentsInput, WorkItemUncheckedUpdateWithoutComponentsInput>
    create: XOR<WorkItemCreateWithoutComponentsInput, WorkItemUncheckedCreateWithoutComponentsInput>
    where?: WorkItemWhereInput
  }

  export type WorkItemUpdateToOneWithWhereWithoutComponentsInput = {
    where?: WorkItemWhereInput
    data: XOR<WorkItemUpdateWithoutComponentsInput, WorkItemUncheckedUpdateWithoutComponentsInput>
  }

  export type WorkItemUpdateWithoutComponentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWorkItemTypeFieldUpdateOperationsInput | $Enums.WorkItemType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    storyPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: WorkItemUpdateOneWithoutChildrenNestedInput
    children?: WorkItemUpdateManyWithoutParentNestedInput
    epic?: WorkItemUpdateOneWithoutStoriesNestedInput
    stories?: WorkItemUpdateManyWithoutEpicNestedInput
    project?: ProjectUpdateOneRequiredWithoutWorkItemsNestedInput
    state?: WorkItemStateUpdateOneWithoutWorkItemsNestedInput
    assignee?: UserUpdateOneWithoutAssignedWorkItemsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedWorkItemsNestedInput
    sprint?: SprintUpdateOneWithoutWorkItemsNestedInput
    details?: WorkItemDetailUpdateOneWithoutWorkItemNestedInput
    dependenciesAsSource?: DependencyUpdateManyWithoutSourceItemNestedInput
    dependenciesAsTarget?: DependencyUpdateManyWithoutTargetItemNestedInput
    comments?: CommentUpdateManyWithoutWorkItemNestedInput
    attachments?: AttachmentUpdateManyWithoutWorkItemNestedInput
    timeLogs?: TimeLogUpdateManyWithoutWorkItemNestedInput
    snapshots?: WorkItemSnapshotUpdateManyWithoutWorkItemNestedInput
    tags?: TagOnWorkItemUpdateManyWithoutWorkItemNestedInput
    embedding?: WorkItemEmbeddingUpdateOneWithoutWorkItemNestedInput
  }

  export type WorkItemUncheckedUpdateWithoutComponentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWorkItemTypeFieldUpdateOperationsInput | $Enums.WorkItemType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    storyPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    epicId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: WorkItemUncheckedUpdateManyWithoutParentNestedInput
    stories?: WorkItemUncheckedUpdateManyWithoutEpicNestedInput
    details?: WorkItemDetailUncheckedUpdateOneWithoutWorkItemNestedInput
    dependenciesAsSource?: DependencyUncheckedUpdateManyWithoutSourceItemNestedInput
    dependenciesAsTarget?: DependencyUncheckedUpdateManyWithoutTargetItemNestedInput
    comments?: CommentUncheckedUpdateManyWithoutWorkItemNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutWorkItemNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutWorkItemNestedInput
    snapshots?: WorkItemSnapshotUncheckedUpdateManyWithoutWorkItemNestedInput
    tags?: TagOnWorkItemUncheckedUpdateManyWithoutWorkItemNestedInput
    embedding?: WorkItemEmbeddingUncheckedUpdateOneWithoutWorkItemNestedInput
  }

  export type ComponentUpsertWithoutWorkItemsInput = {
    update: XOR<ComponentUpdateWithoutWorkItemsInput, ComponentUncheckedUpdateWithoutWorkItemsInput>
    create: XOR<ComponentCreateWithoutWorkItemsInput, ComponentUncheckedCreateWithoutWorkItemsInput>
    where?: ComponentWhereInput
  }

  export type ComponentUpdateToOneWithWhereWithoutWorkItemsInput = {
    where?: ComponentWhereInput
    data: XOR<ComponentUpdateWithoutWorkItemsInput, ComponentUncheckedUpdateWithoutWorkItemsInput>
  }

  export type ComponentUpdateWithoutWorkItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutComponentsNestedInput
  }

  export type ComponentUncheckedUpdateWithoutWorkItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkItemCreateWithoutDependenciesAsSourceInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.WorkItemType
    priority?: $Enums.Priority
    storyPoints?: number | null
    estimatedHours?: number | null
    remainingHours?: number | null
    order?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: WorkItemCreateNestedOneWithoutChildrenInput
    children?: WorkItemCreateNestedManyWithoutParentInput
    epic?: WorkItemCreateNestedOneWithoutStoriesInput
    stories?: WorkItemCreateNestedManyWithoutEpicInput
    project: ProjectCreateNestedOneWithoutWorkItemsInput
    state?: WorkItemStateCreateNestedOneWithoutWorkItemsInput
    assignee?: UserCreateNestedOneWithoutAssignedWorkItemsInput
    creator: UserCreateNestedOneWithoutCreatedWorkItemsInput
    sprint?: SprintCreateNestedOneWithoutWorkItemsInput
    details?: WorkItemDetailCreateNestedOneWithoutWorkItemInput
    dependenciesAsTarget?: DependencyCreateNestedManyWithoutTargetItemInput
    comments?: CommentCreateNestedManyWithoutWorkItemInput
    attachments?: AttachmentCreateNestedManyWithoutWorkItemInput
    timeLogs?: TimeLogCreateNestedManyWithoutWorkItemInput
    snapshots?: WorkItemSnapshotCreateNestedManyWithoutWorkItemInput
    tags?: TagOnWorkItemCreateNestedManyWithoutWorkItemInput
    components?: ComponentOnWorkItemCreateNestedManyWithoutWorkItemInput
    embedding?: WorkItemEmbeddingCreateNestedOneWithoutWorkItemInput
  }

  export type WorkItemUncheckedCreateWithoutDependenciesAsSourceInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.WorkItemType
    priority?: $Enums.Priority
    storyPoints?: number | null
    estimatedHours?: number | null
    remainingHours?: number | null
    order?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    epicId?: string | null
    projectId: string
    stateId?: string | null
    assigneeId?: string | null
    creatorId: string
    sprintId?: string | null
    children?: WorkItemUncheckedCreateNestedManyWithoutParentInput
    stories?: WorkItemUncheckedCreateNestedManyWithoutEpicInput
    details?: WorkItemDetailUncheckedCreateNestedOneWithoutWorkItemInput
    dependenciesAsTarget?: DependencyUncheckedCreateNestedManyWithoutTargetItemInput
    comments?: CommentUncheckedCreateNestedManyWithoutWorkItemInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutWorkItemInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutWorkItemInput
    snapshots?: WorkItemSnapshotUncheckedCreateNestedManyWithoutWorkItemInput
    tags?: TagOnWorkItemUncheckedCreateNestedManyWithoutWorkItemInput
    components?: ComponentOnWorkItemUncheckedCreateNestedManyWithoutWorkItemInput
    embedding?: WorkItemEmbeddingUncheckedCreateNestedOneWithoutWorkItemInput
  }

  export type WorkItemCreateOrConnectWithoutDependenciesAsSourceInput = {
    where: WorkItemWhereUniqueInput
    create: XOR<WorkItemCreateWithoutDependenciesAsSourceInput, WorkItemUncheckedCreateWithoutDependenciesAsSourceInput>
  }

  export type WorkItemCreateWithoutDependenciesAsTargetInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.WorkItemType
    priority?: $Enums.Priority
    storyPoints?: number | null
    estimatedHours?: number | null
    remainingHours?: number | null
    order?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: WorkItemCreateNestedOneWithoutChildrenInput
    children?: WorkItemCreateNestedManyWithoutParentInput
    epic?: WorkItemCreateNestedOneWithoutStoriesInput
    stories?: WorkItemCreateNestedManyWithoutEpicInput
    project: ProjectCreateNestedOneWithoutWorkItemsInput
    state?: WorkItemStateCreateNestedOneWithoutWorkItemsInput
    assignee?: UserCreateNestedOneWithoutAssignedWorkItemsInput
    creator: UserCreateNestedOneWithoutCreatedWorkItemsInput
    sprint?: SprintCreateNestedOneWithoutWorkItemsInput
    details?: WorkItemDetailCreateNestedOneWithoutWorkItemInput
    dependenciesAsSource?: DependencyCreateNestedManyWithoutSourceItemInput
    comments?: CommentCreateNestedManyWithoutWorkItemInput
    attachments?: AttachmentCreateNestedManyWithoutWorkItemInput
    timeLogs?: TimeLogCreateNestedManyWithoutWorkItemInput
    snapshots?: WorkItemSnapshotCreateNestedManyWithoutWorkItemInput
    tags?: TagOnWorkItemCreateNestedManyWithoutWorkItemInput
    components?: ComponentOnWorkItemCreateNestedManyWithoutWorkItemInput
    embedding?: WorkItemEmbeddingCreateNestedOneWithoutWorkItemInput
  }

  export type WorkItemUncheckedCreateWithoutDependenciesAsTargetInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.WorkItemType
    priority?: $Enums.Priority
    storyPoints?: number | null
    estimatedHours?: number | null
    remainingHours?: number | null
    order?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    epicId?: string | null
    projectId: string
    stateId?: string | null
    assigneeId?: string | null
    creatorId: string
    sprintId?: string | null
    children?: WorkItemUncheckedCreateNestedManyWithoutParentInput
    stories?: WorkItemUncheckedCreateNestedManyWithoutEpicInput
    details?: WorkItemDetailUncheckedCreateNestedOneWithoutWorkItemInput
    dependenciesAsSource?: DependencyUncheckedCreateNestedManyWithoutSourceItemInput
    comments?: CommentUncheckedCreateNestedManyWithoutWorkItemInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutWorkItemInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutWorkItemInput
    snapshots?: WorkItemSnapshotUncheckedCreateNestedManyWithoutWorkItemInput
    tags?: TagOnWorkItemUncheckedCreateNestedManyWithoutWorkItemInput
    components?: ComponentOnWorkItemUncheckedCreateNestedManyWithoutWorkItemInput
    embedding?: WorkItemEmbeddingUncheckedCreateNestedOneWithoutWorkItemInput
  }

  export type WorkItemCreateOrConnectWithoutDependenciesAsTargetInput = {
    where: WorkItemWhereUniqueInput
    create: XOR<WorkItemCreateWithoutDependenciesAsTargetInput, WorkItemUncheckedCreateWithoutDependenciesAsTargetInput>
  }

  export type WorkItemUpsertWithoutDependenciesAsSourceInput = {
    update: XOR<WorkItemUpdateWithoutDependenciesAsSourceInput, WorkItemUncheckedUpdateWithoutDependenciesAsSourceInput>
    create: XOR<WorkItemCreateWithoutDependenciesAsSourceInput, WorkItemUncheckedCreateWithoutDependenciesAsSourceInput>
    where?: WorkItemWhereInput
  }

  export type WorkItemUpdateToOneWithWhereWithoutDependenciesAsSourceInput = {
    where?: WorkItemWhereInput
    data: XOR<WorkItemUpdateWithoutDependenciesAsSourceInput, WorkItemUncheckedUpdateWithoutDependenciesAsSourceInput>
  }

  export type WorkItemUpdateWithoutDependenciesAsSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWorkItemTypeFieldUpdateOperationsInput | $Enums.WorkItemType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    storyPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: WorkItemUpdateOneWithoutChildrenNestedInput
    children?: WorkItemUpdateManyWithoutParentNestedInput
    epic?: WorkItemUpdateOneWithoutStoriesNestedInput
    stories?: WorkItemUpdateManyWithoutEpicNestedInput
    project?: ProjectUpdateOneRequiredWithoutWorkItemsNestedInput
    state?: WorkItemStateUpdateOneWithoutWorkItemsNestedInput
    assignee?: UserUpdateOneWithoutAssignedWorkItemsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedWorkItemsNestedInput
    sprint?: SprintUpdateOneWithoutWorkItemsNestedInput
    details?: WorkItemDetailUpdateOneWithoutWorkItemNestedInput
    dependenciesAsTarget?: DependencyUpdateManyWithoutTargetItemNestedInput
    comments?: CommentUpdateManyWithoutWorkItemNestedInput
    attachments?: AttachmentUpdateManyWithoutWorkItemNestedInput
    timeLogs?: TimeLogUpdateManyWithoutWorkItemNestedInput
    snapshots?: WorkItemSnapshotUpdateManyWithoutWorkItemNestedInput
    tags?: TagOnWorkItemUpdateManyWithoutWorkItemNestedInput
    components?: ComponentOnWorkItemUpdateManyWithoutWorkItemNestedInput
    embedding?: WorkItemEmbeddingUpdateOneWithoutWorkItemNestedInput
  }

  export type WorkItemUncheckedUpdateWithoutDependenciesAsSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWorkItemTypeFieldUpdateOperationsInput | $Enums.WorkItemType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    storyPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    epicId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: WorkItemUncheckedUpdateManyWithoutParentNestedInput
    stories?: WorkItemUncheckedUpdateManyWithoutEpicNestedInput
    details?: WorkItemDetailUncheckedUpdateOneWithoutWorkItemNestedInput
    dependenciesAsTarget?: DependencyUncheckedUpdateManyWithoutTargetItemNestedInput
    comments?: CommentUncheckedUpdateManyWithoutWorkItemNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutWorkItemNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutWorkItemNestedInput
    snapshots?: WorkItemSnapshotUncheckedUpdateManyWithoutWorkItemNestedInput
    tags?: TagOnWorkItemUncheckedUpdateManyWithoutWorkItemNestedInput
    components?: ComponentOnWorkItemUncheckedUpdateManyWithoutWorkItemNestedInput
    embedding?: WorkItemEmbeddingUncheckedUpdateOneWithoutWorkItemNestedInput
  }

  export type WorkItemUpsertWithoutDependenciesAsTargetInput = {
    update: XOR<WorkItemUpdateWithoutDependenciesAsTargetInput, WorkItemUncheckedUpdateWithoutDependenciesAsTargetInput>
    create: XOR<WorkItemCreateWithoutDependenciesAsTargetInput, WorkItemUncheckedCreateWithoutDependenciesAsTargetInput>
    where?: WorkItemWhereInput
  }

  export type WorkItemUpdateToOneWithWhereWithoutDependenciesAsTargetInput = {
    where?: WorkItemWhereInput
    data: XOR<WorkItemUpdateWithoutDependenciesAsTargetInput, WorkItemUncheckedUpdateWithoutDependenciesAsTargetInput>
  }

  export type WorkItemUpdateWithoutDependenciesAsTargetInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWorkItemTypeFieldUpdateOperationsInput | $Enums.WorkItemType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    storyPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: WorkItemUpdateOneWithoutChildrenNestedInput
    children?: WorkItemUpdateManyWithoutParentNestedInput
    epic?: WorkItemUpdateOneWithoutStoriesNestedInput
    stories?: WorkItemUpdateManyWithoutEpicNestedInput
    project?: ProjectUpdateOneRequiredWithoutWorkItemsNestedInput
    state?: WorkItemStateUpdateOneWithoutWorkItemsNestedInput
    assignee?: UserUpdateOneWithoutAssignedWorkItemsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedWorkItemsNestedInput
    sprint?: SprintUpdateOneWithoutWorkItemsNestedInput
    details?: WorkItemDetailUpdateOneWithoutWorkItemNestedInput
    dependenciesAsSource?: DependencyUpdateManyWithoutSourceItemNestedInput
    comments?: CommentUpdateManyWithoutWorkItemNestedInput
    attachments?: AttachmentUpdateManyWithoutWorkItemNestedInput
    timeLogs?: TimeLogUpdateManyWithoutWorkItemNestedInput
    snapshots?: WorkItemSnapshotUpdateManyWithoutWorkItemNestedInput
    tags?: TagOnWorkItemUpdateManyWithoutWorkItemNestedInput
    components?: ComponentOnWorkItemUpdateManyWithoutWorkItemNestedInput
    embedding?: WorkItemEmbeddingUpdateOneWithoutWorkItemNestedInput
  }

  export type WorkItemUncheckedUpdateWithoutDependenciesAsTargetInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWorkItemTypeFieldUpdateOperationsInput | $Enums.WorkItemType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    storyPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    epicId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: WorkItemUncheckedUpdateManyWithoutParentNestedInput
    stories?: WorkItemUncheckedUpdateManyWithoutEpicNestedInput
    details?: WorkItemDetailUncheckedUpdateOneWithoutWorkItemNestedInput
    dependenciesAsSource?: DependencyUncheckedUpdateManyWithoutSourceItemNestedInput
    comments?: CommentUncheckedUpdateManyWithoutWorkItemNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutWorkItemNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutWorkItemNestedInput
    snapshots?: WorkItemSnapshotUncheckedUpdateManyWithoutWorkItemNestedInput
    tags?: TagOnWorkItemUncheckedUpdateManyWithoutWorkItemNestedInput
    components?: ComponentOnWorkItemUncheckedUpdateManyWithoutWorkItemNestedInput
    embedding?: WorkItemEmbeddingUncheckedUpdateOneWithoutWorkItemNestedInput
  }

  export type WorkItemCreateWithoutTimeLogsInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.WorkItemType
    priority?: $Enums.Priority
    storyPoints?: number | null
    estimatedHours?: number | null
    remainingHours?: number | null
    order?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: WorkItemCreateNestedOneWithoutChildrenInput
    children?: WorkItemCreateNestedManyWithoutParentInput
    epic?: WorkItemCreateNestedOneWithoutStoriesInput
    stories?: WorkItemCreateNestedManyWithoutEpicInput
    project: ProjectCreateNestedOneWithoutWorkItemsInput
    state?: WorkItemStateCreateNestedOneWithoutWorkItemsInput
    assignee?: UserCreateNestedOneWithoutAssignedWorkItemsInput
    creator: UserCreateNestedOneWithoutCreatedWorkItemsInput
    sprint?: SprintCreateNestedOneWithoutWorkItemsInput
    details?: WorkItemDetailCreateNestedOneWithoutWorkItemInput
    dependenciesAsSource?: DependencyCreateNestedManyWithoutSourceItemInput
    dependenciesAsTarget?: DependencyCreateNestedManyWithoutTargetItemInput
    comments?: CommentCreateNestedManyWithoutWorkItemInput
    attachments?: AttachmentCreateNestedManyWithoutWorkItemInput
    snapshots?: WorkItemSnapshotCreateNestedManyWithoutWorkItemInput
    tags?: TagOnWorkItemCreateNestedManyWithoutWorkItemInput
    components?: ComponentOnWorkItemCreateNestedManyWithoutWorkItemInput
    embedding?: WorkItemEmbeddingCreateNestedOneWithoutWorkItemInput
  }

  export type WorkItemUncheckedCreateWithoutTimeLogsInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.WorkItemType
    priority?: $Enums.Priority
    storyPoints?: number | null
    estimatedHours?: number | null
    remainingHours?: number | null
    order?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    epicId?: string | null
    projectId: string
    stateId?: string | null
    assigneeId?: string | null
    creatorId: string
    sprintId?: string | null
    children?: WorkItemUncheckedCreateNestedManyWithoutParentInput
    stories?: WorkItemUncheckedCreateNestedManyWithoutEpicInput
    details?: WorkItemDetailUncheckedCreateNestedOneWithoutWorkItemInput
    dependenciesAsSource?: DependencyUncheckedCreateNestedManyWithoutSourceItemInput
    dependenciesAsTarget?: DependencyUncheckedCreateNestedManyWithoutTargetItemInput
    comments?: CommentUncheckedCreateNestedManyWithoutWorkItemInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutWorkItemInput
    snapshots?: WorkItemSnapshotUncheckedCreateNestedManyWithoutWorkItemInput
    tags?: TagOnWorkItemUncheckedCreateNestedManyWithoutWorkItemInput
    components?: ComponentOnWorkItemUncheckedCreateNestedManyWithoutWorkItemInput
    embedding?: WorkItemEmbeddingUncheckedCreateNestedOneWithoutWorkItemInput
  }

  export type WorkItemCreateOrConnectWithoutTimeLogsInput = {
    where: WorkItemWhereUniqueInput
    create: XOR<WorkItemCreateWithoutTimeLogsInput, WorkItemUncheckedCreateWithoutTimeLogsInput>
  }

  export type UserCreateWithoutTimeLogsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    passwordHash?: string | null
    firstName: string
    lastName: string
    avatarUrl?: string | null
    timezone?: string
    availabilityHours?: number
    isActive?: boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    organizationMemberships?: OrganizationMembershipCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMembershipCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectCreateNestedManyWithoutLeadUserInput
    assignedWorkItems?: WorkItemCreateNestedManyWithoutAssigneeInput
    createdWorkItems?: WorkItemCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    skillProfile?: UserSkillProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTimeLogsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    passwordHash?: string | null
    firstName: string
    lastName: string
    avatarUrl?: string | null
    timezone?: string
    availabilityHours?: number
    isActive?: boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    organizationMemberships?: OrganizationMembershipUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMembershipUncheckedCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutLeadUserInput
    assignedWorkItems?: WorkItemUncheckedCreateNestedManyWithoutAssigneeInput
    createdWorkItems?: WorkItemUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    skillProfile?: UserSkillProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTimeLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTimeLogsInput, UserUncheckedCreateWithoutTimeLogsInput>
  }

  export type SprintCreateWithoutTimeLogsInput = {
    id?: string
    name: string
    goal?: string | null
    startDate: Date | string
    endDate: Date | string
    state?: string
    committedPoints?: number
    completedPoints?: number
    velocity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutSprintsInput
    workItems?: WorkItemCreateNestedManyWithoutSprintInput
    snapshots?: WorkItemSnapshotCreateNestedManyWithoutSprintInput
    retrospective?: RetrospectiveCreateNestedOneWithoutSprintInput
    boards?: BoardCreateNestedManyWithoutSprintInput
  }

  export type SprintUncheckedCreateWithoutTimeLogsInput = {
    id?: string
    name: string
    goal?: string | null
    startDate: Date | string
    endDate: Date | string
    state?: string
    committedPoints?: number
    completedPoints?: number
    velocity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    workItems?: WorkItemUncheckedCreateNestedManyWithoutSprintInput
    snapshots?: WorkItemSnapshotUncheckedCreateNestedManyWithoutSprintInput
    retrospective?: RetrospectiveUncheckedCreateNestedOneWithoutSprintInput
    boards?: BoardUncheckedCreateNestedManyWithoutSprintInput
  }

  export type SprintCreateOrConnectWithoutTimeLogsInput = {
    where: SprintWhereUniqueInput
    create: XOR<SprintCreateWithoutTimeLogsInput, SprintUncheckedCreateWithoutTimeLogsInput>
  }

  export type WorkItemUpsertWithoutTimeLogsInput = {
    update: XOR<WorkItemUpdateWithoutTimeLogsInput, WorkItemUncheckedUpdateWithoutTimeLogsInput>
    create: XOR<WorkItemCreateWithoutTimeLogsInput, WorkItemUncheckedCreateWithoutTimeLogsInput>
    where?: WorkItemWhereInput
  }

  export type WorkItemUpdateToOneWithWhereWithoutTimeLogsInput = {
    where?: WorkItemWhereInput
    data: XOR<WorkItemUpdateWithoutTimeLogsInput, WorkItemUncheckedUpdateWithoutTimeLogsInput>
  }

  export type WorkItemUpdateWithoutTimeLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWorkItemTypeFieldUpdateOperationsInput | $Enums.WorkItemType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    storyPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: WorkItemUpdateOneWithoutChildrenNestedInput
    children?: WorkItemUpdateManyWithoutParentNestedInput
    epic?: WorkItemUpdateOneWithoutStoriesNestedInput
    stories?: WorkItemUpdateManyWithoutEpicNestedInput
    project?: ProjectUpdateOneRequiredWithoutWorkItemsNestedInput
    state?: WorkItemStateUpdateOneWithoutWorkItemsNestedInput
    assignee?: UserUpdateOneWithoutAssignedWorkItemsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedWorkItemsNestedInput
    sprint?: SprintUpdateOneWithoutWorkItemsNestedInput
    details?: WorkItemDetailUpdateOneWithoutWorkItemNestedInput
    dependenciesAsSource?: DependencyUpdateManyWithoutSourceItemNestedInput
    dependenciesAsTarget?: DependencyUpdateManyWithoutTargetItemNestedInput
    comments?: CommentUpdateManyWithoutWorkItemNestedInput
    attachments?: AttachmentUpdateManyWithoutWorkItemNestedInput
    snapshots?: WorkItemSnapshotUpdateManyWithoutWorkItemNestedInput
    tags?: TagOnWorkItemUpdateManyWithoutWorkItemNestedInput
    components?: ComponentOnWorkItemUpdateManyWithoutWorkItemNestedInput
    embedding?: WorkItemEmbeddingUpdateOneWithoutWorkItemNestedInput
  }

  export type WorkItemUncheckedUpdateWithoutTimeLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWorkItemTypeFieldUpdateOperationsInput | $Enums.WorkItemType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    storyPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    epicId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: WorkItemUncheckedUpdateManyWithoutParentNestedInput
    stories?: WorkItemUncheckedUpdateManyWithoutEpicNestedInput
    details?: WorkItemDetailUncheckedUpdateOneWithoutWorkItemNestedInput
    dependenciesAsSource?: DependencyUncheckedUpdateManyWithoutSourceItemNestedInput
    dependenciesAsTarget?: DependencyUncheckedUpdateManyWithoutTargetItemNestedInput
    comments?: CommentUncheckedUpdateManyWithoutWorkItemNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutWorkItemNestedInput
    snapshots?: WorkItemSnapshotUncheckedUpdateManyWithoutWorkItemNestedInput
    tags?: TagOnWorkItemUncheckedUpdateManyWithoutWorkItemNestedInput
    components?: ComponentOnWorkItemUncheckedUpdateManyWithoutWorkItemNestedInput
    embedding?: WorkItemEmbeddingUncheckedUpdateOneWithoutWorkItemNestedInput
  }

  export type UserUpsertWithoutTimeLogsInput = {
    update: XOR<UserUpdateWithoutTimeLogsInput, UserUncheckedUpdateWithoutTimeLogsInput>
    create: XOR<UserCreateWithoutTimeLogsInput, UserUncheckedCreateWithoutTimeLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTimeLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTimeLogsInput, UserUncheckedUpdateWithoutTimeLogsInput>
  }

  export type UserUpdateWithoutTimeLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    availabilityHours?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    organizationMemberships?: OrganizationMembershipUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMembershipUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUpdateManyWithoutLeadUserNestedInput
    assignedWorkItems?: WorkItemUpdateManyWithoutAssigneeNestedInput
    createdWorkItems?: WorkItemUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    skillProfile?: UserSkillProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTimeLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    availabilityHours?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    organizationMemberships?: OrganizationMembershipUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMembershipUncheckedUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutLeadUserNestedInput
    assignedWorkItems?: WorkItemUncheckedUpdateManyWithoutAssigneeNestedInput
    createdWorkItems?: WorkItemUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    skillProfile?: UserSkillProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type SprintUpsertWithoutTimeLogsInput = {
    update: XOR<SprintUpdateWithoutTimeLogsInput, SprintUncheckedUpdateWithoutTimeLogsInput>
    create: XOR<SprintCreateWithoutTimeLogsInput, SprintUncheckedCreateWithoutTimeLogsInput>
    where?: SprintWhereInput
  }

  export type SprintUpdateToOneWithWhereWithoutTimeLogsInput = {
    where?: SprintWhereInput
    data: XOR<SprintUpdateWithoutTimeLogsInput, SprintUncheckedUpdateWithoutTimeLogsInput>
  }

  export type SprintUpdateWithoutTimeLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    goal?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: StringFieldUpdateOperationsInput | string
    committedPoints?: FloatFieldUpdateOperationsInput | number
    completedPoints?: FloatFieldUpdateOperationsInput | number
    velocity?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutSprintsNestedInput
    workItems?: WorkItemUpdateManyWithoutSprintNestedInput
    snapshots?: WorkItemSnapshotUpdateManyWithoutSprintNestedInput
    retrospective?: RetrospectiveUpdateOneWithoutSprintNestedInput
    boards?: BoardUpdateManyWithoutSprintNestedInput
  }

  export type SprintUncheckedUpdateWithoutTimeLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    goal?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: StringFieldUpdateOperationsInput | string
    committedPoints?: FloatFieldUpdateOperationsInput | number
    completedPoints?: FloatFieldUpdateOperationsInput | number
    velocity?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    workItems?: WorkItemUncheckedUpdateManyWithoutSprintNestedInput
    snapshots?: WorkItemSnapshotUncheckedUpdateManyWithoutSprintNestedInput
    retrospective?: RetrospectiveUncheckedUpdateOneWithoutSprintNestedInput
    boards?: BoardUncheckedUpdateManyWithoutSprintNestedInput
  }

  export type WorkItemCreateWithoutCommentsInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.WorkItemType
    priority?: $Enums.Priority
    storyPoints?: number | null
    estimatedHours?: number | null
    remainingHours?: number | null
    order?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: WorkItemCreateNestedOneWithoutChildrenInput
    children?: WorkItemCreateNestedManyWithoutParentInput
    epic?: WorkItemCreateNestedOneWithoutStoriesInput
    stories?: WorkItemCreateNestedManyWithoutEpicInput
    project: ProjectCreateNestedOneWithoutWorkItemsInput
    state?: WorkItemStateCreateNestedOneWithoutWorkItemsInput
    assignee?: UserCreateNestedOneWithoutAssignedWorkItemsInput
    creator: UserCreateNestedOneWithoutCreatedWorkItemsInput
    sprint?: SprintCreateNestedOneWithoutWorkItemsInput
    details?: WorkItemDetailCreateNestedOneWithoutWorkItemInput
    dependenciesAsSource?: DependencyCreateNestedManyWithoutSourceItemInput
    dependenciesAsTarget?: DependencyCreateNestedManyWithoutTargetItemInput
    attachments?: AttachmentCreateNestedManyWithoutWorkItemInput
    timeLogs?: TimeLogCreateNestedManyWithoutWorkItemInput
    snapshots?: WorkItemSnapshotCreateNestedManyWithoutWorkItemInput
    tags?: TagOnWorkItemCreateNestedManyWithoutWorkItemInput
    components?: ComponentOnWorkItemCreateNestedManyWithoutWorkItemInput
    embedding?: WorkItemEmbeddingCreateNestedOneWithoutWorkItemInput
  }

  export type WorkItemUncheckedCreateWithoutCommentsInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.WorkItemType
    priority?: $Enums.Priority
    storyPoints?: number | null
    estimatedHours?: number | null
    remainingHours?: number | null
    order?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    epicId?: string | null
    projectId: string
    stateId?: string | null
    assigneeId?: string | null
    creatorId: string
    sprintId?: string | null
    children?: WorkItemUncheckedCreateNestedManyWithoutParentInput
    stories?: WorkItemUncheckedCreateNestedManyWithoutEpicInput
    details?: WorkItemDetailUncheckedCreateNestedOneWithoutWorkItemInput
    dependenciesAsSource?: DependencyUncheckedCreateNestedManyWithoutSourceItemInput
    dependenciesAsTarget?: DependencyUncheckedCreateNestedManyWithoutTargetItemInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutWorkItemInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutWorkItemInput
    snapshots?: WorkItemSnapshotUncheckedCreateNestedManyWithoutWorkItemInput
    tags?: TagOnWorkItemUncheckedCreateNestedManyWithoutWorkItemInput
    components?: ComponentOnWorkItemUncheckedCreateNestedManyWithoutWorkItemInput
    embedding?: WorkItemEmbeddingUncheckedCreateNestedOneWithoutWorkItemInput
  }

  export type WorkItemCreateOrConnectWithoutCommentsInput = {
    where: WorkItemWhereUniqueInput
    create: XOR<WorkItemCreateWithoutCommentsInput, WorkItemUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutCommentsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    passwordHash?: string | null
    firstName: string
    lastName: string
    avatarUrl?: string | null
    timezone?: string
    availabilityHours?: number
    isActive?: boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    organizationMemberships?: OrganizationMembershipCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMembershipCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectCreateNestedManyWithoutLeadUserInput
    assignedWorkItems?: WorkItemCreateNestedManyWithoutAssigneeInput
    createdWorkItems?: WorkItemCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    skillProfile?: UserSkillProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommentsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    passwordHash?: string | null
    firstName: string
    lastName: string
    avatarUrl?: string | null
    timezone?: string
    availabilityHours?: number
    isActive?: boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    organizationMemberships?: OrganizationMembershipUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMembershipUncheckedCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutLeadUserInput
    assignedWorkItems?: WorkItemUncheckedCreateNestedManyWithoutAssigneeInput
    createdWorkItems?: WorkItemUncheckedCreateNestedManyWithoutCreatorInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    skillProfile?: UserSkillProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type WorkItemUpsertWithoutCommentsInput = {
    update: XOR<WorkItemUpdateWithoutCommentsInput, WorkItemUncheckedUpdateWithoutCommentsInput>
    create: XOR<WorkItemCreateWithoutCommentsInput, WorkItemUncheckedCreateWithoutCommentsInput>
    where?: WorkItemWhereInput
  }

  export type WorkItemUpdateToOneWithWhereWithoutCommentsInput = {
    where?: WorkItemWhereInput
    data: XOR<WorkItemUpdateWithoutCommentsInput, WorkItemUncheckedUpdateWithoutCommentsInput>
  }

  export type WorkItemUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWorkItemTypeFieldUpdateOperationsInput | $Enums.WorkItemType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    storyPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: WorkItemUpdateOneWithoutChildrenNestedInput
    children?: WorkItemUpdateManyWithoutParentNestedInput
    epic?: WorkItemUpdateOneWithoutStoriesNestedInput
    stories?: WorkItemUpdateManyWithoutEpicNestedInput
    project?: ProjectUpdateOneRequiredWithoutWorkItemsNestedInput
    state?: WorkItemStateUpdateOneWithoutWorkItemsNestedInput
    assignee?: UserUpdateOneWithoutAssignedWorkItemsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedWorkItemsNestedInput
    sprint?: SprintUpdateOneWithoutWorkItemsNestedInput
    details?: WorkItemDetailUpdateOneWithoutWorkItemNestedInput
    dependenciesAsSource?: DependencyUpdateManyWithoutSourceItemNestedInput
    dependenciesAsTarget?: DependencyUpdateManyWithoutTargetItemNestedInput
    attachments?: AttachmentUpdateManyWithoutWorkItemNestedInput
    timeLogs?: TimeLogUpdateManyWithoutWorkItemNestedInput
    snapshots?: WorkItemSnapshotUpdateManyWithoutWorkItemNestedInput
    tags?: TagOnWorkItemUpdateManyWithoutWorkItemNestedInput
    components?: ComponentOnWorkItemUpdateManyWithoutWorkItemNestedInput
    embedding?: WorkItemEmbeddingUpdateOneWithoutWorkItemNestedInput
  }

  export type WorkItemUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWorkItemTypeFieldUpdateOperationsInput | $Enums.WorkItemType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    storyPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    epicId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: WorkItemUncheckedUpdateManyWithoutParentNestedInput
    stories?: WorkItemUncheckedUpdateManyWithoutEpicNestedInput
    details?: WorkItemDetailUncheckedUpdateOneWithoutWorkItemNestedInput
    dependenciesAsSource?: DependencyUncheckedUpdateManyWithoutSourceItemNestedInput
    dependenciesAsTarget?: DependencyUncheckedUpdateManyWithoutTargetItemNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutWorkItemNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutWorkItemNestedInput
    snapshots?: WorkItemSnapshotUncheckedUpdateManyWithoutWorkItemNestedInput
    tags?: TagOnWorkItemUncheckedUpdateManyWithoutWorkItemNestedInput
    components?: ComponentOnWorkItemUncheckedUpdateManyWithoutWorkItemNestedInput
    embedding?: WorkItemEmbeddingUncheckedUpdateOneWithoutWorkItemNestedInput
  }

  export type UserUpsertWithoutCommentsInput = {
    update: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    availabilityHours?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    organizationMemberships?: OrganizationMembershipUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMembershipUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUpdateManyWithoutLeadUserNestedInput
    assignedWorkItems?: WorkItemUpdateManyWithoutAssigneeNestedInput
    createdWorkItems?: WorkItemUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    skillProfile?: UserSkillProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    availabilityHours?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    organizationMemberships?: OrganizationMembershipUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMembershipUncheckedUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutLeadUserNestedInput
    assignedWorkItems?: WorkItemUncheckedUpdateManyWithoutAssigneeNestedInput
    createdWorkItems?: WorkItemUncheckedUpdateManyWithoutCreatorNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    skillProfile?: UserSkillProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type WorkItemCreateWithoutAttachmentsInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.WorkItemType
    priority?: $Enums.Priority
    storyPoints?: number | null
    estimatedHours?: number | null
    remainingHours?: number | null
    order?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: WorkItemCreateNestedOneWithoutChildrenInput
    children?: WorkItemCreateNestedManyWithoutParentInput
    epic?: WorkItemCreateNestedOneWithoutStoriesInput
    stories?: WorkItemCreateNestedManyWithoutEpicInput
    project: ProjectCreateNestedOneWithoutWorkItemsInput
    state?: WorkItemStateCreateNestedOneWithoutWorkItemsInput
    assignee?: UserCreateNestedOneWithoutAssignedWorkItemsInput
    creator: UserCreateNestedOneWithoutCreatedWorkItemsInput
    sprint?: SprintCreateNestedOneWithoutWorkItemsInput
    details?: WorkItemDetailCreateNestedOneWithoutWorkItemInput
    dependenciesAsSource?: DependencyCreateNestedManyWithoutSourceItemInput
    dependenciesAsTarget?: DependencyCreateNestedManyWithoutTargetItemInput
    comments?: CommentCreateNestedManyWithoutWorkItemInput
    timeLogs?: TimeLogCreateNestedManyWithoutWorkItemInput
    snapshots?: WorkItemSnapshotCreateNestedManyWithoutWorkItemInput
    tags?: TagOnWorkItemCreateNestedManyWithoutWorkItemInput
    components?: ComponentOnWorkItemCreateNestedManyWithoutWorkItemInput
    embedding?: WorkItemEmbeddingCreateNestedOneWithoutWorkItemInput
  }

  export type WorkItemUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.WorkItemType
    priority?: $Enums.Priority
    storyPoints?: number | null
    estimatedHours?: number | null
    remainingHours?: number | null
    order?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    epicId?: string | null
    projectId: string
    stateId?: string | null
    assigneeId?: string | null
    creatorId: string
    sprintId?: string | null
    children?: WorkItemUncheckedCreateNestedManyWithoutParentInput
    stories?: WorkItemUncheckedCreateNestedManyWithoutEpicInput
    details?: WorkItemDetailUncheckedCreateNestedOneWithoutWorkItemInput
    dependenciesAsSource?: DependencyUncheckedCreateNestedManyWithoutSourceItemInput
    dependenciesAsTarget?: DependencyUncheckedCreateNestedManyWithoutTargetItemInput
    comments?: CommentUncheckedCreateNestedManyWithoutWorkItemInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutWorkItemInput
    snapshots?: WorkItemSnapshotUncheckedCreateNestedManyWithoutWorkItemInput
    tags?: TagOnWorkItemUncheckedCreateNestedManyWithoutWorkItemInput
    components?: ComponentOnWorkItemUncheckedCreateNestedManyWithoutWorkItemInput
    embedding?: WorkItemEmbeddingUncheckedCreateNestedOneWithoutWorkItemInput
  }

  export type WorkItemCreateOrConnectWithoutAttachmentsInput = {
    where: WorkItemWhereUniqueInput
    create: XOR<WorkItemCreateWithoutAttachmentsInput, WorkItemUncheckedCreateWithoutAttachmentsInput>
  }

  export type WorkItemUpsertWithoutAttachmentsInput = {
    update: XOR<WorkItemUpdateWithoutAttachmentsInput, WorkItemUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<WorkItemCreateWithoutAttachmentsInput, WorkItemUncheckedCreateWithoutAttachmentsInput>
    where?: WorkItemWhereInput
  }

  export type WorkItemUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: WorkItemWhereInput
    data: XOR<WorkItemUpdateWithoutAttachmentsInput, WorkItemUncheckedUpdateWithoutAttachmentsInput>
  }

  export type WorkItemUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWorkItemTypeFieldUpdateOperationsInput | $Enums.WorkItemType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    storyPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: WorkItemUpdateOneWithoutChildrenNestedInput
    children?: WorkItemUpdateManyWithoutParentNestedInput
    epic?: WorkItemUpdateOneWithoutStoriesNestedInput
    stories?: WorkItemUpdateManyWithoutEpicNestedInput
    project?: ProjectUpdateOneRequiredWithoutWorkItemsNestedInput
    state?: WorkItemStateUpdateOneWithoutWorkItemsNestedInput
    assignee?: UserUpdateOneWithoutAssignedWorkItemsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedWorkItemsNestedInput
    sprint?: SprintUpdateOneWithoutWorkItemsNestedInput
    details?: WorkItemDetailUpdateOneWithoutWorkItemNestedInput
    dependenciesAsSource?: DependencyUpdateManyWithoutSourceItemNestedInput
    dependenciesAsTarget?: DependencyUpdateManyWithoutTargetItemNestedInput
    comments?: CommentUpdateManyWithoutWorkItemNestedInput
    timeLogs?: TimeLogUpdateManyWithoutWorkItemNestedInput
    snapshots?: WorkItemSnapshotUpdateManyWithoutWorkItemNestedInput
    tags?: TagOnWorkItemUpdateManyWithoutWorkItemNestedInput
    components?: ComponentOnWorkItemUpdateManyWithoutWorkItemNestedInput
    embedding?: WorkItemEmbeddingUpdateOneWithoutWorkItemNestedInput
  }

  export type WorkItemUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWorkItemTypeFieldUpdateOperationsInput | $Enums.WorkItemType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    storyPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    epicId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: WorkItemUncheckedUpdateManyWithoutParentNestedInput
    stories?: WorkItemUncheckedUpdateManyWithoutEpicNestedInput
    details?: WorkItemDetailUncheckedUpdateOneWithoutWorkItemNestedInput
    dependenciesAsSource?: DependencyUncheckedUpdateManyWithoutSourceItemNestedInput
    dependenciesAsTarget?: DependencyUncheckedUpdateManyWithoutTargetItemNestedInput
    comments?: CommentUncheckedUpdateManyWithoutWorkItemNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutWorkItemNestedInput
    snapshots?: WorkItemSnapshotUncheckedUpdateManyWithoutWorkItemNestedInput
    tags?: TagOnWorkItemUncheckedUpdateManyWithoutWorkItemNestedInput
    components?: ComponentOnWorkItemUncheckedUpdateManyWithoutWorkItemNestedInput
    embedding?: WorkItemEmbeddingUncheckedUpdateOneWithoutWorkItemNestedInput
  }

  export type WorkItemCreateWithoutEmbeddingInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.WorkItemType
    priority?: $Enums.Priority
    storyPoints?: number | null
    estimatedHours?: number | null
    remainingHours?: number | null
    order?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: WorkItemCreateNestedOneWithoutChildrenInput
    children?: WorkItemCreateNestedManyWithoutParentInput
    epic?: WorkItemCreateNestedOneWithoutStoriesInput
    stories?: WorkItemCreateNestedManyWithoutEpicInput
    project: ProjectCreateNestedOneWithoutWorkItemsInput
    state?: WorkItemStateCreateNestedOneWithoutWorkItemsInput
    assignee?: UserCreateNestedOneWithoutAssignedWorkItemsInput
    creator: UserCreateNestedOneWithoutCreatedWorkItemsInput
    sprint?: SprintCreateNestedOneWithoutWorkItemsInput
    details?: WorkItemDetailCreateNestedOneWithoutWorkItemInput
    dependenciesAsSource?: DependencyCreateNestedManyWithoutSourceItemInput
    dependenciesAsTarget?: DependencyCreateNestedManyWithoutTargetItemInput
    comments?: CommentCreateNestedManyWithoutWorkItemInput
    attachments?: AttachmentCreateNestedManyWithoutWorkItemInput
    timeLogs?: TimeLogCreateNestedManyWithoutWorkItemInput
    snapshots?: WorkItemSnapshotCreateNestedManyWithoutWorkItemInput
    tags?: TagOnWorkItemCreateNestedManyWithoutWorkItemInput
    components?: ComponentOnWorkItemCreateNestedManyWithoutWorkItemInput
  }

  export type WorkItemUncheckedCreateWithoutEmbeddingInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.WorkItemType
    priority?: $Enums.Priority
    storyPoints?: number | null
    estimatedHours?: number | null
    remainingHours?: number | null
    order?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    epicId?: string | null
    projectId: string
    stateId?: string | null
    assigneeId?: string | null
    creatorId: string
    sprintId?: string | null
    children?: WorkItemUncheckedCreateNestedManyWithoutParentInput
    stories?: WorkItemUncheckedCreateNestedManyWithoutEpicInput
    details?: WorkItemDetailUncheckedCreateNestedOneWithoutWorkItemInput
    dependenciesAsSource?: DependencyUncheckedCreateNestedManyWithoutSourceItemInput
    dependenciesAsTarget?: DependencyUncheckedCreateNestedManyWithoutTargetItemInput
    comments?: CommentUncheckedCreateNestedManyWithoutWorkItemInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutWorkItemInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutWorkItemInput
    snapshots?: WorkItemSnapshotUncheckedCreateNestedManyWithoutWorkItemInput
    tags?: TagOnWorkItemUncheckedCreateNestedManyWithoutWorkItemInput
    components?: ComponentOnWorkItemUncheckedCreateNestedManyWithoutWorkItemInput
  }

  export type WorkItemCreateOrConnectWithoutEmbeddingInput = {
    where: WorkItemWhereUniqueInput
    create: XOR<WorkItemCreateWithoutEmbeddingInput, WorkItemUncheckedCreateWithoutEmbeddingInput>
  }

  export type WorkItemUpsertWithoutEmbeddingInput = {
    update: XOR<WorkItemUpdateWithoutEmbeddingInput, WorkItemUncheckedUpdateWithoutEmbeddingInput>
    create: XOR<WorkItemCreateWithoutEmbeddingInput, WorkItemUncheckedCreateWithoutEmbeddingInput>
    where?: WorkItemWhereInput
  }

  export type WorkItemUpdateToOneWithWhereWithoutEmbeddingInput = {
    where?: WorkItemWhereInput
    data: XOR<WorkItemUpdateWithoutEmbeddingInput, WorkItemUncheckedUpdateWithoutEmbeddingInput>
  }

  export type WorkItemUpdateWithoutEmbeddingInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWorkItemTypeFieldUpdateOperationsInput | $Enums.WorkItemType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    storyPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: WorkItemUpdateOneWithoutChildrenNestedInput
    children?: WorkItemUpdateManyWithoutParentNestedInput
    epic?: WorkItemUpdateOneWithoutStoriesNestedInput
    stories?: WorkItemUpdateManyWithoutEpicNestedInput
    project?: ProjectUpdateOneRequiredWithoutWorkItemsNestedInput
    state?: WorkItemStateUpdateOneWithoutWorkItemsNestedInput
    assignee?: UserUpdateOneWithoutAssignedWorkItemsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedWorkItemsNestedInput
    sprint?: SprintUpdateOneWithoutWorkItemsNestedInput
    details?: WorkItemDetailUpdateOneWithoutWorkItemNestedInput
    dependenciesAsSource?: DependencyUpdateManyWithoutSourceItemNestedInput
    dependenciesAsTarget?: DependencyUpdateManyWithoutTargetItemNestedInput
    comments?: CommentUpdateManyWithoutWorkItemNestedInput
    attachments?: AttachmentUpdateManyWithoutWorkItemNestedInput
    timeLogs?: TimeLogUpdateManyWithoutWorkItemNestedInput
    snapshots?: WorkItemSnapshotUpdateManyWithoutWorkItemNestedInput
    tags?: TagOnWorkItemUpdateManyWithoutWorkItemNestedInput
    components?: ComponentOnWorkItemUpdateManyWithoutWorkItemNestedInput
  }

  export type WorkItemUncheckedUpdateWithoutEmbeddingInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWorkItemTypeFieldUpdateOperationsInput | $Enums.WorkItemType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    storyPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    epicId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: WorkItemUncheckedUpdateManyWithoutParentNestedInput
    stories?: WorkItemUncheckedUpdateManyWithoutEpicNestedInput
    details?: WorkItemDetailUncheckedUpdateOneWithoutWorkItemNestedInput
    dependenciesAsSource?: DependencyUncheckedUpdateManyWithoutSourceItemNestedInput
    dependenciesAsTarget?: DependencyUncheckedUpdateManyWithoutTargetItemNestedInput
    comments?: CommentUncheckedUpdateManyWithoutWorkItemNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutWorkItemNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutWorkItemNestedInput
    snapshots?: WorkItemSnapshotUncheckedUpdateManyWithoutWorkItemNestedInput
    tags?: TagOnWorkItemUncheckedUpdateManyWithoutWorkItemNestedInput
    components?: ComponentOnWorkItemUncheckedUpdateManyWithoutWorkItemNestedInput
  }

  export type WorkItemCreateWithoutSnapshotsInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.WorkItemType
    priority?: $Enums.Priority
    storyPoints?: number | null
    estimatedHours?: number | null
    remainingHours?: number | null
    order?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: WorkItemCreateNestedOneWithoutChildrenInput
    children?: WorkItemCreateNestedManyWithoutParentInput
    epic?: WorkItemCreateNestedOneWithoutStoriesInput
    stories?: WorkItemCreateNestedManyWithoutEpicInput
    project: ProjectCreateNestedOneWithoutWorkItemsInput
    state?: WorkItemStateCreateNestedOneWithoutWorkItemsInput
    assignee?: UserCreateNestedOneWithoutAssignedWorkItemsInput
    creator: UserCreateNestedOneWithoutCreatedWorkItemsInput
    sprint?: SprintCreateNestedOneWithoutWorkItemsInput
    details?: WorkItemDetailCreateNestedOneWithoutWorkItemInput
    dependenciesAsSource?: DependencyCreateNestedManyWithoutSourceItemInput
    dependenciesAsTarget?: DependencyCreateNestedManyWithoutTargetItemInput
    comments?: CommentCreateNestedManyWithoutWorkItemInput
    attachments?: AttachmentCreateNestedManyWithoutWorkItemInput
    timeLogs?: TimeLogCreateNestedManyWithoutWorkItemInput
    tags?: TagOnWorkItemCreateNestedManyWithoutWorkItemInput
    components?: ComponentOnWorkItemCreateNestedManyWithoutWorkItemInput
    embedding?: WorkItemEmbeddingCreateNestedOneWithoutWorkItemInput
  }

  export type WorkItemUncheckedCreateWithoutSnapshotsInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.WorkItemType
    priority?: $Enums.Priority
    storyPoints?: number | null
    estimatedHours?: number | null
    remainingHours?: number | null
    order?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    epicId?: string | null
    projectId: string
    stateId?: string | null
    assigneeId?: string | null
    creatorId: string
    sprintId?: string | null
    children?: WorkItemUncheckedCreateNestedManyWithoutParentInput
    stories?: WorkItemUncheckedCreateNestedManyWithoutEpicInput
    details?: WorkItemDetailUncheckedCreateNestedOneWithoutWorkItemInput
    dependenciesAsSource?: DependencyUncheckedCreateNestedManyWithoutSourceItemInput
    dependenciesAsTarget?: DependencyUncheckedCreateNestedManyWithoutTargetItemInput
    comments?: CommentUncheckedCreateNestedManyWithoutWorkItemInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutWorkItemInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutWorkItemInput
    tags?: TagOnWorkItemUncheckedCreateNestedManyWithoutWorkItemInput
    components?: ComponentOnWorkItemUncheckedCreateNestedManyWithoutWorkItemInput
    embedding?: WorkItemEmbeddingUncheckedCreateNestedOneWithoutWorkItemInput
  }

  export type WorkItemCreateOrConnectWithoutSnapshotsInput = {
    where: WorkItemWhereUniqueInput
    create: XOR<WorkItemCreateWithoutSnapshotsInput, WorkItemUncheckedCreateWithoutSnapshotsInput>
  }

  export type SprintCreateWithoutSnapshotsInput = {
    id?: string
    name: string
    goal?: string | null
    startDate: Date | string
    endDate: Date | string
    state?: string
    committedPoints?: number
    completedPoints?: number
    velocity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutSprintsInput
    workItems?: WorkItemCreateNestedManyWithoutSprintInput
    retrospective?: RetrospectiveCreateNestedOneWithoutSprintInput
    timeLogs?: TimeLogCreateNestedManyWithoutSprintInput
    boards?: BoardCreateNestedManyWithoutSprintInput
  }

  export type SprintUncheckedCreateWithoutSnapshotsInput = {
    id?: string
    name: string
    goal?: string | null
    startDate: Date | string
    endDate: Date | string
    state?: string
    committedPoints?: number
    completedPoints?: number
    velocity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
    workItems?: WorkItemUncheckedCreateNestedManyWithoutSprintInput
    retrospective?: RetrospectiveUncheckedCreateNestedOneWithoutSprintInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutSprintInput
    boards?: BoardUncheckedCreateNestedManyWithoutSprintInput
  }

  export type SprintCreateOrConnectWithoutSnapshotsInput = {
    where: SprintWhereUniqueInput
    create: XOR<SprintCreateWithoutSnapshotsInput, SprintUncheckedCreateWithoutSnapshotsInput>
  }

  export type WorkItemUpsertWithoutSnapshotsInput = {
    update: XOR<WorkItemUpdateWithoutSnapshotsInput, WorkItemUncheckedUpdateWithoutSnapshotsInput>
    create: XOR<WorkItemCreateWithoutSnapshotsInput, WorkItemUncheckedCreateWithoutSnapshotsInput>
    where?: WorkItemWhereInput
  }

  export type WorkItemUpdateToOneWithWhereWithoutSnapshotsInput = {
    where?: WorkItemWhereInput
    data: XOR<WorkItemUpdateWithoutSnapshotsInput, WorkItemUncheckedUpdateWithoutSnapshotsInput>
  }

  export type WorkItemUpdateWithoutSnapshotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWorkItemTypeFieldUpdateOperationsInput | $Enums.WorkItemType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    storyPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: WorkItemUpdateOneWithoutChildrenNestedInput
    children?: WorkItemUpdateManyWithoutParentNestedInput
    epic?: WorkItemUpdateOneWithoutStoriesNestedInput
    stories?: WorkItemUpdateManyWithoutEpicNestedInput
    project?: ProjectUpdateOneRequiredWithoutWorkItemsNestedInput
    state?: WorkItemStateUpdateOneWithoutWorkItemsNestedInput
    assignee?: UserUpdateOneWithoutAssignedWorkItemsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedWorkItemsNestedInput
    sprint?: SprintUpdateOneWithoutWorkItemsNestedInput
    details?: WorkItemDetailUpdateOneWithoutWorkItemNestedInput
    dependenciesAsSource?: DependencyUpdateManyWithoutSourceItemNestedInput
    dependenciesAsTarget?: DependencyUpdateManyWithoutTargetItemNestedInput
    comments?: CommentUpdateManyWithoutWorkItemNestedInput
    attachments?: AttachmentUpdateManyWithoutWorkItemNestedInput
    timeLogs?: TimeLogUpdateManyWithoutWorkItemNestedInput
    tags?: TagOnWorkItemUpdateManyWithoutWorkItemNestedInput
    components?: ComponentOnWorkItemUpdateManyWithoutWorkItemNestedInput
    embedding?: WorkItemEmbeddingUpdateOneWithoutWorkItemNestedInput
  }

  export type WorkItemUncheckedUpdateWithoutSnapshotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWorkItemTypeFieldUpdateOperationsInput | $Enums.WorkItemType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    storyPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    epicId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: WorkItemUncheckedUpdateManyWithoutParentNestedInput
    stories?: WorkItemUncheckedUpdateManyWithoutEpicNestedInput
    details?: WorkItemDetailUncheckedUpdateOneWithoutWorkItemNestedInput
    dependenciesAsSource?: DependencyUncheckedUpdateManyWithoutSourceItemNestedInput
    dependenciesAsTarget?: DependencyUncheckedUpdateManyWithoutTargetItemNestedInput
    comments?: CommentUncheckedUpdateManyWithoutWorkItemNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutWorkItemNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutWorkItemNestedInput
    tags?: TagOnWorkItemUncheckedUpdateManyWithoutWorkItemNestedInput
    components?: ComponentOnWorkItemUncheckedUpdateManyWithoutWorkItemNestedInput
    embedding?: WorkItemEmbeddingUncheckedUpdateOneWithoutWorkItemNestedInput
  }

  export type SprintUpsertWithoutSnapshotsInput = {
    update: XOR<SprintUpdateWithoutSnapshotsInput, SprintUncheckedUpdateWithoutSnapshotsInput>
    create: XOR<SprintCreateWithoutSnapshotsInput, SprintUncheckedCreateWithoutSnapshotsInput>
    where?: SprintWhereInput
  }

  export type SprintUpdateToOneWithWhereWithoutSnapshotsInput = {
    where?: SprintWhereInput
    data: XOR<SprintUpdateWithoutSnapshotsInput, SprintUncheckedUpdateWithoutSnapshotsInput>
  }

  export type SprintUpdateWithoutSnapshotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    goal?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: StringFieldUpdateOperationsInput | string
    committedPoints?: FloatFieldUpdateOperationsInput | number
    completedPoints?: FloatFieldUpdateOperationsInput | number
    velocity?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutSprintsNestedInput
    workItems?: WorkItemUpdateManyWithoutSprintNestedInput
    retrospective?: RetrospectiveUpdateOneWithoutSprintNestedInput
    timeLogs?: TimeLogUpdateManyWithoutSprintNestedInput
    boards?: BoardUpdateManyWithoutSprintNestedInput
  }

  export type SprintUncheckedUpdateWithoutSnapshotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    goal?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: StringFieldUpdateOperationsInput | string
    committedPoints?: FloatFieldUpdateOperationsInput | number
    completedPoints?: FloatFieldUpdateOperationsInput | number
    velocity?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    workItems?: WorkItemUncheckedUpdateManyWithoutSprintNestedInput
    retrospective?: RetrospectiveUncheckedUpdateOneWithoutSprintNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutSprintNestedInput
    boards?: BoardUncheckedUpdateManyWithoutSprintNestedInput
  }

  export type UserCreateWithoutSkillProfileInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    passwordHash?: string | null
    firstName: string
    lastName: string
    avatarUrl?: string | null
    timezone?: string
    availabilityHours?: number
    isActive?: boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    organizationMemberships?: OrganizationMembershipCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMembershipCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectCreateNestedManyWithoutLeadUserInput
    assignedWorkItems?: WorkItemCreateNestedManyWithoutAssigneeInput
    createdWorkItems?: WorkItemCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    timeLogs?: TimeLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSkillProfileInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    passwordHash?: string | null
    firstName: string
    lastName: string
    avatarUrl?: string | null
    timezone?: string
    availabilityHours?: number
    isActive?: boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    organizationMemberships?: OrganizationMembershipUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMembershipUncheckedCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutLeadUserInput
    assignedWorkItems?: WorkItemUncheckedCreateNestedManyWithoutAssigneeInput
    createdWorkItems?: WorkItemUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSkillProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSkillProfileInput, UserUncheckedCreateWithoutSkillProfileInput>
  }

  export type TeamCreateWithoutSkillProfilesInput = {
    id?: string
    name: string
    description?: string | null
    velocityHistory?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutTeamsInput
    members?: TeamMembershipCreateNestedManyWithoutTeamInput
    projects?: ProjectCreateNestedManyWithoutTeamsInput
  }

  export type TeamUncheckedCreateWithoutSkillProfilesInput = {
    id?: string
    name: string
    description?: string | null
    velocityHistory?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    organizationId: string
    members?: TeamMembershipUncheckedCreateNestedManyWithoutTeamInput
    projects?: ProjectUncheckedCreateNestedManyWithoutTeamsInput
  }

  export type TeamCreateOrConnectWithoutSkillProfilesInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutSkillProfilesInput, TeamUncheckedCreateWithoutSkillProfilesInput>
  }

  export type UserUpsertWithoutSkillProfileInput = {
    update: XOR<UserUpdateWithoutSkillProfileInput, UserUncheckedUpdateWithoutSkillProfileInput>
    create: XOR<UserCreateWithoutSkillProfileInput, UserUncheckedCreateWithoutSkillProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSkillProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSkillProfileInput, UserUncheckedUpdateWithoutSkillProfileInput>
  }

  export type UserUpdateWithoutSkillProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    availabilityHours?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    organizationMemberships?: OrganizationMembershipUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMembershipUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUpdateManyWithoutLeadUserNestedInput
    assignedWorkItems?: WorkItemUpdateManyWithoutAssigneeNestedInput
    createdWorkItems?: WorkItemUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    timeLogs?: TimeLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSkillProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    availabilityHours?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    organizationMemberships?: OrganizationMembershipUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMembershipUncheckedUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutLeadUserNestedInput
    assignedWorkItems?: WorkItemUncheckedUpdateManyWithoutAssigneeNestedInput
    createdWorkItems?: WorkItemUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TeamUpsertWithoutSkillProfilesInput = {
    update: XOR<TeamUpdateWithoutSkillProfilesInput, TeamUncheckedUpdateWithoutSkillProfilesInput>
    create: XOR<TeamCreateWithoutSkillProfilesInput, TeamUncheckedCreateWithoutSkillProfilesInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutSkillProfilesInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutSkillProfilesInput, TeamUncheckedUpdateWithoutSkillProfilesInput>
  }

  export type TeamUpdateWithoutSkillProfilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    velocityHistory?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutTeamsNestedInput
    members?: TeamMembershipUpdateManyWithoutTeamNestedInput
    projects?: ProjectUpdateManyWithoutTeamsNestedInput
  }

  export type TeamUncheckedUpdateWithoutSkillProfilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    velocityHistory?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: StringFieldUpdateOperationsInput | string
    members?: TeamMembershipUncheckedUpdateManyWithoutTeamNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutTeamsNestedInput
  }

  export type ProjectCreateWithoutWorkflowRulesInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    projectType?: string
    riskScore?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    portfolio?: PortfolioCreateNestedOneWithoutProjectsInput
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    leadUser?: UserCreateNestedOneWithoutOwnedProjectsInput
    workItems?: WorkItemCreateNestedManyWithoutProjectInput
    sprints?: SprintCreateNestedManyWithoutProjectInput
    milestones?: MilestoneCreateNestedManyWithoutProjectInput
    boards?: BoardCreateNestedManyWithoutProjectInput
    workItemStates?: WorkItemStateCreateNestedManyWithoutProjectInput
    components?: ComponentCreateNestedManyWithoutProjectInput
    teams?: TeamCreateNestedManyWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutWorkflowRulesInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    projectType?: string
    riskScore?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    portfolioId?: string | null
    organizationId: string
    leadUserId?: string | null
    workItems?: WorkItemUncheckedCreateNestedManyWithoutProjectInput
    sprints?: SprintUncheckedCreateNestedManyWithoutProjectInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutProjectInput
    boards?: BoardUncheckedCreateNestedManyWithoutProjectInput
    workItemStates?: WorkItemStateUncheckedCreateNestedManyWithoutProjectInput
    components?: ComponentUncheckedCreateNestedManyWithoutProjectInput
    teams?: TeamUncheckedCreateNestedManyWithoutProjectsInput
  }

  export type ProjectCreateOrConnectWithoutWorkflowRulesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutWorkflowRulesInput, ProjectUncheckedCreateWithoutWorkflowRulesInput>
  }

  export type ProjectUpsertWithoutWorkflowRulesInput = {
    update: XOR<ProjectUpdateWithoutWorkflowRulesInput, ProjectUncheckedUpdateWithoutWorkflowRulesInput>
    create: XOR<ProjectCreateWithoutWorkflowRulesInput, ProjectUncheckedCreateWithoutWorkflowRulesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutWorkflowRulesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutWorkflowRulesInput, ProjectUncheckedUpdateWithoutWorkflowRulesInput>
  }

  export type ProjectUpdateWithoutWorkflowRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    projectType?: StringFieldUpdateOperationsInput | string
    riskScore?: FloatFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolio?: PortfolioUpdateOneWithoutProjectsNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    leadUser?: UserUpdateOneWithoutOwnedProjectsNestedInput
    workItems?: WorkItemUpdateManyWithoutProjectNestedInput
    sprints?: SprintUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUpdateManyWithoutProjectNestedInput
    boards?: BoardUpdateManyWithoutProjectNestedInput
    workItemStates?: WorkItemStateUpdateManyWithoutProjectNestedInput
    components?: ComponentUpdateManyWithoutProjectNestedInput
    teams?: TeamUpdateManyWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutWorkflowRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    projectType?: StringFieldUpdateOperationsInput | string
    riskScore?: FloatFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolioId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    leadUserId?: NullableStringFieldUpdateOperationsInput | string | null
    workItems?: WorkItemUncheckedUpdateManyWithoutProjectNestedInput
    sprints?: SprintUncheckedUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutProjectNestedInput
    boards?: BoardUncheckedUpdateManyWithoutProjectNestedInput
    workItemStates?: WorkItemStateUncheckedUpdateManyWithoutProjectNestedInput
    components?: ComponentUncheckedUpdateManyWithoutProjectNestedInput
    teams?: TeamUncheckedUpdateManyWithoutProjectsNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    passwordHash?: string | null
    firstName: string
    lastName: string
    avatarUrl?: string | null
    timezone?: string
    availabilityHours?: number
    isActive?: boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    organizationMemberships?: OrganizationMembershipCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMembershipCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectCreateNestedManyWithoutLeadUserInput
    assignedWorkItems?: WorkItemCreateNestedManyWithoutAssigneeInput
    createdWorkItems?: WorkItemCreateNestedManyWithoutCreatorInput
    comments?: CommentCreateNestedManyWithoutUserInput
    timeLogs?: TimeLogCreateNestedManyWithoutUserInput
    skillProfile?: UserSkillProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: boolean
    image?: string | null
    passwordHash?: string | null
    firstName: string
    lastName: string
    avatarUrl?: string | null
    timezone?: string
    availabilityHours?: number
    isActive?: boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    organizationMemberships?: OrganizationMembershipUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMembershipUncheckedCreateNestedManyWithoutUserInput
    ownedProjects?: ProjectUncheckedCreateNestedManyWithoutLeadUserInput
    assignedWorkItems?: WorkItemUncheckedCreateNestedManyWithoutAssigneeInput
    createdWorkItems?: WorkItemUncheckedCreateNestedManyWithoutCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    timeLogs?: TimeLogUncheckedCreateNestedManyWithoutUserInput
    skillProfile?: UserSkillProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    availabilityHours?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    organizationMemberships?: OrganizationMembershipUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMembershipUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUpdateManyWithoutLeadUserNestedInput
    assignedWorkItems?: WorkItemUpdateManyWithoutAssigneeNestedInput
    createdWorkItems?: WorkItemUpdateManyWithoutCreatorNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    timeLogs?: TimeLogUpdateManyWithoutUserNestedInput
    skillProfile?: UserSkillProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    availabilityHours?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    organizationMemberships?: OrganizationMembershipUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMembershipUncheckedUpdateManyWithoutUserNestedInput
    ownedProjects?: ProjectUncheckedUpdateManyWithoutLeadUserNestedInput
    assignedWorkItems?: WorkItemUncheckedUpdateManyWithoutAssigneeNestedInput
    createdWorkItems?: WorkItemUncheckedUpdateManyWithoutCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutUserNestedInput
    skillProfile?: UserSkillProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type SessionCreateManyUserInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type AccountCreateManyUserInput = {
    id: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationMembershipCreateManyUserInput = {
    id?: string
    organizationId: string
    role?: string
    joinedAt?: Date | string
  }

  export type TeamMembershipCreateManyUserInput = {
    id?: string
    teamId: string
    roleId?: string | null
    joinedAt?: Date | string
    leftAt?: Date | string | null
  }

  export type ProjectCreateManyLeadUserInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    projectType?: string
    riskScore?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    portfolioId?: string | null
    organizationId: string
  }

  export type WorkItemCreateManyAssigneeInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.WorkItemType
    priority?: $Enums.Priority
    storyPoints?: number | null
    estimatedHours?: number | null
    remainingHours?: number | null
    order?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    epicId?: string | null
    projectId: string
    stateId?: string | null
    creatorId: string
    sprintId?: string | null
  }

  export type WorkItemCreateManyCreatorInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.WorkItemType
    priority?: $Enums.Priority
    storyPoints?: number | null
    estimatedHours?: number | null
    remainingHours?: number | null
    order?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    epicId?: string | null
    projectId: string
    stateId?: string | null
    assigneeId?: string | null
    sprintId?: string | null
  }

  export type CommentCreateManyUserInput = {
    id?: string
    body: string
    sentimentScore?: number | null
    sentimentLabel?: string | null
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workItemId: string
  }

  export type TimeLogCreateManyUserInput = {
    id?: string
    duration: number
    description?: string | null
    billable?: boolean
    logDate: Date | string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workItemId: string
    sprintId?: string | null
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    type: string
    title: string
    body?: string | null
    targetUrl?: string | null
    priorityScore?: number
    isRead?: boolean
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationMembershipUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutUsersNestedInput
  }

  export type OrganizationMembershipUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationMembershipUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMembershipUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    team?: TeamUpdateOneRequiredWithoutMembersNestedInput
    role?: RoleUpdateOneWithoutTeamMembershipsNestedInput
  }

  export type TeamMembershipUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TeamMembershipUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProjectUpdateWithoutLeadUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    projectType?: StringFieldUpdateOperationsInput | string
    riskScore?: FloatFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolio?: PortfolioUpdateOneWithoutProjectsNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    workItems?: WorkItemUpdateManyWithoutProjectNestedInput
    sprints?: SprintUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUpdateManyWithoutProjectNestedInput
    boards?: BoardUpdateManyWithoutProjectNestedInput
    workflowRules?: WorkflowRuleUpdateManyWithoutProjectNestedInput
    workItemStates?: WorkItemStateUpdateManyWithoutProjectNestedInput
    components?: ComponentUpdateManyWithoutProjectNestedInput
    teams?: TeamUpdateManyWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutLeadUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    projectType?: StringFieldUpdateOperationsInput | string
    riskScore?: FloatFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolioId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    workItems?: WorkItemUncheckedUpdateManyWithoutProjectNestedInput
    sprints?: SprintUncheckedUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutProjectNestedInput
    boards?: BoardUncheckedUpdateManyWithoutProjectNestedInput
    workflowRules?: WorkflowRuleUncheckedUpdateManyWithoutProjectNestedInput
    workItemStates?: WorkItemStateUncheckedUpdateManyWithoutProjectNestedInput
    components?: ComponentUncheckedUpdateManyWithoutProjectNestedInput
    teams?: TeamUncheckedUpdateManyWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutLeadUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    projectType?: StringFieldUpdateOperationsInput | string
    riskScore?: FloatFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolioId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkItemUpdateWithoutAssigneeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWorkItemTypeFieldUpdateOperationsInput | $Enums.WorkItemType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    storyPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: WorkItemUpdateOneWithoutChildrenNestedInput
    children?: WorkItemUpdateManyWithoutParentNestedInput
    epic?: WorkItemUpdateOneWithoutStoriesNestedInput
    stories?: WorkItemUpdateManyWithoutEpicNestedInput
    project?: ProjectUpdateOneRequiredWithoutWorkItemsNestedInput
    state?: WorkItemStateUpdateOneWithoutWorkItemsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedWorkItemsNestedInput
    sprint?: SprintUpdateOneWithoutWorkItemsNestedInput
    details?: WorkItemDetailUpdateOneWithoutWorkItemNestedInput
    dependenciesAsSource?: DependencyUpdateManyWithoutSourceItemNestedInput
    dependenciesAsTarget?: DependencyUpdateManyWithoutTargetItemNestedInput
    comments?: CommentUpdateManyWithoutWorkItemNestedInput
    attachments?: AttachmentUpdateManyWithoutWorkItemNestedInput
    timeLogs?: TimeLogUpdateManyWithoutWorkItemNestedInput
    snapshots?: WorkItemSnapshotUpdateManyWithoutWorkItemNestedInput
    tags?: TagOnWorkItemUpdateManyWithoutWorkItemNestedInput
    components?: ComponentOnWorkItemUpdateManyWithoutWorkItemNestedInput
    embedding?: WorkItemEmbeddingUpdateOneWithoutWorkItemNestedInput
  }

  export type WorkItemUncheckedUpdateWithoutAssigneeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWorkItemTypeFieldUpdateOperationsInput | $Enums.WorkItemType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    storyPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    epicId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: WorkItemUncheckedUpdateManyWithoutParentNestedInput
    stories?: WorkItemUncheckedUpdateManyWithoutEpicNestedInput
    details?: WorkItemDetailUncheckedUpdateOneWithoutWorkItemNestedInput
    dependenciesAsSource?: DependencyUncheckedUpdateManyWithoutSourceItemNestedInput
    dependenciesAsTarget?: DependencyUncheckedUpdateManyWithoutTargetItemNestedInput
    comments?: CommentUncheckedUpdateManyWithoutWorkItemNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutWorkItemNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutWorkItemNestedInput
    snapshots?: WorkItemSnapshotUncheckedUpdateManyWithoutWorkItemNestedInput
    tags?: TagOnWorkItemUncheckedUpdateManyWithoutWorkItemNestedInput
    components?: ComponentOnWorkItemUncheckedUpdateManyWithoutWorkItemNestedInput
    embedding?: WorkItemEmbeddingUncheckedUpdateOneWithoutWorkItemNestedInput
  }

  export type WorkItemUncheckedUpdateManyWithoutAssigneeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWorkItemTypeFieldUpdateOperationsInput | $Enums.WorkItemType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    storyPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    epicId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkItemUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWorkItemTypeFieldUpdateOperationsInput | $Enums.WorkItemType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    storyPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: WorkItemUpdateOneWithoutChildrenNestedInput
    children?: WorkItemUpdateManyWithoutParentNestedInput
    epic?: WorkItemUpdateOneWithoutStoriesNestedInput
    stories?: WorkItemUpdateManyWithoutEpicNestedInput
    project?: ProjectUpdateOneRequiredWithoutWorkItemsNestedInput
    state?: WorkItemStateUpdateOneWithoutWorkItemsNestedInput
    assignee?: UserUpdateOneWithoutAssignedWorkItemsNestedInput
    sprint?: SprintUpdateOneWithoutWorkItemsNestedInput
    details?: WorkItemDetailUpdateOneWithoutWorkItemNestedInput
    dependenciesAsSource?: DependencyUpdateManyWithoutSourceItemNestedInput
    dependenciesAsTarget?: DependencyUpdateManyWithoutTargetItemNestedInput
    comments?: CommentUpdateManyWithoutWorkItemNestedInput
    attachments?: AttachmentUpdateManyWithoutWorkItemNestedInput
    timeLogs?: TimeLogUpdateManyWithoutWorkItemNestedInput
    snapshots?: WorkItemSnapshotUpdateManyWithoutWorkItemNestedInput
    tags?: TagOnWorkItemUpdateManyWithoutWorkItemNestedInput
    components?: ComponentOnWorkItemUpdateManyWithoutWorkItemNestedInput
    embedding?: WorkItemEmbeddingUpdateOneWithoutWorkItemNestedInput
  }

  export type WorkItemUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWorkItemTypeFieldUpdateOperationsInput | $Enums.WorkItemType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    storyPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    epicId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: WorkItemUncheckedUpdateManyWithoutParentNestedInput
    stories?: WorkItemUncheckedUpdateManyWithoutEpicNestedInput
    details?: WorkItemDetailUncheckedUpdateOneWithoutWorkItemNestedInput
    dependenciesAsSource?: DependencyUncheckedUpdateManyWithoutSourceItemNestedInput
    dependenciesAsTarget?: DependencyUncheckedUpdateManyWithoutTargetItemNestedInput
    comments?: CommentUncheckedUpdateManyWithoutWorkItemNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutWorkItemNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutWorkItemNestedInput
    snapshots?: WorkItemSnapshotUncheckedUpdateManyWithoutWorkItemNestedInput
    tags?: TagOnWorkItemUncheckedUpdateManyWithoutWorkItemNestedInput
    components?: ComponentOnWorkItemUncheckedUpdateManyWithoutWorkItemNestedInput
    embedding?: WorkItemEmbeddingUncheckedUpdateOneWithoutWorkItemNestedInput
  }

  export type WorkItemUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWorkItemTypeFieldUpdateOperationsInput | $Enums.WorkItemType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    storyPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    epicId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    sentimentLabel?: NullableStringFieldUpdateOperationsInput | string | null
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workItem?: WorkItemUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    sentimentLabel?: NullableStringFieldUpdateOperationsInput | string | null
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workItemId?: StringFieldUpdateOperationsInput | string
  }

  export type CommentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    sentimentLabel?: NullableStringFieldUpdateOperationsInput | string | null
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workItemId?: StringFieldUpdateOperationsInput | string
  }

  export type TimeLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    billable?: BoolFieldUpdateOperationsInput | boolean
    logDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workItem?: WorkItemUpdateOneRequiredWithoutTimeLogsNestedInput
    sprint?: SprintUpdateOneWithoutTimeLogsNestedInput
  }

  export type TimeLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    billable?: BoolFieldUpdateOperationsInput | boolean
    logDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workItemId?: StringFieldUpdateOperationsInput | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TimeLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    billable?: BoolFieldUpdateOperationsInput | boolean
    logDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workItemId?: StringFieldUpdateOperationsInput | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    targetUrl?: NullableStringFieldUpdateOperationsInput | string | null
    priorityScore?: FloatFieldUpdateOperationsInput | number
    isRead?: BoolFieldUpdateOperationsInput | boolean
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    targetUrl?: NullableStringFieldUpdateOperationsInput | string | null
    priorityScore?: FloatFieldUpdateOperationsInput | number
    isRead?: BoolFieldUpdateOperationsInput | boolean
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    targetUrl?: NullableStringFieldUpdateOperationsInput | string | null
    priorityScore?: FloatFieldUpdateOperationsInput | number
    isRead?: BoolFieldUpdateOperationsInput | boolean
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrganizationMembershipCreateManyOrganizationInput = {
    id?: string
    userId: string
    role?: string
    joinedAt?: Date | string
  }

  export type PortfolioCreateManyOrganizationInput = {
    id?: string
    name: string
    description?: string | null
    strategicGoal?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamCreateManyOrganizationInput = {
    id?: string
    name: string
    description?: string | null
    velocityHistory?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectCreateManyOrganizationInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    projectType?: string
    riskScore?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    portfolioId?: string | null
    leadUserId?: string | null
  }

  export type OrganizationMembershipUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrganizationMembershipsNestedInput
  }

  export type OrganizationMembershipUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationMembershipUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortfolioUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    strategicGoal?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutPortfolioNestedInput
  }

  export type PortfolioUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    strategicGoal?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutPortfolioNestedInput
  }

  export type PortfolioUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    strategicGoal?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    velocityHistory?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMembershipUpdateManyWithoutTeamNestedInput
    projects?: ProjectUpdateManyWithoutTeamsNestedInput
    skillProfiles?: UserSkillProfileUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    velocityHistory?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMembershipUncheckedUpdateManyWithoutTeamNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutTeamsNestedInput
    skillProfiles?: UserSkillProfileUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    velocityHistory?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    projectType?: StringFieldUpdateOperationsInput | string
    riskScore?: FloatFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolio?: PortfolioUpdateOneWithoutProjectsNestedInput
    leadUser?: UserUpdateOneWithoutOwnedProjectsNestedInput
    workItems?: WorkItemUpdateManyWithoutProjectNestedInput
    sprints?: SprintUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUpdateManyWithoutProjectNestedInput
    boards?: BoardUpdateManyWithoutProjectNestedInput
    workflowRules?: WorkflowRuleUpdateManyWithoutProjectNestedInput
    workItemStates?: WorkItemStateUpdateManyWithoutProjectNestedInput
    components?: ComponentUpdateManyWithoutProjectNestedInput
    teams?: TeamUpdateManyWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    projectType?: StringFieldUpdateOperationsInput | string
    riskScore?: FloatFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolioId?: NullableStringFieldUpdateOperationsInput | string | null
    leadUserId?: NullableStringFieldUpdateOperationsInput | string | null
    workItems?: WorkItemUncheckedUpdateManyWithoutProjectNestedInput
    sprints?: SprintUncheckedUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutProjectNestedInput
    boards?: BoardUncheckedUpdateManyWithoutProjectNestedInput
    workflowRules?: WorkflowRuleUncheckedUpdateManyWithoutProjectNestedInput
    workItemStates?: WorkItemStateUncheckedUpdateManyWithoutProjectNestedInput
    components?: ComponentUncheckedUpdateManyWithoutProjectNestedInput
    teams?: TeamUncheckedUpdateManyWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    projectType?: StringFieldUpdateOperationsInput | string
    riskScore?: FloatFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolioId?: NullableStringFieldUpdateOperationsInput | string | null
    leadUserId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TeamMembershipCreateManyTeamInput = {
    id?: string
    userId: string
    roleId?: string | null
    joinedAt?: Date | string
    leftAt?: Date | string | null
  }

  export type UserSkillProfileCreateManyTeamInput = {
    id?: string
    skills?: UserSkillProfileCreateskillsInput | string[]
    proficiencyScores?: JsonNullValueInput | InputJsonValue
    certifiedSkills?: UserSkillProfileCreatecertifiedSkillsInput | string[]
    overallProficiency?: number
    lastUpdated?: Date | string
    userId: string
  }

  export type TeamMembershipUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutTeamMembershipsNestedInput
    role?: RoleUpdateOneWithoutTeamMembershipsNestedInput
  }

  export type TeamMembershipUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TeamMembershipUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProjectUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    projectType?: StringFieldUpdateOperationsInput | string
    riskScore?: FloatFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolio?: PortfolioUpdateOneWithoutProjectsNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    leadUser?: UserUpdateOneWithoutOwnedProjectsNestedInput
    workItems?: WorkItemUpdateManyWithoutProjectNestedInput
    sprints?: SprintUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUpdateManyWithoutProjectNestedInput
    boards?: BoardUpdateManyWithoutProjectNestedInput
    workflowRules?: WorkflowRuleUpdateManyWithoutProjectNestedInput
    workItemStates?: WorkItemStateUpdateManyWithoutProjectNestedInput
    components?: ComponentUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    projectType?: StringFieldUpdateOperationsInput | string
    riskScore?: FloatFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolioId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    leadUserId?: NullableStringFieldUpdateOperationsInput | string | null
    workItems?: WorkItemUncheckedUpdateManyWithoutProjectNestedInput
    sprints?: SprintUncheckedUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutProjectNestedInput
    boards?: BoardUncheckedUpdateManyWithoutProjectNestedInput
    workflowRules?: WorkflowRuleUncheckedUpdateManyWithoutProjectNestedInput
    workItemStates?: WorkItemStateUncheckedUpdateManyWithoutProjectNestedInput
    components?: ComponentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    projectType?: StringFieldUpdateOperationsInput | string
    riskScore?: FloatFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    portfolioId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    leadUserId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserSkillProfileUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    skills?: UserSkillProfileUpdateskillsInput | string[]
    proficiencyScores?: JsonNullValueInput | InputJsonValue
    certifiedSkills?: UserSkillProfileUpdatecertifiedSkillsInput | string[]
    overallProficiency?: FloatFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSkillProfileNestedInput
  }

  export type UserSkillProfileUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    skills?: UserSkillProfileUpdateskillsInput | string[]
    proficiencyScores?: JsonNullValueInput | InputJsonValue
    certifiedSkills?: UserSkillProfileUpdatecertifiedSkillsInput | string[]
    overallProficiency?: FloatFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserSkillProfileUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    skills?: UserSkillProfileUpdateskillsInput | string[]
    proficiencyScores?: JsonNullValueInput | InputJsonValue
    certifiedSkills?: UserSkillProfileUpdatecertifiedSkillsInput | string[]
    overallProficiency?: FloatFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type TeamMembershipCreateManyRoleInput = {
    id?: string
    userId: string
    teamId: string
    joinedAt?: Date | string
    leftAt?: Date | string | null
  }

  export type TeamMembershipUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutTeamMembershipsNestedInput
    team?: TeamUpdateOneRequiredWithoutMembersNestedInput
  }

  export type TeamMembershipUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TeamMembershipUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProjectCreateManyPortfolioInput = {
    id?: string
    key: string
    name: string
    description?: string | null
    projectType?: string
    riskScore?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    organizationId: string
    leadUserId?: string | null
  }

  export type ProjectUpdateWithoutPortfolioInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    projectType?: StringFieldUpdateOperationsInput | string
    riskScore?: FloatFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    leadUser?: UserUpdateOneWithoutOwnedProjectsNestedInput
    workItems?: WorkItemUpdateManyWithoutProjectNestedInput
    sprints?: SprintUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUpdateManyWithoutProjectNestedInput
    boards?: BoardUpdateManyWithoutProjectNestedInput
    workflowRules?: WorkflowRuleUpdateManyWithoutProjectNestedInput
    workItemStates?: WorkItemStateUpdateManyWithoutProjectNestedInput
    components?: ComponentUpdateManyWithoutProjectNestedInput
    teams?: TeamUpdateManyWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutPortfolioInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    projectType?: StringFieldUpdateOperationsInput | string
    riskScore?: FloatFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: StringFieldUpdateOperationsInput | string
    leadUserId?: NullableStringFieldUpdateOperationsInput | string | null
    workItems?: WorkItemUncheckedUpdateManyWithoutProjectNestedInput
    sprints?: SprintUncheckedUpdateManyWithoutProjectNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutProjectNestedInput
    boards?: BoardUncheckedUpdateManyWithoutProjectNestedInput
    workflowRules?: WorkflowRuleUncheckedUpdateManyWithoutProjectNestedInput
    workItemStates?: WorkItemStateUncheckedUpdateManyWithoutProjectNestedInput
    components?: ComponentUncheckedUpdateManyWithoutProjectNestedInput
    teams?: TeamUncheckedUpdateManyWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutPortfolioInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    projectType?: StringFieldUpdateOperationsInput | string
    riskScore?: FloatFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: StringFieldUpdateOperationsInput | string
    leadUserId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkItemCreateManyProjectInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.WorkItemType
    priority?: $Enums.Priority
    storyPoints?: number | null
    estimatedHours?: number | null
    remainingHours?: number | null
    order?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    epicId?: string | null
    stateId?: string | null
    assigneeId?: string | null
    creatorId: string
    sprintId?: string | null
  }

  export type SprintCreateManyProjectInput = {
    id?: string
    name: string
    goal?: string | null
    startDate: Date | string
    endDate: Date | string
    state?: string
    committedPoints?: number
    completedPoints?: number
    velocity?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MilestoneCreateManyProjectInput = {
    id?: string
    name: string
    description?: string | null
    dueDate: Date | string
    completed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BoardCreateManyProjectInput = {
    id?: string
    name: string
    boardType?: string
    filterQuery?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sprintId?: string | null
  }

  export type WorkflowRuleCreateManyProjectInput = {
    id?: string
    name: string
    description?: string | null
    trigger: string
    action: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    priority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkItemStateCreateManyProjectInput = {
    id?: string
    name: string
    category: $Enums.WorkItemStateCategory
    position: number
    wipLimit?: number | null
    color?: string
    icon?: string | null
    isInitial?: boolean
    isFinal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComponentCreateManyProjectInput = {
    id?: string
    name: string
    description?: string | null
    color?: string
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkItemUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWorkItemTypeFieldUpdateOperationsInput | $Enums.WorkItemType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    storyPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: WorkItemUpdateOneWithoutChildrenNestedInput
    children?: WorkItemUpdateManyWithoutParentNestedInput
    epic?: WorkItemUpdateOneWithoutStoriesNestedInput
    stories?: WorkItemUpdateManyWithoutEpicNestedInput
    state?: WorkItemStateUpdateOneWithoutWorkItemsNestedInput
    assignee?: UserUpdateOneWithoutAssignedWorkItemsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedWorkItemsNestedInput
    sprint?: SprintUpdateOneWithoutWorkItemsNestedInput
    details?: WorkItemDetailUpdateOneWithoutWorkItemNestedInput
    dependenciesAsSource?: DependencyUpdateManyWithoutSourceItemNestedInput
    dependenciesAsTarget?: DependencyUpdateManyWithoutTargetItemNestedInput
    comments?: CommentUpdateManyWithoutWorkItemNestedInput
    attachments?: AttachmentUpdateManyWithoutWorkItemNestedInput
    timeLogs?: TimeLogUpdateManyWithoutWorkItemNestedInput
    snapshots?: WorkItemSnapshotUpdateManyWithoutWorkItemNestedInput
    tags?: TagOnWorkItemUpdateManyWithoutWorkItemNestedInput
    components?: ComponentOnWorkItemUpdateManyWithoutWorkItemNestedInput
    embedding?: WorkItemEmbeddingUpdateOneWithoutWorkItemNestedInput
  }

  export type WorkItemUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWorkItemTypeFieldUpdateOperationsInput | $Enums.WorkItemType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    storyPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    epicId?: NullableStringFieldUpdateOperationsInput | string | null
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: WorkItemUncheckedUpdateManyWithoutParentNestedInput
    stories?: WorkItemUncheckedUpdateManyWithoutEpicNestedInput
    details?: WorkItemDetailUncheckedUpdateOneWithoutWorkItemNestedInput
    dependenciesAsSource?: DependencyUncheckedUpdateManyWithoutSourceItemNestedInput
    dependenciesAsTarget?: DependencyUncheckedUpdateManyWithoutTargetItemNestedInput
    comments?: CommentUncheckedUpdateManyWithoutWorkItemNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutWorkItemNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutWorkItemNestedInput
    snapshots?: WorkItemSnapshotUncheckedUpdateManyWithoutWorkItemNestedInput
    tags?: TagOnWorkItemUncheckedUpdateManyWithoutWorkItemNestedInput
    components?: ComponentOnWorkItemUncheckedUpdateManyWithoutWorkItemNestedInput
    embedding?: WorkItemEmbeddingUncheckedUpdateOneWithoutWorkItemNestedInput
  }

  export type WorkItemUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWorkItemTypeFieldUpdateOperationsInput | $Enums.WorkItemType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    storyPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    epicId?: NullableStringFieldUpdateOperationsInput | string | null
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SprintUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    goal?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: StringFieldUpdateOperationsInput | string
    committedPoints?: FloatFieldUpdateOperationsInput | number
    completedPoints?: FloatFieldUpdateOperationsInput | number
    velocity?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workItems?: WorkItemUpdateManyWithoutSprintNestedInput
    snapshots?: WorkItemSnapshotUpdateManyWithoutSprintNestedInput
    retrospective?: RetrospectiveUpdateOneWithoutSprintNestedInput
    timeLogs?: TimeLogUpdateManyWithoutSprintNestedInput
    boards?: BoardUpdateManyWithoutSprintNestedInput
  }

  export type SprintUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    goal?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: StringFieldUpdateOperationsInput | string
    committedPoints?: FloatFieldUpdateOperationsInput | number
    completedPoints?: FloatFieldUpdateOperationsInput | number
    velocity?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workItems?: WorkItemUncheckedUpdateManyWithoutSprintNestedInput
    snapshots?: WorkItemSnapshotUncheckedUpdateManyWithoutSprintNestedInput
    retrospective?: RetrospectiveUncheckedUpdateOneWithoutSprintNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutSprintNestedInput
    boards?: BoardUncheckedUpdateManyWithoutSprintNestedInput
  }

  export type SprintUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    goal?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: StringFieldUpdateOperationsInput | string
    committedPoints?: FloatFieldUpdateOperationsInput | number
    completedPoints?: FloatFieldUpdateOperationsInput | number
    velocity?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilestoneUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilestoneUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilestoneUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BoardUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    boardType?: StringFieldUpdateOperationsInput | string
    filterQuery?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sprint?: SprintUpdateOneWithoutBoardsNestedInput
    lanes?: BoardLaneUpdateManyWithoutBoardNestedInput
  }

  export type BoardUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    boardType?: StringFieldUpdateOperationsInput | string
    filterQuery?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    lanes?: BoardLaneUncheckedUpdateManyWithoutBoardNestedInput
  }

  export type BoardUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    boardType?: StringFieldUpdateOperationsInput | string
    filterQuery?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkflowRuleUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trigger?: StringFieldUpdateOperationsInput | string
    action?: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowRuleUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trigger?: StringFieldUpdateOperationsInput | string
    action?: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowRuleUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trigger?: StringFieldUpdateOperationsInput | string
    action?: JsonNullValueInput | InputJsonValue
    conditions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkItemStateUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumWorkItemStateCategoryFieldUpdateOperationsInput | $Enums.WorkItemStateCategory
    position?: IntFieldUpdateOperationsInput | number
    wipLimit?: NullableIntFieldUpdateOperationsInput | number | null
    color?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isInitial?: BoolFieldUpdateOperationsInput | boolean
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workItems?: WorkItemUpdateManyWithoutStateNestedInput
  }

  export type WorkItemStateUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumWorkItemStateCategoryFieldUpdateOperationsInput | $Enums.WorkItemStateCategory
    position?: IntFieldUpdateOperationsInput | number
    wipLimit?: NullableIntFieldUpdateOperationsInput | number | null
    color?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isInitial?: BoolFieldUpdateOperationsInput | boolean
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workItems?: WorkItemUncheckedUpdateManyWithoutStateNestedInput
  }

  export type WorkItemStateUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumWorkItemStateCategoryFieldUpdateOperationsInput | $Enums.WorkItemStateCategory
    position?: IntFieldUpdateOperationsInput | number
    wipLimit?: NullableIntFieldUpdateOperationsInput | number | null
    color?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isInitial?: BoolFieldUpdateOperationsInput | boolean
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComponentUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workItems?: ComponentOnWorkItemUpdateManyWithoutComponentNestedInput
  }

  export type ComponentUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workItems?: ComponentOnWorkItemUncheckedUpdateManyWithoutComponentNestedInput
  }

  export type ComponentUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    velocityHistory?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutTeamsNestedInput
    members?: TeamMembershipUpdateManyWithoutTeamNestedInput
    skillProfiles?: UserSkillProfileUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    velocityHistory?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: StringFieldUpdateOperationsInput | string
    members?: TeamMembershipUncheckedUpdateManyWithoutTeamNestedInput
    skillProfiles?: UserSkillProfileUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateManyWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    velocityHistory?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkItemCreateManySprintInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.WorkItemType
    priority?: $Enums.Priority
    storyPoints?: number | null
    estimatedHours?: number | null
    remainingHours?: number | null
    order?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    epicId?: string | null
    projectId: string
    stateId?: string | null
    assigneeId?: string | null
    creatorId: string
  }

  export type WorkItemSnapshotCreateManySprintInput = {
    id?: string
    stateId?: string | null
    pointsRemaining?: number | null
    hoursRemaining?: number | null
    hoursSpent?: number | null
    daysInCurrentState?: number
    blockerIds?: WorkItemSnapshotCreateblockerIdsInput | string[]
    snapshotDate?: Date | string
    workItemId: string
  }

  export type TimeLogCreateManySprintInput = {
    id?: string
    duration: number
    description?: string | null
    billable?: boolean
    logDate: Date | string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workItemId: string
    userId: string
  }

  export type BoardCreateManySprintInput = {
    id?: string
    name: string
    boardType?: string
    filterQuery?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: string
  }

  export type WorkItemUpdateWithoutSprintInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWorkItemTypeFieldUpdateOperationsInput | $Enums.WorkItemType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    storyPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: WorkItemUpdateOneWithoutChildrenNestedInput
    children?: WorkItemUpdateManyWithoutParentNestedInput
    epic?: WorkItemUpdateOneWithoutStoriesNestedInput
    stories?: WorkItemUpdateManyWithoutEpicNestedInput
    project?: ProjectUpdateOneRequiredWithoutWorkItemsNestedInput
    state?: WorkItemStateUpdateOneWithoutWorkItemsNestedInput
    assignee?: UserUpdateOneWithoutAssignedWorkItemsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedWorkItemsNestedInput
    details?: WorkItemDetailUpdateOneWithoutWorkItemNestedInput
    dependenciesAsSource?: DependencyUpdateManyWithoutSourceItemNestedInput
    dependenciesAsTarget?: DependencyUpdateManyWithoutTargetItemNestedInput
    comments?: CommentUpdateManyWithoutWorkItemNestedInput
    attachments?: AttachmentUpdateManyWithoutWorkItemNestedInput
    timeLogs?: TimeLogUpdateManyWithoutWorkItemNestedInput
    snapshots?: WorkItemSnapshotUpdateManyWithoutWorkItemNestedInput
    tags?: TagOnWorkItemUpdateManyWithoutWorkItemNestedInput
    components?: ComponentOnWorkItemUpdateManyWithoutWorkItemNestedInput
    embedding?: WorkItemEmbeddingUpdateOneWithoutWorkItemNestedInput
  }

  export type WorkItemUncheckedUpdateWithoutSprintInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWorkItemTypeFieldUpdateOperationsInput | $Enums.WorkItemType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    storyPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    epicId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    children?: WorkItemUncheckedUpdateManyWithoutParentNestedInput
    stories?: WorkItemUncheckedUpdateManyWithoutEpicNestedInput
    details?: WorkItemDetailUncheckedUpdateOneWithoutWorkItemNestedInput
    dependenciesAsSource?: DependencyUncheckedUpdateManyWithoutSourceItemNestedInput
    dependenciesAsTarget?: DependencyUncheckedUpdateManyWithoutTargetItemNestedInput
    comments?: CommentUncheckedUpdateManyWithoutWorkItemNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutWorkItemNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutWorkItemNestedInput
    snapshots?: WorkItemSnapshotUncheckedUpdateManyWithoutWorkItemNestedInput
    tags?: TagOnWorkItemUncheckedUpdateManyWithoutWorkItemNestedInput
    components?: ComponentOnWorkItemUncheckedUpdateManyWithoutWorkItemNestedInput
    embedding?: WorkItemEmbeddingUncheckedUpdateOneWithoutWorkItemNestedInput
  }

  export type WorkItemUncheckedUpdateManyWithoutSprintInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWorkItemTypeFieldUpdateOperationsInput | $Enums.WorkItemType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    storyPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    epicId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkItemSnapshotUpdateWithoutSprintInput = {
    id?: StringFieldUpdateOperationsInput | string
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    pointsRemaining?: NullableFloatFieldUpdateOperationsInput | number | null
    hoursRemaining?: NullableFloatFieldUpdateOperationsInput | number | null
    hoursSpent?: NullableFloatFieldUpdateOperationsInput | number | null
    daysInCurrentState?: IntFieldUpdateOperationsInput | number
    blockerIds?: WorkItemSnapshotUpdateblockerIdsInput | string[]
    snapshotDate?: DateTimeFieldUpdateOperationsInput | Date | string
    workItem?: WorkItemUpdateOneRequiredWithoutSnapshotsNestedInput
  }

  export type WorkItemSnapshotUncheckedUpdateWithoutSprintInput = {
    id?: StringFieldUpdateOperationsInput | string
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    pointsRemaining?: NullableFloatFieldUpdateOperationsInput | number | null
    hoursRemaining?: NullableFloatFieldUpdateOperationsInput | number | null
    hoursSpent?: NullableFloatFieldUpdateOperationsInput | number | null
    daysInCurrentState?: IntFieldUpdateOperationsInput | number
    blockerIds?: WorkItemSnapshotUpdateblockerIdsInput | string[]
    snapshotDate?: DateTimeFieldUpdateOperationsInput | Date | string
    workItemId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkItemSnapshotUncheckedUpdateManyWithoutSprintInput = {
    id?: StringFieldUpdateOperationsInput | string
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    pointsRemaining?: NullableFloatFieldUpdateOperationsInput | number | null
    hoursRemaining?: NullableFloatFieldUpdateOperationsInput | number | null
    hoursSpent?: NullableFloatFieldUpdateOperationsInput | number | null
    daysInCurrentState?: IntFieldUpdateOperationsInput | number
    blockerIds?: WorkItemSnapshotUpdateblockerIdsInput | string[]
    snapshotDate?: DateTimeFieldUpdateOperationsInput | Date | string
    workItemId?: StringFieldUpdateOperationsInput | string
  }

  export type TimeLogUpdateWithoutSprintInput = {
    id?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    billable?: BoolFieldUpdateOperationsInput | boolean
    logDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workItem?: WorkItemUpdateOneRequiredWithoutTimeLogsNestedInput
    user?: UserUpdateOneRequiredWithoutTimeLogsNestedInput
  }

  export type TimeLogUncheckedUpdateWithoutSprintInput = {
    id?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    billable?: BoolFieldUpdateOperationsInput | boolean
    logDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workItemId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type TimeLogUncheckedUpdateManyWithoutSprintInput = {
    id?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    billable?: BoolFieldUpdateOperationsInput | boolean
    logDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workItemId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type BoardUpdateWithoutSprintInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    boardType?: StringFieldUpdateOperationsInput | string
    filterQuery?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutBoardsNestedInput
    lanes?: BoardLaneUpdateManyWithoutBoardNestedInput
  }

  export type BoardUncheckedUpdateWithoutSprintInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    boardType?: StringFieldUpdateOperationsInput | string
    filterQuery?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    lanes?: BoardLaneUncheckedUpdateManyWithoutBoardNestedInput
  }

  export type BoardUncheckedUpdateManyWithoutSprintInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    boardType?: StringFieldUpdateOperationsInput | string
    filterQuery?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkItemCreateManyParentInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.WorkItemType
    priority?: $Enums.Priority
    storyPoints?: number | null
    estimatedHours?: number | null
    remainingHours?: number | null
    order?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    epicId?: string | null
    projectId: string
    stateId?: string | null
    assigneeId?: string | null
    creatorId: string
    sprintId?: string | null
  }

  export type WorkItemCreateManyEpicInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.WorkItemType
    priority?: $Enums.Priority
    storyPoints?: number | null
    estimatedHours?: number | null
    remainingHours?: number | null
    order?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    projectId: string
    stateId?: string | null
    assigneeId?: string | null
    creatorId: string
    sprintId?: string | null
  }

  export type DependencyCreateManySourceItemInput = {
    id?: string
    dependencyType?: string
    description?: string | null
    createdAt?: Date | string
    targetItemId: string
  }

  export type DependencyCreateManyTargetItemInput = {
    id?: string
    dependencyType?: string
    description?: string | null
    createdAt?: Date | string
    sourceItemId: string
  }

  export type CommentCreateManyWorkItemInput = {
    id?: string
    body: string
    sentimentScore?: number | null
    sentimentLabel?: string | null
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type AttachmentCreateManyWorkItemInput = {
    id?: string
    fileName: string
    fileType: string
    fileSize: number
    storagePath: string
    fileUrl: string
    ocrContent?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    uploadedBy: string
  }

  export type TimeLogCreateManyWorkItemInput = {
    id?: string
    duration: number
    description?: string | null
    billable?: boolean
    logDate: Date | string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    sprintId?: string | null
  }

  export type WorkItemSnapshotCreateManyWorkItemInput = {
    id?: string
    stateId?: string | null
    pointsRemaining?: number | null
    hoursRemaining?: number | null
    hoursSpent?: number | null
    daysInCurrentState?: number
    blockerIds?: WorkItemSnapshotCreateblockerIdsInput | string[]
    snapshotDate?: Date | string
    sprintId?: string | null
  }

  export type TagOnWorkItemCreateManyWorkItemInput = {
    tagId: string
  }

  export type ComponentOnWorkItemCreateManyWorkItemInput = {
    componentId: string
    assignedAt?: Date | string
  }

  export type WorkItemUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWorkItemTypeFieldUpdateOperationsInput | $Enums.WorkItemType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    storyPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: WorkItemUpdateManyWithoutParentNestedInput
    epic?: WorkItemUpdateOneWithoutStoriesNestedInput
    stories?: WorkItemUpdateManyWithoutEpicNestedInput
    project?: ProjectUpdateOneRequiredWithoutWorkItemsNestedInput
    state?: WorkItemStateUpdateOneWithoutWorkItemsNestedInput
    assignee?: UserUpdateOneWithoutAssignedWorkItemsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedWorkItemsNestedInput
    sprint?: SprintUpdateOneWithoutWorkItemsNestedInput
    details?: WorkItemDetailUpdateOneWithoutWorkItemNestedInput
    dependenciesAsSource?: DependencyUpdateManyWithoutSourceItemNestedInput
    dependenciesAsTarget?: DependencyUpdateManyWithoutTargetItemNestedInput
    comments?: CommentUpdateManyWithoutWorkItemNestedInput
    attachments?: AttachmentUpdateManyWithoutWorkItemNestedInput
    timeLogs?: TimeLogUpdateManyWithoutWorkItemNestedInput
    snapshots?: WorkItemSnapshotUpdateManyWithoutWorkItemNestedInput
    tags?: TagOnWorkItemUpdateManyWithoutWorkItemNestedInput
    components?: ComponentOnWorkItemUpdateManyWithoutWorkItemNestedInput
    embedding?: WorkItemEmbeddingUpdateOneWithoutWorkItemNestedInput
  }

  export type WorkItemUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWorkItemTypeFieldUpdateOperationsInput | $Enums.WorkItemType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    storyPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    epicId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: WorkItemUncheckedUpdateManyWithoutParentNestedInput
    stories?: WorkItemUncheckedUpdateManyWithoutEpicNestedInput
    details?: WorkItemDetailUncheckedUpdateOneWithoutWorkItemNestedInput
    dependenciesAsSource?: DependencyUncheckedUpdateManyWithoutSourceItemNestedInput
    dependenciesAsTarget?: DependencyUncheckedUpdateManyWithoutTargetItemNestedInput
    comments?: CommentUncheckedUpdateManyWithoutWorkItemNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutWorkItemNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutWorkItemNestedInput
    snapshots?: WorkItemSnapshotUncheckedUpdateManyWithoutWorkItemNestedInput
    tags?: TagOnWorkItemUncheckedUpdateManyWithoutWorkItemNestedInput
    components?: ComponentOnWorkItemUncheckedUpdateManyWithoutWorkItemNestedInput
    embedding?: WorkItemEmbeddingUncheckedUpdateOneWithoutWorkItemNestedInput
  }

  export type WorkItemUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWorkItemTypeFieldUpdateOperationsInput | $Enums.WorkItemType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    storyPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    epicId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkItemUpdateWithoutEpicInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWorkItemTypeFieldUpdateOperationsInput | $Enums.WorkItemType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    storyPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: WorkItemUpdateOneWithoutChildrenNestedInput
    children?: WorkItemUpdateManyWithoutParentNestedInput
    stories?: WorkItemUpdateManyWithoutEpicNestedInput
    project?: ProjectUpdateOneRequiredWithoutWorkItemsNestedInput
    state?: WorkItemStateUpdateOneWithoutWorkItemsNestedInput
    assignee?: UserUpdateOneWithoutAssignedWorkItemsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedWorkItemsNestedInput
    sprint?: SprintUpdateOneWithoutWorkItemsNestedInput
    details?: WorkItemDetailUpdateOneWithoutWorkItemNestedInput
    dependenciesAsSource?: DependencyUpdateManyWithoutSourceItemNestedInput
    dependenciesAsTarget?: DependencyUpdateManyWithoutTargetItemNestedInput
    comments?: CommentUpdateManyWithoutWorkItemNestedInput
    attachments?: AttachmentUpdateManyWithoutWorkItemNestedInput
    timeLogs?: TimeLogUpdateManyWithoutWorkItemNestedInput
    snapshots?: WorkItemSnapshotUpdateManyWithoutWorkItemNestedInput
    tags?: TagOnWorkItemUpdateManyWithoutWorkItemNestedInput
    components?: ComponentOnWorkItemUpdateManyWithoutWorkItemNestedInput
    embedding?: WorkItemEmbeddingUpdateOneWithoutWorkItemNestedInput
  }

  export type WorkItemUncheckedUpdateWithoutEpicInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWorkItemTypeFieldUpdateOperationsInput | $Enums.WorkItemType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    storyPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: WorkItemUncheckedUpdateManyWithoutParentNestedInput
    stories?: WorkItemUncheckedUpdateManyWithoutEpicNestedInput
    details?: WorkItemDetailUncheckedUpdateOneWithoutWorkItemNestedInput
    dependenciesAsSource?: DependencyUncheckedUpdateManyWithoutSourceItemNestedInput
    dependenciesAsTarget?: DependencyUncheckedUpdateManyWithoutTargetItemNestedInput
    comments?: CommentUncheckedUpdateManyWithoutWorkItemNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutWorkItemNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutWorkItemNestedInput
    snapshots?: WorkItemSnapshotUncheckedUpdateManyWithoutWorkItemNestedInput
    tags?: TagOnWorkItemUncheckedUpdateManyWithoutWorkItemNestedInput
    components?: ComponentOnWorkItemUncheckedUpdateManyWithoutWorkItemNestedInput
    embedding?: WorkItemEmbeddingUncheckedUpdateOneWithoutWorkItemNestedInput
  }

  export type WorkItemUncheckedUpdateManyWithoutEpicInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWorkItemTypeFieldUpdateOperationsInput | $Enums.WorkItemType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    storyPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DependencyUpdateWithoutSourceItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    dependencyType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetItem?: WorkItemUpdateOneRequiredWithoutDependenciesAsTargetNestedInput
  }

  export type DependencyUncheckedUpdateWithoutSourceItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    dependencyType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetItemId?: StringFieldUpdateOperationsInput | string
  }

  export type DependencyUncheckedUpdateManyWithoutSourceItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    dependencyType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetItemId?: StringFieldUpdateOperationsInput | string
  }

  export type DependencyUpdateWithoutTargetItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    dependencyType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceItem?: WorkItemUpdateOneRequiredWithoutDependenciesAsSourceNestedInput
  }

  export type DependencyUncheckedUpdateWithoutTargetItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    dependencyType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceItemId?: StringFieldUpdateOperationsInput | string
  }

  export type DependencyUncheckedUpdateManyWithoutTargetItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    dependencyType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceItemId?: StringFieldUpdateOperationsInput | string
  }

  export type CommentUpdateWithoutWorkItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    sentimentLabel?: NullableStringFieldUpdateOperationsInput | string | null
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutWorkItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    sentimentLabel?: NullableStringFieldUpdateOperationsInput | string | null
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type CommentUncheckedUpdateManyWithoutWorkItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    sentimentScore?: NullableFloatFieldUpdateOperationsInput | number | null
    sentimentLabel?: NullableStringFieldUpdateOperationsInput | string | null
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type AttachmentUpdateWithoutWorkItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storagePath?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    ocrContent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
  }

  export type AttachmentUncheckedUpdateWithoutWorkItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storagePath?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    ocrContent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
  }

  export type AttachmentUncheckedUpdateManyWithoutWorkItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    storagePath?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    ocrContent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
  }

  export type TimeLogUpdateWithoutWorkItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    billable?: BoolFieldUpdateOperationsInput | boolean
    logDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTimeLogsNestedInput
    sprint?: SprintUpdateOneWithoutTimeLogsNestedInput
  }

  export type TimeLogUncheckedUpdateWithoutWorkItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    billable?: BoolFieldUpdateOperationsInput | boolean
    logDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TimeLogUncheckedUpdateManyWithoutWorkItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    billable?: BoolFieldUpdateOperationsInput | boolean
    logDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkItemSnapshotUpdateWithoutWorkItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    pointsRemaining?: NullableFloatFieldUpdateOperationsInput | number | null
    hoursRemaining?: NullableFloatFieldUpdateOperationsInput | number | null
    hoursSpent?: NullableFloatFieldUpdateOperationsInput | number | null
    daysInCurrentState?: IntFieldUpdateOperationsInput | number
    blockerIds?: WorkItemSnapshotUpdateblockerIdsInput | string[]
    snapshotDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sprint?: SprintUpdateOneWithoutSnapshotsNestedInput
  }

  export type WorkItemSnapshotUncheckedUpdateWithoutWorkItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    pointsRemaining?: NullableFloatFieldUpdateOperationsInput | number | null
    hoursRemaining?: NullableFloatFieldUpdateOperationsInput | number | null
    hoursSpent?: NullableFloatFieldUpdateOperationsInput | number | null
    daysInCurrentState?: IntFieldUpdateOperationsInput | number
    blockerIds?: WorkItemSnapshotUpdateblockerIdsInput | string[]
    snapshotDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkItemSnapshotUncheckedUpdateManyWithoutWorkItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    stateId?: NullableStringFieldUpdateOperationsInput | string | null
    pointsRemaining?: NullableFloatFieldUpdateOperationsInput | number | null
    hoursRemaining?: NullableFloatFieldUpdateOperationsInput | number | null
    hoursSpent?: NullableFloatFieldUpdateOperationsInput | number | null
    daysInCurrentState?: IntFieldUpdateOperationsInput | number
    blockerIds?: WorkItemSnapshotUpdateblockerIdsInput | string[]
    snapshotDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TagOnWorkItemUpdateWithoutWorkItemInput = {
    tag?: TagUpdateOneRequiredWithoutWorkItemsNestedInput
  }

  export type TagOnWorkItemUncheckedUpdateWithoutWorkItemInput = {
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type TagOnWorkItemUncheckedUpdateManyWithoutWorkItemInput = {
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type ComponentOnWorkItemUpdateWithoutWorkItemInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    component?: ComponentUpdateOneRequiredWithoutWorkItemsNestedInput
  }

  export type ComponentOnWorkItemUncheckedUpdateWithoutWorkItemInput = {
    componentId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComponentOnWorkItemUncheckedUpdateManyWithoutWorkItemInput = {
    componentId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkItemCreateManyStateInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.WorkItemType
    priority?: $Enums.Priority
    storyPoints?: number | null
    estimatedHours?: number | null
    remainingHours?: number | null
    order?: number
    dueDate?: Date | string | null
    completedAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    epicId?: string | null
    projectId: string
    assigneeId?: string | null
    creatorId: string
    sprintId?: string | null
  }

  export type WorkItemUpdateWithoutStateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWorkItemTypeFieldUpdateOperationsInput | $Enums.WorkItemType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    storyPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: WorkItemUpdateOneWithoutChildrenNestedInput
    children?: WorkItemUpdateManyWithoutParentNestedInput
    epic?: WorkItemUpdateOneWithoutStoriesNestedInput
    stories?: WorkItemUpdateManyWithoutEpicNestedInput
    project?: ProjectUpdateOneRequiredWithoutWorkItemsNestedInput
    assignee?: UserUpdateOneWithoutAssignedWorkItemsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedWorkItemsNestedInput
    sprint?: SprintUpdateOneWithoutWorkItemsNestedInput
    details?: WorkItemDetailUpdateOneWithoutWorkItemNestedInput
    dependenciesAsSource?: DependencyUpdateManyWithoutSourceItemNestedInput
    dependenciesAsTarget?: DependencyUpdateManyWithoutTargetItemNestedInput
    comments?: CommentUpdateManyWithoutWorkItemNestedInput
    attachments?: AttachmentUpdateManyWithoutWorkItemNestedInput
    timeLogs?: TimeLogUpdateManyWithoutWorkItemNestedInput
    snapshots?: WorkItemSnapshotUpdateManyWithoutWorkItemNestedInput
    tags?: TagOnWorkItemUpdateManyWithoutWorkItemNestedInput
    components?: ComponentOnWorkItemUpdateManyWithoutWorkItemNestedInput
    embedding?: WorkItemEmbeddingUpdateOneWithoutWorkItemNestedInput
  }

  export type WorkItemUncheckedUpdateWithoutStateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWorkItemTypeFieldUpdateOperationsInput | $Enums.WorkItemType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    storyPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    epicId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: WorkItemUncheckedUpdateManyWithoutParentNestedInput
    stories?: WorkItemUncheckedUpdateManyWithoutEpicNestedInput
    details?: WorkItemDetailUncheckedUpdateOneWithoutWorkItemNestedInput
    dependenciesAsSource?: DependencyUncheckedUpdateManyWithoutSourceItemNestedInput
    dependenciesAsTarget?: DependencyUncheckedUpdateManyWithoutTargetItemNestedInput
    comments?: CommentUncheckedUpdateManyWithoutWorkItemNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutWorkItemNestedInput
    timeLogs?: TimeLogUncheckedUpdateManyWithoutWorkItemNestedInput
    snapshots?: WorkItemSnapshotUncheckedUpdateManyWithoutWorkItemNestedInput
    tags?: TagOnWorkItemUncheckedUpdateManyWithoutWorkItemNestedInput
    components?: ComponentOnWorkItemUncheckedUpdateManyWithoutWorkItemNestedInput
    embedding?: WorkItemEmbeddingUncheckedUpdateOneWithoutWorkItemNestedInput
  }

  export type WorkItemUncheckedUpdateManyWithoutStateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumWorkItemTypeFieldUpdateOperationsInput | $Enums.WorkItemType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    storyPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedHours?: NullableFloatFieldUpdateOperationsInput | number | null
    remainingHours?: NullableFloatFieldUpdateOperationsInput | number | null
    order?: IntFieldUpdateOperationsInput | number
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    epicId?: NullableStringFieldUpdateOperationsInput | string | null
    projectId?: StringFieldUpdateOperationsInput | string
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: StringFieldUpdateOperationsInput | string
    sprintId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BoardLaneCreateManyBoardInput = {
    id?: string
    name: string
    position: number
    wipLimit?: number | null
    colorConfig?: JsonNullValueInput | InputJsonValue
    mappedStates?: BoardLaneCreatemappedStatesInput | string[]
    isCollapsed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BoardLaneUpdateWithoutBoardInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    wipLimit?: NullableIntFieldUpdateOperationsInput | number | null
    colorConfig?: JsonNullValueInput | InputJsonValue
    mappedStates?: BoardLaneUpdatemappedStatesInput | string[]
    isCollapsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BoardLaneUncheckedUpdateWithoutBoardInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    wipLimit?: NullableIntFieldUpdateOperationsInput | number | null
    colorConfig?: JsonNullValueInput | InputJsonValue
    mappedStates?: BoardLaneUpdatemappedStatesInput | string[]
    isCollapsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BoardLaneUncheckedUpdateManyWithoutBoardInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    wipLimit?: NullableIntFieldUpdateOperationsInput | number | null
    colorConfig?: JsonNullValueInput | InputJsonValue
    mappedStates?: BoardLaneUpdatemappedStatesInput | string[]
    isCollapsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagOnWorkItemCreateManyTagInput = {
    workItemId: string
  }

  export type TagOnWorkItemUpdateWithoutTagInput = {
    workItem?: WorkItemUpdateOneRequiredWithoutTagsNestedInput
  }

  export type TagOnWorkItemUncheckedUpdateWithoutTagInput = {
    workItemId?: StringFieldUpdateOperationsInput | string
  }

  export type TagOnWorkItemUncheckedUpdateManyWithoutTagInput = {
    workItemId?: StringFieldUpdateOperationsInput | string
  }

  export type ComponentOnWorkItemCreateManyComponentInput = {
    workItemId: string
    assignedAt?: Date | string
  }

  export type ComponentOnWorkItemUpdateWithoutComponentInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workItem?: WorkItemUpdateOneRequiredWithoutComponentsNestedInput
  }

  export type ComponentOnWorkItemUncheckedUpdateWithoutComponentInput = {
    workItemId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComponentOnWorkItemUncheckedUpdateManyWithoutComponentInput = {
    workItemId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}